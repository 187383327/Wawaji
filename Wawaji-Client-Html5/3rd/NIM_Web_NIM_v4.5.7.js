(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["NIM"] = factory();
	else
		root["NIM"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(54);

	module.exports = __webpack_require__(121);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var platform = __webpack_require__(9);
	var io = __webpack_require__(19);
	var naturalSort = __webpack_require__(28);
	var deep = __webpack_require__(22);
	__webpack_require__(44);
	var NIMError = __webpack_require__(4);

	/**
	 * NIM util 工具方法, 通过 `NIM.util` 来获取此工具的引用
	 *
	 * @namespace util
	 */
	var util = __webpack_require__(17);
	var window = util.getGlobal();
	var regWhiteSpace = /\s+/;

	util.shouldDisplayInstallFlashHint = function () {
	  var name = platform.name.toLowerCase();
	  if (name === 'ie') {
	    var version = +platform.version || 0;
	    version = Math.floor(version);
	    return version === 7 && !io.Transport.flashsocket.check();
	  }
	  return false;
	};

	util.deduplicate = function (arr) {
	  var rtn = [];
	  arr.forEach(function (item) {
	    if (rtn.indexOf(item) === -1) {
	      rtn.push(item);
	    }
	  });
	  return rtn;
	};

	util.capFirstLetter = function (str) {
	  if (!str) {
	    return '';
	  }
	  str = '' + str;
	  return str.slice(0, 1).toUpperCase() + str.slice(1);
	};

	/**
	 * 生成一个 32 位的 [GUID](https://en.wikipedia.org/wiki/Globally_unique_identifier)/[UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
	 *
	 * @memberOf util
	 * @method guid
	 *
	 * @return {String}   guid/uuid
	 */
	util.guid = function () {
	  var _s4 = function _s4() {
	    return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
	  };
	  return function () {
	    return _s4() + _s4() + _s4() + _s4() + _s4() + _s4() + _s4() + _s4();
	  };
	}();

	util.extend = function (o1, o2, override) {
	  for (var i in o2) {
	    if (typeof o1[i] === 'undefined' || override === true) {
	      o1[i] = o2[i];
	    }
	  }
	};

	util.filterObj = function (base, props) {
	  var obj = {};
	  if (util.isString(props)) {
	    props = props.split(regWhiteSpace);
	  }
	  props.forEach(function (prop) {
	    if (base.hasOwnProperty(prop)) {
	      obj[prop] = base[prop];
	    }
	  });
	  return obj;
	};

	util.simpleClone = function (obj) {
	  return JSON.parse(JSON.stringify(obj));
	};

	/**
	 * 将 target 复制到 base
	 *
	 * @private
	 * @param  {Object} target 待复制的对象
	 * @param  {Object} base   复制后的对象
	 * @return {Object}        复制后的对象
	 */
	util.copy = function (target, base) {
	  base = base || {};
	  if (!target) {
	    return base;
	  }
	  Object.keys(target).forEach(function (key) {
	    if (util.exist(target[key])) {
	      base[key] = target[key];
	    }
	  });
	  return base;
	};

	/**
	 * 将 target 复制到 base，null值也复制
	 *
	 * @private
	 * @param  {Object} target 待复制的对象
	 * @param  {Object} base   复制后的对象
	 * @return {Object}        复制后的对象
	 */
	util.copyWithNull = function (target, base) {
	  base = base || {};
	  if (!target) {
	    return base;
	  }
	  Object.keys(target).forEach(function (key) {
	    if (util.exist(target[key]) || util.isnull(target[key])) {
	      base[key] = target[key];
	    }
	  });
	  return base;
	};

	util.findObjIndexInArray = function (array, options) {
	  array = array || [];
	  var keyPath = options.keyPath || 'id';
	  var pos = -1;
	  array.some(function (obj, index) {
	    if (deep(obj, keyPath) === options.value) {
	      pos = index;
	      return true;
	    }
	  });
	  return pos;
	};

	/**
	 * 在数组里面找 keyPath 对应的属性值为 value 的元素
	 * - 数组的每一项均为对象, 并且必须有由 keyPath 指定的属性
	 *
	 * @memberOf util
	 * @method findObjInArray
	 *
	 * @param  {Object[]}   array               待查找的数组
	 * @param  {Object}     options             查找的条件
	 * @param  {String}     [options.keyPath]   keyPath, 匹配的字段, 默认为 'id'
	 * @param  {Anything}   [options.value]     匹配的值
	 * @return {Object}                         找到的元素, 或者 null
	 *
	 * @example
	 * var array = [
	 *     {name: 'tom'},
	 *     {name: 'jack'},
	 *     {name: 'dan'}
	 * ];
	 * var obj = NIM.util.findObjInArray(array, {
	 *     keyPath: 'name',
	 *     value: 'jack'
	 * });
	 * // obj 为 {name: 'jack'}
	 */
	util.findObjInArray = function (array, options) {
	  var index = util.findObjIndexInArray(array, options);
	  return index === -1 ? null : array[index];
	};

	/**
	 * 合并数组
	 * - 此方法接收不定量参数
	 *     - 最后一个参数如果是对象, 那么就是配置参数
	 *     - 除了配置参数之外, 所有其它的参数都必须是数组, 它们都会被合并
	 * - 如果两个对象`keyPath`字段对应的属性值相同, 后面的对象会被合并到前面的对象
	 *
	 * @memberOf util
	 * @method mergeObjArray
	 *
	 * @param  {Object[]}   arr1                    待合并的数组
	 * @param  {Object[]}   arr2                    待合并的数组
	 * @param  {Object}     [options]               配置参数
	 * @param  {String}     [options.keyPath='id']  `keyPath`, 去重的字段, 默认为 `id`
	 * @param  {Boolean}    [options.notSort]       是否要排序, 默认`false`要排序, 传`true`则不排序
	 * @param  {Function}   [options.compare]       决定排序的方法, 如果不提供, 那么使用 {@link NIM.naturalSort|NIM.naturalSort} 进行排序
	 * @param  {String}     [options.sortPath]      `sortPath`, 排序用的字段, 默认为 `keyPath`
	 * @param  {Boolean}    [options.insensitive]   排序时是否不区分大小写, 默认区分
	 * @param  {Boolean}    [options.desc]          是否逆序, 默认正序
	 * @return {Object[]}                           合并并排序后的数组
	 *
	 * @example
	 * var arr1 = [
	 *     {
	 *         account: 'tom',
	 *         name: 'T'
	 *     }
	 * ];
	 * var arr2 = [
	 *     {
	 *         account: 'adam'
	 *     },
	 *     {
	 *         account: 'tom',
	 *         name: 'T-new'
	 *     }
	 * ];
	 * var options = {
	 *     keyPath: 'account'
	 * };
	 * var resultArray = NIM.util.mergeObjArray(arr1, arr2, options);
	 * // resultArray为
	 * // [
	 * //     {account: 'adam'},
	 * //     {account: 'tom', name: 'T-new'},
	 * // ]
	 */
	util.mergeObjArray = function () {
	  var base = [];
	  // 截取除了最后一个之外的参数, 这些就是待合并的数组
	  var arrays = [].slice.call(arguments, 0, -1);
	  // 最后一个参数是 options, 如果它是数组, 那么它也是待合并的数组
	  var options = arguments[arguments.length - 1];
	  if (util.isArray(options)) {
	    arrays.push(options);
	    options = {};
	  }
	  // options
	  var keyPath = options.keyPath = options.keyPath || 'id';
	  options.sortPath = options.sortPath || keyPath;
	  // 如果 base 的长度为 0, 那么直接拷贝后一个数组里面的所有元素
	  while (!base.length && !!arrays.length) {
	    base = arrays.shift() || [];
	    base = base.slice(0);
	  }
	  // 合并所有的数组
	  var index;
	  arrays.forEach(function (array) {
	    if (!array) {
	      return;
	    }
	    array.forEach(function (item) {
	      index = util.findObjIndexInArray(base, {
	        keyPath: keyPath,
	        value: deep(item, keyPath)
	      });
	      if (index !== -1) {
	        // 不修改原有的对象, 生成新的
	        base[index] = util.merge({}, base[index], item);
	      } else {
	        base.push(item);
	      }
	    });
	  });
	  // 排序
	  if (!options.notSort) {
	    base = util.sortObjArray(base, options);
	  }
	  return base;
	};

	/**
	 * 从数组里面去除某些项
	 *
	 * @memberOf util
	 * @method cutObjArray
	 *
	 * @param  {Array}      base                    基数组
	 * @param  {Object[]}   arr1                    待去除的数组
	 * @param  {Object[]}   arr2                    待去除的数组
	 * @param  {Object}     options                 配置参数
	 * @param  {String}     [options.keyPath='id']  `keyPath`, 去重的字段, 默认为 `id`
	 * @return {Array}                              去除后的数组
	 *
	 * @example
	 * var olds = [
	 *     { account: 'a' },
	 *     { account: 'b' },
	 *     { account: 'c' }
	 * ];
	 * var invalids = [
	 *     { account: 'b' }
	 * ];
	 * var options = {
	 *     keyPath: 'account'
	 * };
	 * var array = NIM.util.cutObjArray(olds, invalids, options);
	 * // array 为
	 * // [
	 * //     { account: 'a' },
	 * //     { account: 'c' }
	 * // ]
	 */
	util.cutObjArray = function (base) {
	  var rtn = base.slice(0);
	  var argsLength = arguments.length;
	  // 截取除了第一个和最后一个之外的参数, 这些就是待删除的数组
	  var arrays = [].slice.call(arguments, 1, argsLength - 1);
	  // 最后一个参数是 options, 如果它不是对象, 那么它也是待删除的数组
	  var options = arguments[argsLength - 1];
	  if (!util.isObject(options)) {
	    arrays.push(options);
	    options = {};
	  }
	  // keyPath
	  var keyPath = options.keyPath = options.keyPath || 'id';
	  // 删除
	  var index;
	  arrays.forEach(function (cuts) {
	    if (!util.isArray(cuts)) {
	      cuts = [cuts];
	    }
	    cuts.forEach(function (cut) {
	      if (!cut) {
	        return;
	      }
	      options.value = deep(cut, keyPath);
	      index = util.findObjIndexInArray(rtn, options);
	      if (index !== -1) {
	        rtn.splice(index, 1);
	      }
	    });
	  });
	  return rtn;
	};

	/**
	 * 返回排序后的数组
	 * - 数组的每一项都为 `Object`, 并且必须有由 `sortPath` 指定的属性
	 *
	 * @memberOf util
	 * @method sortObjArray
	 *
	 * @param  {Object[]}   array                   待排序的数组
	 * @param  {Object}     [options]               配置参数
	 * @param {Function}    [options.compare]       决定排序的方法, 如果不提供, 那么使用 {@link NIM.naturalSort|NIM.naturalSort} 进行排序
	 * @param  {String}     [options.sortPath]      `sortPath`, 排序用的字段, 默认为 `id`
	 * @param  {Boolean}    [options.insensitive]   排序时是否不区分大小写, 默认区分
	 * @param  {Boolean}    [options.desc]          是否逆序, 默认正序
	 * @return {Object[]}                           排序后的数组
	 *
	 * @example
	 * var array = [
	 *     { account: 'b' },
	 *     { account: 'a' }
	 * ];
	 * var options = {
	 *     sortPath: 'account'
	 * };
	 * NIM.util.sortObjArray(array, options);
	 * // array 为
	 * //[
	 * //    { account: 'a' },
	 * //    { account: 'b' }
	 * //]
	 */
	util.sortObjArray = function (array, options) {
	  options = options || {};
	  var sortPath = options.sortPath || 'id';
	  naturalSort.insensitive = !!options.insensitive;
	  var desc = !!options.desc;
	  var pa, pb;
	  var compare;
	  if (util.isFunction(options.compare)) {
	    compare = options.compare;
	  } else {
	    compare = function compare(a, b) {
	      pa = deep(a, sortPath);
	      pb = deep(b, sortPath);
	      if (desc) {
	        return naturalSort(pb, pa);
	      } else {
	        return naturalSort(pa, pb);
	      }
	    };
	  }
	  return array.sort(compare);
	};

	util.emptyFunc = function () {};

	util.isEmptyFunc = function (func) {
	  return func === util.emptyFunc;
	};

	util.notEmptyFunc = function (func) {
	  return func !== util.emptyFunc;
	};

	util.splice = function (obj, start, end) {
	  return [].splice.call(obj, start, end);
	};

	// 重新切分数据，将一维数组切分成每列num个元素的二维数组
	util.reshape2d = function (obj, num) {
	  if (Array.isArray(obj)) {
	    util.verifyParamType('type', num, 'number');
	    var len = obj.length;
	    if (len <= num) {
	      return [obj];
	    } else {
	      var count = Math.ceil(len / num);
	      var result = [];
	      for (var i = 0; i < count; i++) {
	        result.push(obj.slice(i * num, (i + 1) * num));
	      }
	      return result;
	    }
	  }
	  // 如果不是数组则不做任何处理
	  return obj;
	};

	// 扁平化数据，将2d数组转化为一维数组
	util.flatten2d = function (obj) {
	  if (Array.isArray(obj)) {
	    var _ret = function () {
	      var result = [];
	      obj.forEach(function (item) {
	        result = result.concat(item);
	      });
	      return {
	        v: result
	      };
	    }();

	    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	  }
	  return obj;
	};

	// 数组去重
	util.dropArrayDuplicates = function (arr) {
	  if (Array.isArray(arr)) {
	    var map = {};
	    var result = [];
	    while (arr.length > 0) {
	      var item = arr.shift();
	      map[item] = true;
	    }
	    for (var key in map) {
	      if (map[key] === true) {
	        result.push(key);
	      }
	    }
	    return result;
	  }
	  return arr;
	};

	util.onError = function (msg) {
	  throw new NIMError(msg);
	};

	/*
	 * 参数处理相关 API
	 */

	util.verifyParamPresent = function (name, value, prefix) {
	  prefix = prefix || '';
	  var absent = false;
	  switch (util.typeOf(value)) {
	    case 'undefined':
	    case 'null':
	      absent = true;
	      break;
	    case 'string':
	      if (value === '') {
	        absent = true;
	      }
	      break;
	    case 'object':
	      if (!Object.keys(value).length) {
	        absent = true;
	      }
	      break;
	    case 'array':
	      if (!value.length) {
	        absent = true;
	      } else {
	        value.some(function (item) {
	          if (util.notexist(item)) {
	            absent = true;
	            return true;
	          }
	        });
	      }
	      break;
	    default:
	      break;
	  }
	  if (absent) {
	    util.onParamAbsent(prefix + name);
	  }
	};

	util.onParamAbsent = function (name) {
	  util.onParamError('缺少参数"' + name + '", 请确保参数不是 空字符串、空对象、空数组、null或undefined, 或者数组的内容不是 null/undefined');
	};

	util.verifyParamAbsent = function (name, value, prefix) {
	  prefix = prefix || '';
	  if (value !== undefined) {
	    util.onParamPresent(prefix + name);
	  }
	};

	util.onParamPresent = function (name) {
	  util.onParamError('多余的参数"' + name + '"');
	};

	util.verifyParamType = function (name, value, validTypes) {
	  var type = util.typeOf(value).toLowerCase();
	  if (!util.isArray(validTypes)) {
	    validTypes = [validTypes];
	  }
	  validTypes = validTypes.map(function (type) {
	    return type.toLowerCase();
	  });
	  var valid = true;
	  if (validTypes.indexOf(type) === -1) {
	    valid = false;
	  }
	  switch (type) {
	    case 'number':
	      if (isNaN(value)) {
	        valid = false;
	      }
	      break;
	    default:
	      break;
	  }
	  if (!valid) {
	    util.onParamInvalidType(name, validTypes);
	  }
	};

	util.onParamInvalidType = function (name, validTypes, prefix) {
	  prefix = prefix || '';
	  if (util.isArray(validTypes)) {
	    validTypes = validTypes.map(function (type) {
	      return '"' + type + '"';
	    });
	    validTypes = validTypes.join(', ');
	  } else {
	    validTypes = '"' + validTypes + '"';
	  }
	  util.onParamError('参数"' + prefix + name + '"类型错误, 合法的类型包括: [' + validTypes + ']');
	};

	util.verifyParamValid = function (name, value, validValues) {
	  if (!util.isArray(validValues)) {
	    validValues = [validValues];
	  }
	  if (validValues.indexOf(value) === -1) {
	    util.onParamInvalidValue(name, validValues);
	  }
	};

	util.onParamInvalidValue = function (name, validValues) {
	  if (!util.isArray(validValues)) {
	    validValues = [validValues];
	  }
	  validValues = validValues.map(function (value) {
	    return '"' + value + '"';
	  });
	  if (util.isArray(validValues)) {
	    validValues = validValues.join(', ');
	  }
	  util.onParamError('参数"' + name + '"值错误, 合法的值包括: [' + validValues + ']');
	};

	util.verifyParamMin = function (name, value, min) {
	  if (value < min) {
	    util.onParamError('参数' + name + '的值不能小于' + min);
	  }
	};

	util.verifyParamMax = function (name, value, max) {
	  if (value > max) {
	    util.onParamError('参数' + name + '的值不能大于' + max);
	  }
	};

	util.verifyArrayMax = function (name, value, max) {
	  if (value.length > max) {
	    util.onParamError('参数' + name + '的长度不能大于' + max);
	  }
	};

	util.verifyEmail = function () {
	  var reg = /^\S+@\S+$/;
	  return function (name, value) {
	    if (!reg.test(value)) {
	      util.onParamError('参数' + name + '邮箱格式错误, 合法格式必须包含@符号, @符号前后至少要各有一个字符');
	    }
	  };
	}();

	util.verifyTel = function () {
	  var reg = /^[+\-()\d]+$/;
	  return function (name, value) {
	    if (!reg.test(value)) {
	      util.onParamError('参数' + name + '电话号码格式错误, 合法字符包括+、-、英文括号和数字');
	    }
	  };
	}();

	util.verifyBirth = function () {
	  var reg = /^(\d{4})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$/;
	  return function (name, value) {
	    if (!reg.test(value)) {
	      util.onParamError('参数' + name + '生日格式错误, 合法为"yyyy-MM-dd"');
	    }
	  };
	}();

	util.onParamError = function (msg) {
	  util.onError(msg);
	};

	/**
	 * 验证options及其属性是否存在
	 *
	 * @private
	 * @param  {Object}       options       配置参数
	 * @param  {String|Array} params        属性列表
	 * @param  {Boolean}      shouldPresent 是否应该存在
	 * @return {Void}
	 */
	util.verifyOptions = function (options, params, shouldPresent, prefix) {
	  options = options || {};
	  // util.verifyParamPresent('options', options)
	  if (params) {
	    if (util.isString(params)) {
	      params = params.split(regWhiteSpace);
	    }
	    if (util.isArray(params)) {
	      shouldPresent = shouldPresent === undefined ? true : !!shouldPresent;
	      var func = shouldPresent ? util.verifyParamPresent : util.verifyParamAbsent;
	      params.forEach(function (param) {
	        func.call(util, param, options[param], prefix);
	      });
	    }
	  }
	  return options;
	};

	util.verifyParamAtLeastPresentOne = function (options, params) {
	  if (params) {
	    if (util.isString(params)) {
	      params = params.split(regWhiteSpace);
	    }
	    if (util.isArray(params)) {
	      var presentOne = params.some(function (param) {
	        return util.exist(options[param]);
	      });
	      if (!presentOne) {
	        util.onParamError('以下参数[' + params.join(', ') + ']至少需要传入一个');
	      }
	    }
	  }
	};

	util.verifyParamPresentJustOne = function (options, params) {
	  if (params) {
	    if (util.isString(params)) {
	      params = params.split(regWhiteSpace);
	    }
	    if (util.isArray(params)) {
	      var counter = params.reduce(function (p, param) {
	        if (util.exist(options[param])) {
	          p++;
	        }
	        return p;
	      }, 0);
	      if (counter !== 1) {
	        util.onParamError('以下参数[' + params.join(', ') + ']必须且只能传入一个');
	      }
	    }
	  }
	};

	util.verifyBooleanWithDefault = function (options, name, defaultValue, prefix) {
	  if (util.undef(defaultValue)) {
	    defaultValue = true;
	  }
	  if (regWhiteSpace.test(name)) {
	    name = name.split(regWhiteSpace);
	  }
	  if (util.isArray(name)) {
	    name.forEach(function (n) {
	      util.verifyBooleanWithDefault(options, n, defaultValue, prefix);
	    });
	  } else {
	    if (typeof options[name] === 'undefined') {
	      options[name] = defaultValue;
	    } else if (!util.isBoolean(options[name])) {
	      util.onParamInvalidType(name, 'boolean', prefix);
	    }
	  }
	};

	util.verifyFileInput = function (fileInput) {
	  util.verifyParamPresent('fileInput', fileInput);
	  if (util.isString(fileInput)) {
	    fileInput = document.getElementById(fileInput);
	    if (!fileInput) {
	      util.onParamError('找不到要上传的文件对应的input, 请检查fileInput id');
	    }
	  }
	  if (!fileInput.tagName || fileInput.tagName.toLowerCase() !== 'input' || fileInput.type.toLowerCase() !== 'file') {
	    util.onParamError('请提供正确的 fileInput, 必须为 file 类型的 input 节点');
	  }
	  return fileInput;
	};

	/**
	 * 验证是否是合法的文件类型
	 *
	 * @private
	 * @param  {type} type 待验证的文件类型
	 * @return {bool}      是否是合法的文件类型
	 */
	util.verifyFileType = function (type) {
	  util.verifyParamValid('type', type, util.validFileTypes);
	};

	util.verifyCallback = function (options, name) {
	  if (regWhiteSpace.test(name)) {
	    name = name.split(regWhiteSpace);
	  }
	  if (util.isArray(name)) {
	    name.forEach(function (n) {
	      util.verifyCallback(options, n);
	    });
	  } else {
	    if (!options[name]) {
	      options[name] = util.emptyFunc;
	    } else if (!util.isFunction(options[name])) {
	      util.onParamInvalidType(name, 'function');
	    }
	  }
	};

	util.verifyFileUploadCallback = function (options) {
	  util.verifyCallback(options, 'uploadprogress uploaddone uploaderror uploadcancel');
	};

	/*
	 * 文件相关 API
	 */

	util.validFileTypes = ['image', 'audio', 'video', 'file'];

	util.validFileExts = {
	  image: ['bmp', 'gif', 'jpg', 'jpeg', 'jng', 'png', 'webp'],
	  audio: ['mp3', 'wav', 'aac', 'wma', 'wmv', 'amr', 'mp2', 'flac', 'vorbis', 'ac3'],
	  video: ['mp4', 'rm', 'rmvb', 'wmv', 'avi', 'mpg', 'mpeg']
	};

	util.filterFiles = function (files, targetType) {
	  targetType = targetType.toLowerCase();
	  var anyfile = targetType === 'file';
	  var arr = [];
	  var ext;
	  var mime;
	  var type;
	  //   var subtype
	  [].forEach.call(files, function (file) {
	    if (anyfile) {
	      arr.push(file);
	    } else {
	      ext = file.name.slice(file.name.lastIndexOf('.') + 1);
	      mime = file.type.split('/');
	      if (!!mime[0] && !!mime[1]) {
	        type = mime[0].toLowerCase();
	        // subtype = mime[1].toLowerCase()
	        var match = false;
	        if (type === targetType) {
	          match = true;
	        } else {
	          match = util.validFileExts[targetType].indexOf(ext) !== -1;
	        }
	        if (match) {
	          arr.push(file);
	        }
	      } else {
	        // unknow mime
	      }
	    }
	  });
	  return arr;
	};

	var supportFormData = util.supportFormData = util.notundef(window.FormData);
	util.getFileName = function () {
	  return function (fileInput) {
	    fileInput = util.verifyFileInput(fileInput);
	    if (supportFormData) {
	      return fileInput.files[0].name;
	    } else {
	      return fileInput.value.slice(fileInput.value.lastIndexOf('\\') + 1);
	    }
	  };
	}();

	util.sizeText = function () {
	  var sizeUnit = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'BB'];
	  return function (size) {
	    var text;
	    var index = 0;
	    do {
	      size = Math.floor(size * 100) / 100;
	      var unit = sizeUnit[index];
	      text = size + unit;
	      size /= 1024;
	      index++;
	    } while (size > 1);
	    return text;
	  };
	}();

	util.promises2cmds = function (promises) {
	  return promises.map(function (promise) {
	    return promise.cmd;
	  });
	};

	util.objs2accounts = function (objs) {
	  return objs.map(function (obj) {
	    return obj.account;
	  });
	};

	util.teams2ids = function (teams) {
	  return teams.map(function (team) {
	    return team.teamId;
	  });
	};

	util.objs2ids = function (objs) {
	  return objs.map(function (obj) {
	    return obj.id;
	  });
	};

	util.getMaxUpdateTime = function (array) {
	  var timetags = array.map(function (item) {
	    return +item.updateTime;
	  });
	  return Math.max.apply(Math, timetags);
	};

	util.genCheckUniqueFunc = function (keyPath, size) {
	  var array = [];
	  var set = {};
	  keyPath = keyPath || 'id';
	  size = size || 1000;
	  return function (obj) {
	    var id;
	    if (array.length >= size) {
	      id = array.shift();
	      delete set[id];
	    }
	    id = deep(obj, keyPath);
	    if (!set[id]) {
	      set[id] = true;
	      array.push(id);
	      return true;
	    } else {
	      return false;
	    }
	  };
	};

	module.exports = util;

	__webpack_require__(45);

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(process, global) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.0.5
	 */

	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    (global.ES6Promise = factory());
	}(this, (function () { 'use strict';

	function objectOrFunction(x) {
	  return typeof x === 'function' || typeof x === 'object' && x !== null;
	}

	function isFunction(x) {
	  return typeof x === 'function';
	}

	var _isArray = undefined;
	if (!Array.isArray) {
	  _isArray = function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	  };
	} else {
	  _isArray = Array.isArray;
	}

	var isArray = _isArray;

	var len = 0;
	var vertxNext = undefined;
	var customSchedulerFn = undefined;

	var asap = function asap(callback, arg) {
	  queue[len] = callback;
	  queue[len + 1] = arg;
	  len += 2;
	  if (len === 2) {
	    // If len is 2, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    if (customSchedulerFn) {
	      customSchedulerFn(flush);
	    } else {
	      scheduleFlush();
	    }
	  }
	};

	function setScheduler(scheduleFn) {
	  customSchedulerFn = scheduleFn;
	}

	function setAsap(asapFn) {
	  asap = asapFn;
	}

	var browserWindow = typeof window !== 'undefined' ? window : undefined;
	var browserGlobal = browserWindow || {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

	// test for web worker but not in IE10
	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

	// node
	function useNextTick() {
	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	  // see https://github.com/cujojs/when/issues/410 for details
	  return function () {
	    return process.nextTick(flush);
	  };
	}

	// vertx
	function useVertxTimer() {
	  if (typeof vertxNext !== 'undefined') {
	    return function () {
	      vertxNext(flush);
	    };
	  }

	  return useSetTimeout();
	}

	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });

	  return function () {
	    node.data = iterations = ++iterations % 2;
	  };
	}

	// web worker
	function useMessageChannel() {
	  var channel = new MessageChannel();
	  channel.port1.onmessage = flush;
	  return function () {
	    return channel.port2.postMessage(0);
	  };
	}

	function useSetTimeout() {
	  // Store setTimeout reference so es6-promise will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var globalSetTimeout = setTimeout;
	  return function () {
	    return globalSetTimeout(flush, 1);
	  };
	}

	var queue = new Array(1000);
	function flush() {
	  for (var i = 0; i < len; i += 2) {
	    var callback = queue[i];
	    var arg = queue[i + 1];

	    callback(arg);

	    queue[i] = undefined;
	    queue[i + 1] = undefined;
	  }

	  len = 0;
	}

	function attemptVertx() {
	  try {
	    var r = require;
	    var vertx = __webpack_require__(47);
	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
	    return useVertxTimer();
	  } catch (e) {
	    return useSetTimeout();
	  }
	}

	var scheduleFlush = undefined;
	// Decide what async method to use to triggering processing of queued callbacks:
	if (isNode) {
	  scheduleFlush = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush = useMutationObserver();
	} else if (isWorker) {
	  scheduleFlush = useMessageChannel();
	} else if (browserWindow === undefined && "function" === 'function') {
	  scheduleFlush = attemptVertx();
	} else {
	  scheduleFlush = useSetTimeout();
	}

	function then(onFulfillment, onRejection) {
	  var _arguments = arguments;

	  var parent = this;

	  var child = new this.constructor(noop);

	  if (child[PROMISE_ID] === undefined) {
	    makePromise(child);
	  }

	  var _state = parent._state;

	  if (_state) {
	    (function () {
	      var callback = _arguments[_state - 1];
	      asap(function () {
	        return invokeCallback(_state, child, callback, parent._result);
	      });
	    })();
	  } else {
	    subscribe(parent, child, onFulfillment, onRejection);
	  }

	  return child;
	}

	/**
	  `Promise.resolve` returns a promise that will become resolved with the
	  passed `value`. It is shorthand for the following:

	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    resolve(1);
	  });

	  promise.then(function(value){
	    // value === 1
	  });
	  ```

	  Instead of writing the above, your code now simply becomes the following:

	  ```javascript
	  let promise = Promise.resolve(1);

	  promise.then(function(value){
	    // value === 1
	  });
	  ```

	  @method resolve
	  @static
	  @param {Any} value value that the returned promise will be resolved with
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve(object) {
	  /*jshint validthis:true */
	  var Constructor = this;

	  if (object && typeof object === 'object' && object.constructor === Constructor) {
	    return object;
	  }

	  var promise = new Constructor(noop);
	  _resolve(promise, object);
	  return promise;
	}

	var PROMISE_ID = Math.random().toString(36).substring(16);

	function noop() {}

	var PENDING = void 0;
	var FULFILLED = 1;
	var REJECTED = 2;

	var GET_THEN_ERROR = new ErrorObject();

	function selfFulfillment() {
	  return new TypeError("You cannot resolve a promise with itself");
	}

	function cannotReturnOwn() {
	  return new TypeError('A promises callback cannot return that same promise.');
	}

	function getThen(promise) {
	  try {
	    return promise.then;
	  } catch (error) {
	    GET_THEN_ERROR.error = error;
	    return GET_THEN_ERROR;
	  }
	}

	function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	  try {
	    then.call(value, fulfillmentHandler, rejectionHandler);
	  } catch (e) {
	    return e;
	  }
	}

	function handleForeignThenable(promise, thenable, then) {
	  asap(function (promise) {
	    var sealed = false;
	    var error = tryThen(then, thenable, function (value) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	      if (thenable !== value) {
	        _resolve(promise, value);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;

	      _reject(promise, reason);
	    }, 'Settle: ' + (promise._label || ' unknown promise'));

	    if (!sealed && error) {
	      sealed = true;
	      _reject(promise, error);
	    }
	  }, promise);
	}

	function handleOwnThenable(promise, thenable) {
	  if (thenable._state === FULFILLED) {
	    fulfill(promise, thenable._result);
	  } else if (thenable._state === REJECTED) {
	    _reject(promise, thenable._result);
	  } else {
	    subscribe(thenable, undefined, function (value) {
	      return _resolve(promise, value);
	    }, function (reason) {
	      return _reject(promise, reason);
	    });
	  }
	}

	function handleMaybeThenable(promise, maybeThenable, then$$) {
	  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
	    handleOwnThenable(promise, maybeThenable);
	  } else {
	    if (then$$ === GET_THEN_ERROR) {
	      _reject(promise, GET_THEN_ERROR.error);
	    } else if (then$$ === undefined) {
	      fulfill(promise, maybeThenable);
	    } else if (isFunction(then$$)) {
	      handleForeignThenable(promise, maybeThenable, then$$);
	    } else {
	      fulfill(promise, maybeThenable);
	    }
	  }
	}

	function _resolve(promise, value) {
	  if (promise === value) {
	    _reject(promise, selfFulfillment());
	  } else if (objectOrFunction(value)) {
	    handleMaybeThenable(promise, value, getThen(value));
	  } else {
	    fulfill(promise, value);
	  }
	}

	function publishRejection(promise) {
	  if (promise._onerror) {
	    promise._onerror(promise._result);
	  }

	  publish(promise);
	}

	function fulfill(promise, value) {
	  if (promise._state !== PENDING) {
	    return;
	  }

	  promise._result = value;
	  promise._state = FULFILLED;

	  if (promise._subscribers.length !== 0) {
	    asap(publish, promise);
	  }
	}

	function _reject(promise, reason) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	  promise._state = REJECTED;
	  promise._result = reason;

	  asap(publishRejection, promise);
	}

	function subscribe(parent, child, onFulfillment, onRejection) {
	  var _subscribers = parent._subscribers;
	  var length = _subscribers.length;

	  parent._onerror = null;

	  _subscribers[length] = child;
	  _subscribers[length + FULFILLED] = onFulfillment;
	  _subscribers[length + REJECTED] = onRejection;

	  if (length === 0 && parent._state) {
	    asap(publish, parent);
	  }
	}

	function publish(promise) {
	  var subscribers = promise._subscribers;
	  var settled = promise._state;

	  if (subscribers.length === 0) {
	    return;
	  }

	  var child = undefined,
	      callback = undefined,
	      detail = promise._result;

	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];

	    if (child) {
	      invokeCallback(settled, child, callback, detail);
	    } else {
	      callback(detail);
	    }
	  }

	  promise._subscribers.length = 0;
	}

	function ErrorObject() {
	  this.error = null;
	}

	var TRY_CATCH_ERROR = new ErrorObject();

	function tryCatch(callback, detail) {
	  try {
	    return callback(detail);
	  } catch (e) {
	    TRY_CATCH_ERROR.error = e;
	    return TRY_CATCH_ERROR;
	  }
	}

	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value = undefined,
	      error = undefined,
	      succeeded = undefined,
	      failed = undefined;

	  if (hasCallback) {
	    value = tryCatch(callback, detail);

	    if (value === TRY_CATCH_ERROR) {
	      failed = true;
	      error = value.error;
	      value = null;
	    } else {
	      succeeded = true;
	    }

	    if (promise === value) {
	      _reject(promise, cannotReturnOwn());
	      return;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }

	  if (promise._state !== PENDING) {
	    // noop
	  } else if (hasCallback && succeeded) {
	      _resolve(promise, value);
	    } else if (failed) {
	      _reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      _reject(promise, value);
	    }
	}

	function initializePromise(promise, resolver) {
	  try {
	    resolver(function resolvePromise(value) {
	      _resolve(promise, value);
	    }, function rejectPromise(reason) {
	      _reject(promise, reason);
	    });
	  } catch (e) {
	    _reject(promise, e);
	  }
	}

	var id = 0;
	function nextId() {
	  return id++;
	}

	function makePromise(promise) {
	  promise[PROMISE_ID] = id++;
	  promise._state = undefined;
	  promise._result = undefined;
	  promise._subscribers = [];
	}

	function Enumerator(Constructor, input) {
	  this._instanceConstructor = Constructor;
	  this.promise = new Constructor(noop);

	  if (!this.promise[PROMISE_ID]) {
	    makePromise(this.promise);
	  }

	  if (isArray(input)) {
	    this._input = input;
	    this.length = input.length;
	    this._remaining = input.length;

	    this._result = new Array(this.length);

	    if (this.length === 0) {
	      fulfill(this.promise, this._result);
	    } else {
	      this.length = this.length || 0;
	      this._enumerate();
	      if (this._remaining === 0) {
	        fulfill(this.promise, this._result);
	      }
	    }
	  } else {
	    _reject(this.promise, validationError());
	  }
	}

	function validationError() {
	  return new Error('Array Methods must be provided an Array');
	};

	Enumerator.prototype._enumerate = function () {
	  var length = this.length;
	  var _input = this._input;

	  for (var i = 0; this._state === PENDING && i < length; i++) {
	    this._eachEntry(_input[i], i);
	  }
	};

	Enumerator.prototype._eachEntry = function (entry, i) {
	  var c = this._instanceConstructor;
	  var resolve$$ = c.resolve;

	  if (resolve$$ === resolve) {
	    var _then = getThen(entry);

	    if (_then === then && entry._state !== PENDING) {
	      this._settledAt(entry._state, i, entry._result);
	    } else if (typeof _then !== 'function') {
	      this._remaining--;
	      this._result[i] = entry;
	    } else if (c === Promise) {
	      var promise = new c(noop);
	      handleMaybeThenable(promise, entry, _then);
	      this._willSettleAt(promise, i);
	    } else {
	      this._willSettleAt(new c(function (resolve$$) {
	        return resolve$$(entry);
	      }), i);
	    }
	  } else {
	    this._willSettleAt(resolve$$(entry), i);
	  }
	};

	Enumerator.prototype._settledAt = function (state, i, value) {
	  var promise = this.promise;

	  if (promise._state === PENDING) {
	    this._remaining--;

	    if (state === REJECTED) {
	      _reject(promise, value);
	    } else {
	      this._result[i] = value;
	    }
	  }

	  if (this._remaining === 0) {
	    fulfill(promise, this._result);
	  }
	};

	Enumerator.prototype._willSettleAt = function (promise, i) {
	  var enumerator = this;

	  subscribe(promise, undefined, function (value) {
	    return enumerator._settledAt(FULFILLED, i, value);
	  }, function (reason) {
	    return enumerator._settledAt(REJECTED, i, reason);
	  });
	};

	/**
	  `Promise.all` accepts an array of promises, and returns a new promise which
	  is fulfilled with an array of fulfillment values for the passed promises, or
	  rejected with the reason of the first passed promise to be rejected. It casts all
	  elements of the passed iterable to promises as it runs this algorithm.

	  Example:

	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = resolve(2);
	  let promise3 = resolve(3);
	  let promises = [ promise1, promise2, promise3 ];

	  Promise.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```

	  If any of the `promises` given to `all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:

	  Example:

	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = reject(new Error("2"));
	  let promise3 = reject(new Error("3"));
	  let promises = [ promise1, promise2, promise3 ];

	  Promise.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```

	  @method all
	  @static
	  @param {Array} entries array of promises
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	  @static
	*/
	function all(entries) {
	  return new Enumerator(this, entries).promise;
	}

	/**
	  `Promise.race` returns a new promise which is settled in the same way as the
	  first passed promise to settle.

	  Example:

	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });

	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 2');
	    }, 100);
	  });

	  Promise.race([promise1, promise2]).then(function(result){
	    // result === 'promise 2' because it was resolved before promise1
	    // was resolved.
	  });
	  ```

	  `Promise.race` is deterministic in that only the state of the first
	  settled promise matters. For example, even if other promises given to the
	  `promises` array argument are resolved, but the first settled promise has
	  become rejected before the other promises became fulfilled, the returned
	  promise will become rejected:

	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });

	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error('promise 2'));
	    }, 100);
	  });

	  Promise.race([promise1, promise2]).then(function(result){
	    // Code here never runs
	  }, function(reason){
	    // reason.message === 'promise 2' because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```

	  An example real-world use case is implementing timeouts:

	  ```javascript
	  Promise.race([ajax('foo.json'), timeout(5000)])
	  ```

	  @method race
	  @static
	  @param {Array} promises array of promises to observe
	  Useful for tooling.
	  @return {Promise} a promise which settles in the same way as the first passed
	  promise to settle.
	*/
	function race(entries) {
	  /*jshint validthis:true */
	  var Constructor = this;

	  if (!isArray(entries)) {
	    return new Constructor(function (_, reject) {
	      return reject(new TypeError('You must pass an array to race.'));
	    });
	  } else {
	    return new Constructor(function (resolve, reject) {
	      var length = entries.length;
	      for (var i = 0; i < length; i++) {
	        Constructor.resolve(entries[i]).then(resolve, reject);
	      }
	    });
	  }
	}

	/**
	  `Promise.reject` returns a promise rejected with the passed `reason`.
	  It is shorthand for the following:

	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  Instead of writing the above, your code now simply becomes the following:

	  ```javascript
	  let promise = Promise.reject(new Error('WHOOPS'));

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  @method reject
	  @static
	  @param {Any} reason value that the returned promise will be rejected with.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject(reason) {
	  /*jshint validthis:true */
	  var Constructor = this;
	  var promise = new Constructor(noop);
	  _reject(promise, reason);
	  return promise;
	}

	function needsResolver() {
	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	}

	function needsNew() {
	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}

	/**
	  Promise objects represent the eventual result of an asynchronous operation. The
	  primary way of interacting with a promise is through its `then` method, which
	  registers callbacks to receive either a promise's eventual value or the reason
	  why the promise cannot be fulfilled.

	  Terminology
	  -----------

	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	  - `thenable` is an object or function that defines a `then` method.
	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	  - `exception` is a value that is thrown using the throw statement.
	  - `reason` is a value that indicates why a promise was rejected.
	  - `settled` the final resting state of a promise, fulfilled or rejected.

	  A promise can be in one of three states: pending, fulfilled, or rejected.

	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
	  state.  Promises that are rejected have a rejection reason and are in the
	  rejected state.  A fulfillment value is never a thenable.

	  Promises can also be said to *resolve* a value.  If this value is also a
	  promise, then the original promise's settled state will match the value's
	  settled state.  So a promise that *resolves* a promise that rejects will
	  itself reject, and a promise that *resolves* a promise that fulfills will
	  itself fulfill.


	  Basic Usage:
	  ------------

	  ```js
	  let promise = new Promise(function(resolve, reject) {
	    // on success
	    resolve(value);

	    // on failure
	    reject(reason);
	  });

	  promise.then(function(value) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```

	  Advanced Usage:
	  ---------------

	  Promises shine when abstracting away asynchronous interactions such as
	  `XMLHttpRequest`s.

	  ```js
	  function getJSON(url) {
	    return new Promise(function(resolve, reject){
	      let xhr = new XMLHttpRequest();

	      xhr.open('GET', url);
	      xhr.onreadystatechange = handler;
	      xhr.responseType = 'json';
	      xhr.setRequestHeader('Accept', 'application/json');
	      xhr.send();

	      function handler() {
	        if (this.readyState === this.DONE) {
	          if (this.status === 200) {
	            resolve(this.response);
	          } else {
	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	          }
	        }
	      };
	    });
	  }

	  getJSON('/posts.json').then(function(json) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```

	  Unlike callbacks, promises are great composable primitives.

	  ```js
	  Promise.all([
	    getJSON('/posts'),
	    getJSON('/comments')
	  ]).then(function(values){
	    values[0] // => postsJSON
	    values[1] // => commentsJSON

	    return values;
	  });
	  ```

	  @class Promise
	  @param {function} resolver
	  Useful for tooling.
	  @constructor
	*/
	function Promise(resolver) {
	  this[PROMISE_ID] = nextId();
	  this._result = this._state = undefined;
	  this._subscribers = [];

	  if (noop !== resolver) {
	    typeof resolver !== 'function' && needsResolver();
	    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
	  }
	}

	Promise.all = all;
	Promise.race = race;
	Promise.resolve = resolve;
	Promise.reject = reject;
	Promise._setScheduler = setScheduler;
	Promise._setAsap = setAsap;
	Promise._asap = asap;

	Promise.prototype = {
	  constructor: Promise,

	  /**
	    The primary way of interacting with a promise is through its `then` method,
	    which registers callbacks to receive either a promise's eventual value or the
	    reason why the promise cannot be fulfilled.
	  
	    ```js
	    findUser().then(function(user){
	      // user is available
	    }, function(reason){
	      // user is unavailable, and you are given the reason why
	    });
	    ```
	  
	    Chaining
	    --------
	  
	    The return value of `then` is itself a promise.  This second, 'downstream'
	    promise is resolved with the return value of the first promise's fulfillment
	    or rejection handler, or rejected if the handler throws an exception.
	  
	    ```js
	    findUser().then(function (user) {
	      return user.name;
	    }, function (reason) {
	      return 'default name';
	    }).then(function (userName) {
	      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	      // will be `'default name'`
	    });
	  
	    findUser().then(function (user) {
	      throw new Error('Found user, but still unhappy');
	    }, function (reason) {
	      throw new Error('`findUser` rejected and we're unhappy');
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	    });
	    ```
	    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	  
	    ```js
	    findUser().then(function (user) {
	      throw new PedagogicalException('Upstream error');
	    }).then(function (value) {
	      // never reached
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // The `PedgagocialException` is propagated all the way down to here
	    });
	    ```
	  
	    Assimilation
	    ------------
	  
	    Sometimes the value you want to propagate to a downstream promise can only be
	    retrieved asynchronously. This can be achieved by returning a promise in the
	    fulfillment or rejection handler. The downstream promise will then be pending
	    until the returned promise is settled. This is called *assimilation*.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // The user's comments are now available
	    });
	    ```
	  
	    If the assimliated promise rejects, then the downstream promise will also reject.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // If `findCommentsByAuthor` fulfills, we'll have the value here
	    }, function (reason) {
	      // If `findCommentsByAuthor` rejects, we'll have the reason here
	    });
	    ```
	  
	    Simple Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let result;
	  
	    try {
	      result = findResult();
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	    findResult(function(result, err){
	      if (err) {
	        // failure
	      } else {
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findResult().then(function(result){
	      // success
	    }, function(reason){
	      // failure
	    });
	    ```
	  
	    Advanced Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let author, books;
	  
	    try {
	      author = findAuthor();
	      books  = findBooksByAuthor(author);
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	  
	    function foundBooks(books) {
	  
	    }
	  
	    function failure(reason) {
	  
	    }
	  
	    findAuthor(function(author, err){
	      if (err) {
	        failure(err);
	        // failure
	      } else {
	        try {
	          findBoooksByAuthor(author, function(books, err) {
	            if (err) {
	              failure(err);
	            } else {
	              try {
	                foundBooks(books);
	              } catch(reason) {
	                failure(reason);
	              }
	            }
	          });
	        } catch(error) {
	          failure(err);
	        }
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findAuthor().
	      then(findBooksByAuthor).
	      then(function(books){
	        // found books
	    }).catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method then
	    @param {Function} onFulfilled
	    @param {Function} onRejected
	    Useful for tooling.
	    @return {Promise}
	  */
	  then: then,

	  /**
	    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	    as the catch block of a try/catch statement.
	  
	    ```js
	    function findAuthor(){
	      throw new Error('couldn't find that author');
	    }
	  
	    // synchronous
	    try {
	      findAuthor();
	    } catch(reason) {
	      // something went wrong
	    }
	  
	    // async with promises
	    findAuthor().catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method catch
	    @param {Function} onRejection
	    Useful for tooling.
	    @return {Promise}
	  */
	  'catch': function _catch(onRejection) {
	    return this.then(null, onRejection);
	  }
	};

	function polyfill() {
	    var local = undefined;

	    if (typeof global !== 'undefined') {
	        local = global;
	    } else if (typeof self !== 'undefined') {
	        local = self;
	    } else {
	        try {
	            local = Function('return this')();
	        } catch (e) {
	            throw new Error('polyfill failed because global object is unavailable in this environment');
	        }
	    }

	    var P = local.Promise;

	    if (P) {
	        var promiseToString = null;
	        try {
	            promiseToString = Object.prototype.toString.call(P.resolve());
	        } catch (e) {
	            // silently ignored
	        }

	        if (promiseToString === '[object Promise]' && !P.cast) {
	            return;
	        }
	    }

	    local.Promise = Promise;
	}

	// Strange compat..
	Promise.polyfill = polyfill;
	Promise.Promise = Promise;

	return Promise;

	})));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";

	/*** IMPORTS FROM imports-loader ***/
	var hash = "'213270133cd38b48a3c0fcc5a55805a529e969eb";
	var shortHash = "2132701'";
	var version = "4.5.7";
	var agentVersion = "2.2.0.1013";
	var nrtcVersion = "3.5.0";
	var sdkVersion = "40";
	var protocolVersion = 1;
	var lbsUrl = "https://lbs.netease.im/lbs/webconf.jsp";

	/* globals hash:false, shortHash:false, version:false, agentVersion:false, nrtcVersion:fale, sdkVersion:false, protocolVersion:false, lbsUrl:true */
	// those globals will be injected via webpack, @see ./build/webpack.config.js

	var theAnswerToEverything = process.env.NODE_ENV === 'development' ? 6 * 1000 : 42 * 1000;

	// console.log('nrtcVersion', nrtcVersion)
	var config = {
	  info: {
	    hash: hash,
	    shortHash: shortHash,
	    version: version,
	    sdkVersion: sdkVersion,
	    nrtcVersion: nrtcVersion,
	    protocolVersion: protocolVersion
	  },
	  agentVersion: agentVersion,
	  lbsUrl: lbsUrl,
	  // lbs 最大重试次数, 当所有 lbs 地址都不可用的时候, 会尝试重新获取 lbs 地址, 目前只重试一次
	  // lbsMaxRetryCount: 1,
	  // 连接超时时间
	  connectTimeout: theAnswerToEverything,
	  // xhr 超时时间
	  xhrTimeout: theAnswerToEverything,
	  // socket 超时时间
	  socketTimeout: theAnswerToEverything,
	  // 重连间隔和最大间隔
	  reconnectionDelay: 656.25,
	  reconnectionDelayMax: theAnswerToEverything,
	  reconnectionJitter: 0.1,

	  // 心跳间隔
	  heartbeatInterval: 3 * 60 * 1000,

	  // 协议超时时间
	  cmdTimeout: theAnswerToEverything
	};

	// =============================
	// socket 服务器地址相关
	// =============================
	// 格式化
	config.formatSocketUrl = function (_ref) {
	  var url = _ref.url,
	      secure = _ref.secure;

	  var prefix = secure ? 'https' : 'http';
	  if (url.indexOf('http') === -1) {
	    return prefix + '://' + url;
	  }
	  return url;
	};

	// =====================================
	// nos 相关
	// =====================================
	config.fileServerUrl = 'https://nos.netease.com';
	config.replaceUrl = 'http://nos.netease.im';
	// 上传地址本来应该是 http://bucket.nos.netease.com, 但是 nos nginx 处理有点问题, 所以放在后面
	config.genUploadUrl = function (bucket) {
	  if (config.uploadUrl) {
	    return config.uploadUrl + '/' + bucket;
	  }
	  return config.fileServerUrl + '/' + bucket;
	};

	// 下载地址把 bucket 提到前面, 可以 CDN 加速（wj：老大说没有申请cdn 不知道这注释怎么来的）
	config.genDownloadUrl = function (bucket, object) {
	  if (config.downloadUrl) {
	    return config.replaceUrl + '/' + bucket + '/' + object;
	  } else {
	    return config.fileServerUrl + '/' + bucket + '/' + object;
	  }
	};

	module.exports = config;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * 错误
	 *
	 * @constructor
	 * @param {String} message  错误消息
	 * @param {Number} code     错误码
	 */
	function NIMError(message, code) {
	  var self = this;
	  self.message = message;
	  self.code = code;
	  self.time = new Date();
	  self.timetag = +self.time;
	}
	NIMError.prototype = Object.create(Error.prototype);
	NIMError.prototype.name = 'NIMError';

	NIMError.prototype.appendMessage = function (message) {
	  var self = this;
	  if (!self.message) {
	    self.message = message;
	  } else if (message) {
	    self.message += '(' + message + ')';
	  }
	};

	/**
	 * 错误码错误信息表
	 *
	 * @memberOf NIMError
	 * @readOnly
	 * @enum {String}
	 */
	var codeMap = {
	  201: '客户端版本不对, 需升级sdk',
	  302: '用户名或密码错误, 请检查appKey和token是否有效, account和token是否匹配',
	  403: '非法操作或没有权限',
	  404: '对象(用户/群/聊天室)不存在',
	  405: '参数长度过长',
	  408: '客户端请求超时',
	  414: '参数错误',
	  415: '服务不可用/没有聊天室服务器可分配',
	  // http://doc.hz.netease.com/pages/viewpage.action?pageId=60393173
	  416: '频率控制',
	  417: '重复操作',
	  422: '帐号被禁用',
	  500: '服务器内部错误',
	  501: '数据库操作失败',
	  503: '服务器繁忙',
	  508: '删除有效期过了',
	  509: '已失效',
	  7101: '被拉黑',
	  801: '群人数达到上限',
	  802: '没有权限',
	  803: '群不存在或未发生变化',
	  804: '用户不在群里面',
	  805: '群类型不匹配',
	  806: '创建群数量达到限制',
	  807: '群成员状态不对',
	  809: '已经在群里',
	  813: '因群数量限制，部分拉人成功',
	  997: '协议已失效',
	  998: '解包错误',
	  999: '打包错误',
	  9102: '通道失效',
	  9103: '已经在其他端接听/拒绝过这通电话',
	  11001: '对方离线, 通话不可送达',
	  13002: '聊天室状态异常',
	  13003: '在黑名单中',
	  13004: '在禁言名单中',
	  13006: '聊天室处于整体禁言状态,只有管理员能发言',
	  // 请确保flash版本号大于10
	  'Connect_Failed': '无法建立连接, 请确保能 ping/telnet 到云信服务器; 如果是IE8/9, 请确保项目部署在 HTTPS 环境下',
	  'Error_Internet_Disconnected': '网断了',
	  'Error_Connection_is_not_Established': '连接未建立',
	  'Error_Connection_Socket_State_not_Match': 'socket状态不对',
	  'Error_Timeout': '超时',
	  'Param_Error': '参数错误',
	  'No_File_Selected': '请选择文件',
	  'Wrong_File_Type': '文件类型错误',
	  'File_Too_Large': '文件过大',
	  'Cross_Origin_Iframe': '不能获取跨域Iframe的内容',
	  'Not_Support': '不支持',
	  'NO_DB': '无数据库',
	  'DB': '数据库错误',
	  'Still_In_Team': '还在群里',
	  'Session_Exist': '会话已存在',
	  'Session_Not_Exist': '会话不存在',
	  'Error_Unknown': '未知错误',
	  'Operation_Canceled': '操作取消'
	};

	// 200 成功
	// 406 未发生变化
	// 808 申请成功
	// 810 邀请成功
	[200, 406, 808, 810].forEach(function (code) {
	  codeMap[code] = null;
	});

	NIMError.genError = function (code) {
	  var msg = codeMap[code];
	  if (msg === undefined) {
	    msg = '操作失败';
	  }
	  if (msg === null) {
	    return null;
	  } else {
	    return new NIMError(msg, code);
	  }
	};

	NIMError.multiInstance = function () {
	  return new NIMError('不允许初始化多个实例', 'Not_Allow_Multi_Instance');
	};

	NIMError.newNetworkError = function () {
	  var code = 'Error_Internet_Disconnected';
	  return new NIMError(codeMap[code], code);
	};

	NIMError.newConnectError = function (message) {
	  var code = 'Connect_Failed';
	  return new NIMError(codeMap[code] || message, code);
	};

	NIMError.newConnectionError = function () {
	  var code = 'Error_Connection_is_not_Established';
	  return new NIMError(codeMap[code], code);
	};

	NIMError.newSocketStateError = function () {
	  var code = 'Error_Connection_Socket_State_not_Match';
	  return new NIMError(codeMap[code], code);
	};
	NIMError.newTimeoutError = function () {
	  var code = 'Error_Timeout';
	  return new NIMError(codeMap[code], code);
	};

	NIMError.newFrequencyControlError = function () {
	  var code = 416;
	  var error = new NIMError(codeMap[code], code);
	  // 表明此错误是由客户端生成的，此字段只是用于自动化测试
	  error.from = 'local';
	  return error;
	};

	NIMError.newParamError = function (message) {
	  var code = 'Param_Error';
	  return new NIMError(message || codeMap[code], code);
	};

	NIMError.newNoFileError = function (message) {
	  var code = 'No_File_Selected';
	  return new NIMError(message || codeMap[code], code);
	};

	NIMError.newWrongFileTypeError = function (message) {
	  var code = 'Wrong_File_Type';
	  return new NIMError(message || codeMap[code], code);
	};

	NIMError.newFileTooLargeError = function (message) {
	  var code = 'File_Too_Large';
	  return new NIMError(message || codeMap[code], code);
	};

	NIMError.newCORSIframeError = function () {
	  var code = 'Cross_Origin_Iframe';
	  return new NIMError(codeMap[code], code);
	};

	NIMError.newSupportError = function (msg, code) {
	  return new NIMError('不支持' + msg, 'Not_Support_' + code);
	};

	NIMError.newSupportDBError = function () {
	  return NIMError.newSupportError('数据库', 'DB');
	};

	NIMError.noDBError = function () {
	  var code = 'NO_DB';
	  return new NIMError(codeMap[code], code);
	};

	NIMError.newDBError = function () {
	  var code = 'DB';
	  return new NIMError(codeMap[code], code);
	};

	NIMError.newUnknownError = function () {
	  var code = 'Error_Unknown';
	  return new NIMError(codeMap[code], code);
	};

	NIMError.stillInTeamError = function () {
	  var code = 'Still_In_Team';
	  return new NIMError(codeMap[code], code);
	};

	NIMError.sessionExist = function () {
	  var code = 'Session_Exist';
	  return new NIMError(codeMap[code], code);
	};

	NIMError.sessionNotExist = function () {
	  var code = 'Session_Not_Exist';
	  return new NIMError(codeMap[code], code);
	};

	NIMError.cancel = function () {
	  var code = 'Operation_Canceled';
	  return new NIMError(codeMap[code], code);
	};

	// 自定义错误类型
	NIMError.customError = function (message, code) {
	  code = code || 'Other_Error';
	  return new NIMError(message, code);
	};

	module.exports = NIMError;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var DB = __webpack_require__(10);
	var Protocol = __webpack_require__(13);
	var NIMError = __webpack_require__(4);
	var config = __webpack_require__(3);
	var util = __webpack_require__(1);
	var undef = util.undef;
	var PushNotificationMultiportConfig = __webpack_require__(42);
	var parser = __webpack_require__(18).getInstance('IM');
	var SystemMessage = __webpack_require__(25);

	function IMProtocol(options) {
	  var self = this;
	  util.verifyOptions(options, 'appKey account token');
	  // 所有通知回调在用 Promise 的地方使用 setTimeout 来模拟异步线程, 否则, 如果抛出错误会被 Promise catch 到, 控制台就不会报错
	  util.verifyCallback(options, ['onconnect', 'onerror', 'onwillreconnect', 'ondisconnect', 'onloginportschange', 'onmyinfo', 'onblacklist', 'onmutelist', 'onfriends', 'onusers', 'onrobots', 'onteams', 'onsessions', 'onroamingmsgs', 'onofflinemsgs', 'onofflinefiltermsgs', 'onroamingsysmsgs', 'onofflinesysmsgs', 'onofflinefiltersysmsgs', 'onofflinecustomsysmsgs', 'onofflinefiltercustomsysmsgs', 'onbroadcastmsg', 'onbroadcastmsgs', 'onsysmsgunread', 'onsyncdone', 'onteammembers', 'onsyncteammembersdone', 'onmsg', 'onsysmsg', 'oncustomsysmsg', 'onupdatemyinfo', 'onupdateuser', 'onupdateteammember', 'onCreateTeam', 'onUpdateTeam', 'onAddTeamMembers', 'onRemoveTeamMembers', 'onUpdateTeamManagers', 'onDismissTeam', 'onTransferTeam', 'onUpdateTeamMembersMute', 'onupdatesession', 'onupdatesysmsgunread', 'onupdatesysmsg', 'onsynccreateteam', 'onsyncmarkinblacklist', 'onsyncmarkinmutelist', 'onsyncfriendaction',
	  // 只想过滤部分通知，所以是函数
	  'shouldIgnoreNotification', 'shouldCountNotifyUnread', 'onPushNotificationMultiportConfig', 'onPushNotificationMultiportConfigUpdate', 'onpushevents']);
	  // 初始化数据库
	  self.db = options.api.db = new DB({
	    logger: options.logger
	  });
	  // 调用父类初始化
	  Protocol.call(self, options);
	}

	var ProtocolFn = Protocol.fn;
	var IMProtocolFn = IMProtocol.fn = IMProtocol.prototype = Object.create(ProtocolFn);

	IMProtocolFn.init = function () {
	  var self = this;
	  ProtocolFn.init.call(self);

	  // socket 地址
	  self.socketUrls = [];

	  // 协议解释器
	  self.parser = parser;

	  // 是否正在同步中, 初始化时为 true 表示正在同步中
	  // syncData 时会置为 true 表示正在同步中
	  // onSyncDone 时会置为 false 表示同步完成
	  self.syncing = true;
	  // 是否已经进行过同步, 如果已经进行过, 那么后续的同步均为增量同步
	  self.hasSynced = false;
	  // 是否已经进行过同步群成员, 如果已经进行过, 那么后续的同步均为增量同步
	  self.hasSyncedTeamMembers = false;
	  // 存储同步 Promise 数组, 监视什么时候完成同步
	  self.syncPromiseArray = [];
	  // 在同步过程中, 会存入同步到的数据
	  self.syncResult = {};
	  // 存储同步群成员 Promise 数组, 监视什么时候完成同步群成员
	  self.syncTeamMembersPromiseArray = [];
	  // 在同步群成员过程中, 会存入同步到的数据
	  self.syncTeamMembersResult = {};
	  // 同步时间戳, 当没有数据库时从此对象读取同步时间戳, 从而进行增量同步
	  self.timetags = {};

	  // 系统通知未读数
	  self.sysMsgUnread = SystemMessage.completeUnread({});

	  self.resetUnsettledMsgs();
	  self.resetUnsettledSysMsgs();

	  // 使收消息和发消息按照顺序来处理
	  self.msgPromise = Promise.resolve();

	  // 收到系统通知的时候按顺序来存储
	  self.sysMsgPromise = Promise.resolve();

	  /*
	   * 会话集合
	   * - key 为 sessionId, value 为 session
	   * 数据来源为
	   * - 同步后得到的会话 (onSyncDone)
	   * - 更新会话 (onUpdateSession)
	   * - 从本地获取会话 (getLocalSessions)
	   * - 同步后得到的消息回执 (onOfflineMsgReceipts onSyncDone)
	   * - 发送消息回执 (onSendMsgReceipt)
	   * - 收到消息回执 (onMsgReceipt)
	   * 用法
	   * - 如果设置一个不存在的会话为当前会话或者重置一个不存在的会话的未读数, 会直接返回
	   */
	  self.sessionSet = {};

	  self.msgReceiptTasks = {};

	  // 用户集合
	  // key 为 account, value 为 user
	  // 数据来源为同步后得到的用户 (onSyncDone) 以及主动拉到的用户 (getUsers)
	  // 如果收到消息之后发现用户名片被更新了, 那么需要从服务器拉取新的用户名片
	  self.userSet = {};

	  // 多端推送配置项
	  self.pushNotificationMultiportConfig = PushNotificationMultiportConfig.getDefaultConfig();
	};

	IMProtocolFn.reset = function () {
	  var self = this;
	  ProtocolFn.reset.call(self);

	  var options = self.options;

	  // 重置数据库
	  self.db.reset(options.db);

	  // lbsUrl
	  if (undef(options.lbsUrl)) {
	    options.lbsUrl = config.lbsUrl;
	  }
	  self.resetAutoMarkRead();
	};

	IMProtocolFn.resetAutoMarkRead = function () {
	  var options = this.options;
	  util.verifyBooleanWithDefault(options, 'autoMarkRead', true);
	  // 目前使用一个通用的开关, 下面的代码是各个子开关, 先注释掉
	  // 将options.autoMarkRead处理成false或者{}
	  // if (util.notundef(options.autoMarkRead)) {
	  //     if (!util.isObject(options.autoMarkRead)) {
	  //         // 如果该不是一个对象, 那么它必须是Boolean
	  //         util.verifyParamType('autoMarkRead', options.autoMarkRead, 'boolean');
	  //         // 如果是true, 那么变为{}
	  //         if (options.autoMarkRead === true) {
	  //             options.autoMarkRead = {};
	  //         }
	  //     }
	  // } else {
	  //     options.autoMarkRead = {};
	  // }
	  // var auto = true;
	  // if (options.autoMarkRead === false) {
	  //     options.autoMarkRead = {};
	  //     auto = false;
	  // }
	  // // filter开头的开关用于控制云商服专用消息的标记已读
	  // util.verifyBooleanWithDefault(options.autoMarkRead, 'p2p team sys customSys filterP2p filterTeam filterSys filterCustomSys', auto, 'autoMarkRead.');
	};

	/*
	 * 如果同步过程中发生以下情况
	 * - 收到消息 (需要调用 handleMsg)
	 * - 发消息之前 (需要调用 putMsg)
	 * - 发消息失败 (需要调用 updateMsg)
	 * - 发消息成功 (需要调用 updateMsg)
	 * 需要将消息缓存起来, 在同步完成之后再更新数据库, 这样才能保证消息在数据库中的顺序
	 * - processUnsettledMsgs
	 */
	IMProtocolFn.resetUnsettledMsgs = function () {
	  var self = this;
	  /*
	   * 未处理的消息, 包括
	   * - 收到消息
	   * - 发消息之前
	   */
	  self.unhandledMsgs = [];
	  /*
	   * 未更新的消息, 包括
	   * - 发消息失败
	   * - 发消息成功
	   */
	  self.unupdatedMsgs = [];
	};

	/*
	 * 如果同步过程中发生以下情况
	 * - 收到离线消息 (需要调用 handleSysMsg)
	 * 需要将系统通知缓存起来, 在同步完成之后再更新数据库, 这样才能保证系统通知在数据库中的顺序
	 * - processUnsettledSysMsgs
	 */
	IMProtocolFn.resetUnsettledSysMsgs = function () {
	  var self = this;
	  self.unhandledSysMsgs = [];
	  self.unupdatedSysMsgs = [];
	};

	/**
	 * 判断packet是否是同步的回包
	 * 因为同步可能有多个回包, 所以第一个回包会获取到 packet.obj.sync, 后面的回包都获取不到 packet.obj
	 * @private
	 */
	IMProtocolFn.packetFromSync = function (packet) {
	  return !packet.obj || !!packet.obj.sync;
	};

	// 数据库错误
	IMProtocolFn.onDBError = function (event) {
	  var error = NIMError.newDBError();
	  error.event = event;
	  this.notifyError(error);
	};

	// 自定义错误通知
	IMProtocolFn.onCustomError = function (message, code) {
	  var error = NIMError.customError(message, code);
	  error.event = message;
	  this.notifyError(error);
	};

	module.exports = IMProtocol;

	__webpack_require__(154);
	__webpack_require__(152);
	__webpack_require__(166);
	__webpack_require__(169);
	__webpack_require__(157);
	__webpack_require__(163);
	__webpack_require__(168);
	__webpack_require__(162);
	__webpack_require__(158);
	__webpack_require__(160);
	__webpack_require__(159);
	__webpack_require__(167);
	__webpack_require__(164);
	__webpack_require__(165);
	__webpack_require__(153);
	__webpack_require__(156);
	__webpack_require__(155);

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ApiBase = __webpack_require__(11);
	var Protocol = __webpack_require__(5);
	var config = __webpack_require__(3);
	var IMMessage = __webpack_require__(136);
	var parser = __webpack_require__(18).getInstance('IM');

	/**
	 * 请使用 {@link NIM.getInstance} 来初始化 SDK.
	 * 此接口为单例模式, 对于同一个账号, 永远返回同一份实例, 即只有第一次调用会初始化一个实例, 后续调用此接口会直接返回初始化过的实例.
	 * @class
	 */
	function NIM(options) {
	  var self = this;
	  self.subType = 'im';
	  // init
	  options.Protocol = Protocol;
	  options.Message = IMMessage;
	  options.constructor = NIM;
	  return self.init(options);
	}

	NIM.Protocol = Protocol;
	NIM.parser = parser;
	NIM.use = ApiBase.use;

	/**
	 * - 此接口为单例模式, 对于同一个账号, 永远返回同一份实例, 即只有第一次调用会初始化一个实例
	 * - 后续调用此接口会直接返回初始化过的实例, 同时也会调用接口{@link NIM#setOptions|setOptions}更新传入的配置
	 * - 后续调用此接口时, 如果连接已断开, 会自动建立连接
	 * - 当发生掉线时，SDK会自动进行重连
	 *
	 * @method getInstance
	 * @memberOf NIM
	 *
	 * @param {Object}              options                                 配置参数
	 * @param {Boolean|Object}      [options.debug=false]                   是否开启调试, 如果开启调试, 将会在控制台输出一些log。默认`false`不输出日志, 可以传`true`来开启日志。
	 * @param {Boolean|Object}      [options.secure=true]                   secure 模式下会通过 https 协议跟服务器建立连接, 非 secure 模式下会通过 http 协议跟服务器建立连接, 默认 true

	 * @param {String}              options.appKey                          在云信管理后台查看应用的 appKey
	 * @param {String}              options.account                         帐号, 应用内唯一
	 * @param {String}              options.token                           帐号的 token, 用于建立连接
	 * @param {Function}            [options.onconnect]                     连接建立后的回调, 会传入一个对象, 包含登录的信息, 有以下字段
	 * - `lastLoginDeviceId`: 上次登录的设备的设备号
	 * - `connectionId`: 本次登录的连接号
	 * - `ip`: 客户端IP
	 * - `port`: 客户端端口
	 * - `country`: 本次登录的国家
	 * @param {Function}            [options.onwillreconnect]                 即将重连的回调
	 * - 此时说明 SDK 已经断开连接, 请开发者在界面上提示用户连接已断开, 而且正在重新建立连接
	 * - 此回调会收到一个对象, 包含额外的信息, 有以下字段
	 *     - `duration`: 距离下次重连的时间
	 *     - `retryCount`: 重连尝试的次数
	 * @param {Function}            [options.ondisconnect]                  断开连接后的回调
	 * - 此时说明 SDK 处于断开状态, 开发者此时应该根据错误码提示相应的错误信息, 并且跳转到登录页面
	 * - 此回调会收到一个对象, 包含错误的信息, 有以下字段
	 *     - `code`: 出错时的错误码, 可能为空
	 *         - `302`: 账号或者密码错误, 请跳转到登录页面并提示错误
	 *         - `417`: 重复登录, 已经在其它端登录了, 请跳转到登录页面并提示错误
	 *         - `'kicked'`: 被踢
	 * - 当`code`为`'kicked'`的时候, 此对象会有以下字段
	 *     - `reason`: 被踢的原因
	 *         - `samePlatformKick`: 不允许同一个帐号在多个地方同时登录
	 *         - `serverKick`: 被服务器踢了
	 *         - `otherPlatformKick`: 被其它端踢了
	 *     - `message`: 文字描述的被踢的原因
	 * @param {Function}            [options.onerror]                       发生错误的回调, 会传入{@link NIMError|错误}对象

	 * @param {Function}            [options.onloginportschange]            多端登录状态变化的回调, 会收到{@link LoginPort|登录端}列表, 以下情况会收到此回调
	 * - 登录时其它端在线
	 * - 登录后其它端上线或者下线
	 *
	 * @param {Boolean}             [options.syncRelations=true]            是否同步黑名单和静音列表, 默认`true`. 如果传`false`就收不到黑名单和静音列表, 即不会收到`onblacklist`回调和`onmutelist`回调, 开发者后续可以调用{@link NIM#getRelations|获取黑名单和静音列表}来获取黑名单和静音列表。
	 * @param {Function}            [options.onblacklist]                   同步黑名单的回调, 会传入黑名单列表`blacklist`
	 * - `blacklist`的属性`invalid`包含被删除的黑名单列表
	 * - 此回调是增量回调, 可以调用{@link NIM#mergeRelations|nim.mergeRelations}和{@link NIM#cutRelations|nim.cutRelations}来合并数据
	 * @param {Function}            [options.onsyncmarkinblacklist]         当前登录用户在其它端{@link NIM#markInBlacklist|加入黑名单/从黑名单移除}后的回调, 会传入一个参数, 包含两个字段
	 * - `account`: 要加入黑名单/从黑名单移除的账号
	 * - `isAdd`: `true`表示加入黑名单, `false`表示从黑名单移除
	 * @param {Function}            [options.onmutelist]                    同步静音列表的回调, 会传入静音列表`mutelist`
	 * - `mutelist`的属性`invalid`包含被删除的静音列表
	 * - 此回调是增量回调, 可以调用{@link NIM#mergeRelations|nim.mergeRelations}和{@link NIM#cutRelations|nim.cutRelations}来合并数据
	 * @param {Function}            [options.onsyncmarkinmutelist]          当前登录用户在其它端{@link NIM#markInMutelist|加入静音列表/从静音列表移除}后的回调, 会传入一个参数, 包含两个字段
	 * - `account`: 要加入黑名单/从黑名单移除的账号
	 * - `isAdd`: `true`表示加入静音列表, `false`表示从静音列表移除
	 *
	 * @param {Boolean}             [options.syncFriends]                   是否同步好友列表, 默认`true`. 如果传`false`就收不到`onfriends`回调, 开发者后续可以调用{@link NIM#getFriends|获取好友列表}来获取好友列表。
	 * @param {Function}            [options.onfriends]                     同步好友列表的回调, 会传入好友列表
	 * @param {Function}            [options.onsyncfriendaction]           当前登录用户在其它端进行好友相关的操作后的回调
	 * - 操作包括
	 *     - {@link NIM#addFriend|直接加为好友}
	 *     - {@link NIM#applyFriend|申请加为好友}
	 *     - {@link NIM#passFriendApply|通过好友申请}
	 *     - {@link NIM#rejectFriendApply|拒绝好友申请}
	 *     - {@link NIM#deleteFriend|删除好友}
	 *     - {@link NIM#updateFriend|更新好友}
	 * - 此回调会收到一个参数`obj`, 它有一个字段`type`的值为操作的类型, 具体类型如下：
	 *     - `'addFriend'` (直接加为好友), 此时`obj`的字段如下:
	 *         - `account`的值为被直接加为好友的账号
	 *         - `friend`为被直接加为好友的{@link Friend|好友对象}
	 *         - `ps`为附言
	 *     - `'applyFriend'` (申请加为好友), 此时`obj`的字段如下:
	 *         - `account`的值为被申请加为好友的账号
	 *         - `ps`为附言
	 *     - `'passFriendApply'` (通过好友申请), 此时`obj`的字段如下:
	 *         - `account`的值为被通过好友申请的账号
	 *         - `friend`为被通过好友申请的{@link Friend|好友对象}
	 *         - `ps`为附言
	 *     - `'rejectFriendApply'` (拒绝好友申请), 此时`obj`的字段如下:
	 *         - `account`的值为被拒绝好友申请的账号
	 *         - `ps`为附言
	 *     - `'deleteFriend'` (删除好友), 此时`obj`的字段如下:
	 *         - `account`的值为被删除好友的账号
	 *     - `'updateFriend'` (更新好友), 此时`obj`的字段如下:
	 *         - `friend`的值为被更新的{@link Friend|好友对象}
	 *
	 * @param {Function}            [options.onmyinfo]                      同步登录用户名片的回调, 会传入{@link User|用户名片}
	 * @param {Function}            [options.onupdatemyinfo]                当前登录用户在其它端修改自己的个人名片之后的回调, 会传入{@link User|用户名片}
	 * @param {Boolean} [options.syncFriendUsers] 是否同步好友对应的用户名片列表, 默认`true`, 如果传`false`就收不到`onusers`回调.
	 * @param {Function}            [options.onusers]                       同步好友用户名片的回调, 会传入{@link User|用户名片}数组
	 * @param {Function}            [options.onupdateuser]                  用户名片更新后的回调, 会传入{@link User|用户名片}
	 *
	 * @param {Boolean}             [options.syncTeams=true]                是否同步群列表, 默认`true`. 如果传`false`就收不到群列表, 即不会收到`onteams`回调, 开发者后续可以调用{@link NIM#getTeams|获取群列表}来获取群列表.
	 * @param {Boolean} [options.syncExtraTeamInfo] 是否同步额外的群信息, 默认`true`会同步额外的群信息, 目前包括
	 * - 当前登录用户是否开启某个群的消息提醒 (SDK 只是存储了此信息, 具体用此信息来做什么事情完全由开发者控制)
	 * - 调用接口{@link NIM#updateInfoInTeam}来关闭/开启某个群的消息提醒
	 * - 调用接口{@link NIM#notifyForNewTeamMsg}来查询是否需要群消息通知
	 * @param {Function}            [options.onteams]                       同步群列表的回调, 会传入{@link Team|群}数组`teams`
	 * - `teams`的属性`invalid`包含退出的群
	 * @param {Function}            [options.onsynccreateteam]              当前登录用户在其它端{@link NIM#createTeam|创建群}后的回调, 会传入{@link Team|群对象}
	 * @param {Boolean}             [options.syncTeamMembers=true]          是否同步群成员, 默认`true`. 只有在`syncTeams`=`true`的时候才起作用, 如果传`false`就不会同步群成员, 即不会收到`onteammembers`和`onsyncteammembersdone`回调, 开发者后续可以调用{@link NIM#getTeamMembers|获取群成员}来获取群成员.
	 * @param {Function}            [options.onteammembers]                 同步群成员的回调, 一个群对应一个回调, 会传入{@link TeamMember|群成员}数组
	 * @param {Function}            [options.onsyncteammembersdone]         当`syncTeams`和`syncTeamMembers`同时为true时, 会同步所有群的群成员, 当所有群的群成员同步结束时, 会调用此回调
	 * @param {Function}            [options.onupdateteammember]            群成员信息更新后的回调, 会传入{@link TeamMember|群成员}对象, 不过此时的信息是不完整的, 只会包括被更新的字段。当前登录帐号在其它端修改自己在群里面的昵称时也会收到此回调。
	 * @param {Function} [options.onCreateTeam] 创建群的回调, 此方法接收一个参数, 包含群信息和群主信息
	 * @param {Function} [options.onUpdateTeam] 更新群的回调, 此方法接收一个参数, 更新后的群信息
	 * @param {Function} [options.onAddTeamMembers] 新成员入群的回调, 此方法接收一个参数, 包含群信息和群成员信息
	 * @param {Function} [options.onRemoveTeamMembers] 有人出群的回调, 此方法接收一个参数, 包含群信息和群成员账号
	 * @param {Function} [options.onUpdateTeamManagers] 更新群管理员的回调, 此方法接收一个参数, 包含群信息和管理员信息
	 * @param {Function} [options.onDismissTeam] 解散群的回调, 此方法接收一个参数, 包含被解散的群id
	 * @param {Function} [options.onTransferTeam] 移交群的回调, 此方法接收一个参数, 包含群信息和新老群主信息
	 * @param {Function} [options.onUpdateTeamMembersMute] 更新群成员禁言状态的回调, 此方法接收一个参数, 包含群信息和禁言状态信息
	 *
	 * @param {Boolean}  [options.syncSessionUnread=false] 是否同步会话的未读数, 默认不同步
	 * - 如果选择同步
	 *   - 那么在一个端读过的会话在其它端也会被标记为已读
	 *   - 在调用{@link NIM#setCurrSession}的时候 SDK 会自动同步一次未读数, 此后如果收到当前会话的消息, 需要手动调用{@link NIM#resetSessionUnread}来同步未读数
	 * @param {Function}            [options.onsessions]                    同步最近会话列表回调, 会传入{@link Session|会话}列表, 按时间正序排列, 即最近聊过天的放在列表的最后面。
	 * @param {Function}            [options.onupdatesession]               更新会话的回调, 会传入{@link Session|会话}, 以下情况会收到此回调
	 * - 收到消息
	 * - 发送消息
	 * - 设置当前会话
	 * - 重置会话未读数
	 *
	 * @param {Function} [options.shouldIgnoreNotification] 是否要忽略某条通知类消息, 该方法会接收一个消息对象, 如果该方法返回 true, 那么 SDK 将忽略此条通知类消息
	 * @param {Boolean} [options.shouldCountTeamNotifyUnread] 是否群通知消息记未读
	 * @param {Boolean}             [options.syncRoamingMsgs=true]          是否同步漫游消息, 默认`true`. 如果传`false`就收不到漫游消息, 即不会收到`onroamingmsgs`回调.
	 * @param {Function}            [options.onroamingmsgs]                 同步漫游消息的回调, 每个会话对应一个回调, 会传入{@link IMMessage|消息}数组
	 * @param {Function}            [options.onofflinemsgs]                 同步离线消息的回调, 每个会话对应一个回调, 会传入{@link IMMessage|消息}数组
	 * @param {Function}            [options.onmsg]                         收到消息的回调, 会传入{@link IMMessage|消息}对象
	 * - 当前登录帐号在其它端发送消息之后也会收到此回调, 注意此时消息对象的`from`字段就是当前登录的帐号
	 * @param {Boolean} [options.syncMsgReceipts] 是否同步已读回执时间戳, 默认`true`. 如果传`false`就收不到已读回执时间戳.
	 *
	 * @param {Function}            [options.onofflinesysmsgs]              同步离线系统通知的回调, 会传入{@link SystemMessage|系统通知}数组
	 * @param {Function}            [options.onroamingsysmsgs]              同步漫游系统通知的回调, 会传入{@link SystemMessage|系统通知}数组
	 * @param {Function}            [options.onsysmsg]                      收到系统通知的回调, 会传入{@link SystemMessage|系统通知}
	 * @param {Function}            [options.onupdatesysmsg]                更新系统通知后的回调, 会传入{@link SystemMessage|系统通知}
	 * - 以下情况会收到此回调
	 *     - {@link NIM#passFriendApply|通过好友申请}
	 *     - {@link NIM#rejectFriendApply|拒绝好友申请}
	 *     - {@link NIM#acceptTeamInvite|接受入群邀请}
	 *     - {@link NIM#rejectTeamInvite|拒绝入群邀请}
	 *     - {@link NIM#passTeamApply|通过入群申请}
	 *     - {@link NIM#rejectTeamApply|拒绝入群申请}
	 * - 这些操作的发起方会收到此回调, 接收被更新的系统通知, 根据操作的类型系统通知会被更新为下面两种状态
	 *     - `'passed'`: 已通过
	 *     - `'rejected'`: 已拒绝
	 * @param {Function}            [options.onsysmsgunread]                收到系统通知未读数的回调
	 * - SDK 会管理内建系统通知的未读数, 此回调接收的对象包括以下字段
	 *     - `total`: 总共的未读数
	 *     - `friend`: 所有跟好友相关的系统通知的未读数
	 *     - `addFriend`: 直接加为好友的未读数
	 *     - `applyFriend`: 申请加为好友的未读数
	 *     - `passFriendApply`: 通过好友申请的未读数
	 *     - `rejectFriendApply`: 拒绝好友申请的未读数
	 *     - `deleteFriend`: 删除好友的未读数
	 *     - `team`: 所有跟群相关的系统通知的未读数
	 *     - `teamInvite`: 入群邀请的未读数
	 *     - `rejectTeamInvite`: 接受入群邀请的未读数
	 *     - `applyTeam`: 入群申请的未读数
	 *     - `rejectTeamApply`: 拒绝入群申请的未读数
	 * @param {Function}            [options.onupdatesysmsgunread]          更新系统通知未读数的回调
	 * @param {Function}            [options.onofflinecustomsysmsgs]        同步离线自定义系统通知的回调, 会传入{@link SystemMessage|系统通知}数组
	 * @param {Function}            [options.oncustomsysmsg]                收到自定义系统通知的回调, 会传入{@link SystemMessage|系统通知}
	 *
	 * @param {Function}            [options.onsyncdone]                    当上面各个同步（不包括下面的同步群成员）完成后, 会调用此回调；注意, SDK保证在`onsyncdone`调用的时候上面的同步肯定完成了, 但是不保证各个同步回调的顺序。
	 *
	 * @param {Boolean} [options.autoMarkRead=true] 是否自动标记消息为已收到
	 * - 默认情况下SDK在收到服务器推送过来的消息后, 会在将消息推给开发者时将消息标记为已读状态, 下次登录后就不会收到标记为已读的消息。
	 *     - SDK通过`onofflinemsgs`、`onofflinesysmsgs`、`onofflinecustomsysmsgs`等回调将离线消息推送给开发者
	 *     - SDK通过`onmsg`、`onsysmsg`、`oncustomsysmsg`等回调将在线消息推送给开发者
	 * - 如果开发者想控制标记消息为已收到的时机, 那么可以传`false`, 这样SDK就不会自动标记消息已读, 此时需要开发者在适当的时机调用相关的方法来标记消息为已读, 否则下次登录后还会收到未标记为已读的消息。
	 *     - 调用{@link NIM#markSysMsgRead|标记系统通知已读}来标记{@link SystemMessage|系统通知}和{@link SystemMessage.type|自定义系统通知}为已读状态
	 *
	 * @param {Boolean} [options.db=true] 是否使用数据库
	 * - 在支持数据库的浏览器上 SDK 会将数据缓存到数据库中, 后续同步都是增量更新, 加快初始化速度
	 * - 如果开发者不想使用数据库, 那么可以设置`db`为`false`来禁用数据库
	 *
	 * @example
	 * var data = {};
	 * var nim = new NIM({
	 *     // 初始化SDK
	 *     // debug: true
	 *     appKey: 'appKey',
	 *     account: 'account',
	 *     token: 'token',
	 *     onconnect: onConnect,
	 *     onerror: onError,
	 *     onwillreconnect: onWillReconnect,
	 *     ondisconnect: onDisconnect,
	 *     // 多端
	 *     onloginportschange: onLoginPortsChange,
	 *     // 用户关系
	 *     onblacklist: onBlacklist,
	 *     onsyncmarkinblacklist: onMarkInBlacklist,
	 *     onmutelist: onMutelist,
	 *     onsyncmarkinmutelist: onMarkInMutelist,
	 *     // 好友关系
	 *     onfriends: onFriends,
	 *     onsyncfriendaction: onSyncFriendAction,
	 *     // 用户名片
	 *     onmyinfo: onMyInfo,
	 *     onupdatemyinfo: onUpdateMyInfo,
	 *     onusers: onUsers,
	 *     onupdateuser: onUpdateUser,
	 *     // 群组
	 *     onteams: onTeams,
	 *     onsynccreateteam: onCreateTeam,
	 *     onteammembers: onTeamMembers,
	 *     onsyncteammembersdone: onSyncTeamMembersDone,
	 *     onupdateteammember: onUpdateTeamMember,
	 *     // 会话
	 *     onsessions: onSessions,
	 *     onupdatesession: onUpdateSession,
	 *     // 消息
	 *     onroamingmsgs: onRoamingMsgs,
	 *     onofflinemsgs: onOfflineMsgs,
	 *     onmsg: onMsg,
	 *     // 系统通知
	 *     onofflinesysmsgs: onOfflineSysMsgs,
	 *     onsysmsg: onSysMsg,
	 *     onupdatesysmsg: onUpdateSysMsg,
	 *     onsysmsgunread: onSysMsgUnread,
	 *     onupdatesysmsgunread: onUpdateSysMsgUnread,
	 *     onofflinecustomsysmsgs: onOfflineCustomSysMsgs,
	 *     oncustomsysmsg: onCustomSysMsg,
	 *     // 同步完成
	 *     onsyncdone: onSyncDone
	 * });
	 *
	 * function onConnect() {
	 *     console.log('连接成功');
	 * }
	 * function onWillReconnect(obj) {
	 *     // 此时说明 `SDK` 已经断开连接, 请开发者在界面上提示用户连接已断开, 而且正在重新建立连接
	 *     console.log('即将重连', obj);
	 * }
	 * function onDisconnect(error) {
	 *     // 此时说明 `SDK` 处于断开状态, 开发者此时应该根据错误码提示相应的错误信息, 并且跳转到登录页面
	 *     console.log('连接断开', error);
	 *     if (error) {
	 *         switch (error.code) {
	 *         // 账号或者密码错误, 请跳转到登录页面并提示错误
	 *         case 302:
	 *             break;
	 *         // 重复登录, 已经在其它端登录了, 请跳转到登录页面并提示错误
	 *         case 417:
	 *             break;
	 *         // 被踢, 请提示错误后跳转到登录页面
	 *         case 'kicked':
	 *             break;
	 *         default:
	 *             break;
	 *         }
	 *     }
	 * }
	 * function onError(error, obj) {
	 *     console.log('发生错误', error, obj);
	 * }
	 *
	 * function onLoginPortsChange(loginPorts) {
	 *     console.log('当前登录帐号在其它端的状态发生改变了', loginPorts);
	 * }
	 *
	 * function onBlacklist(blacklist) {
	 *     console.log('收到黑名单', blacklist);
	 *     data.blacklist = nim.mergeRelations(data.blacklist, blacklist);
	 *     data.blacklist = nim.cutRelations(data.blacklist, blacklist.invalid);
	 *     refreshBlacklistUI();
	 * }
	 * function onMarkInBlacklist(obj) {
	 *     console.log(obj.account + '被你' + (obj.isAdd ? '加入' : '移除') + '黑名单', obj);
	 *     if (obj.isAdd) {
	 *         addToBlacklist(obj);
	 *     } else {
	 *         removeFromBlacklist(obj);
	 *     }
	 * }
	 * function addToBlacklist(obj) {
	 *     data.blacklist = nim.mergeRelations(data.blacklist, obj.record);
	 *     refreshBlacklistUI();
	 * }
	 * function removeFromBlacklist(obj) {
	 *     data.blacklist = nim.cutRelations(data.blacklist, obj.record);
	 *     refreshBlacklistUI();
	 * }
	 * function refreshBlacklistUI() {
	 *     // 刷新界面
	 * }
	 * function onMutelist(mutelist) {
	 *     console.log('收到静音列表', mutelist);
	 *     data.mutelist = nim.mergeRelations(data.mutelist, mutelist);
	 *     data.mutelist = nim.cutRelations(data.mutelist, mutelist.invalid);
	 *     refreshMutelistUI();
	 * }
	 * function onMarkInMutelist(obj) {
	 *     console.log(obj.account + '被你' + (obj.isAdd ? '加入' : '移除') + '静音列表', obj);
	 *     if (obj.isAdd) {
	 *         addToMutelist(obj);
	 *     } else {
	 *         removeFromMutelist(obj);
	 *     }
	 * }
	 * function addToMutelist(obj) {
	 *     data.mutelist = nim.mergeRelations(data.mutelist, obj.record);
	 *     refreshMutelistUI();
	 * }
	 * function removeFromMutelist(obj) {
	 *     data.mutelist = nim.cutRelations(data.mutelist, obj.record);
	 *     refreshMutelistUI();
	 * }
	 * function refreshMutelistUI() {
	 *     // 刷新界面
	 * }
	 *
	 * function onFriends(friends) {
	 *     console.log('收到好友列表', friends);
	 *     data.friends = nim.mergeFriends(data.friends, friends);
	 *     data.friends = nim.cutFriends(data.friends, friends.invalid);
	 *     refreshFriendsUI();
	 * }
	 * function onSyncFriendAction(obj) {
	 *     console.log('收到好友操作', obj);
	 *     switch (obj.type) {
	 *     case 'addFriend':
	 *         console.log('你在其它端直接加了一个好友' + obj);
	 *         onAddFriend(obj.friend);
	 *         break;
	 *     case 'applyFriend':
	 *         console.log('你在其它端申请加了一个好友' + obj);
	 *         break;
	 *     case 'passFriendApply':
	 *         console.log('你在其它端通过了一个好友申请' + obj);
	 *         onAddFriend(obj.friend);
	 *         break;
	 *     case 'rejectFriendApply':
	 *         console.log('你在其它端拒绝了一个好友申请' + obj);
	 *         break;
	 *     case 'deleteFriend':
	 *         console.log('你在其它端删了一个好友' + obj);
	 *         onDeleteFriend(obj.account);
	 *         break;
	 *     case 'updateFriend':
	 *         console.log('你在其它端更新了一个好友', obj);
	 *         onUpdateFriend(obj.friend);
	 *         break;
	 *     }
	 * }
	 * function onAddFriend(friend) {
	 *     data.friends = nim.mergeFriends(data.friends, friend);
	 *     refreshFriendsUI();
	 * }
	 * function onDeleteFriend(account) {
	 *     data.friends = nim.cutFriendsByAccounts(data.friends, account);
	 *     refreshFriendsUI();
	 * }
	 * function onUpdateFriend(friend) {
	 *     data.friends = nim.mergeFriends(data.friends, friend);
	 *     refreshFriendsUI();
	 * }
	 * function refreshFriendsUI() {
	 *     // 刷新界面
	 * }
	 *
	 * function onMyInfo(user) {
	 *     console.log('收到我的名片', user);
	 *     data.myInfo = user;
	 *     updateMyInfoUI();
	 * }
	 * function onUpdateMyInfo(user) {
	 *     console.log('我的名片更新了', user);
	 *     data.myInfo = NIM.util.merge(data.myInfo, user);
	 *     updateMyInfoUI();
	 * }
	 * function updateMyInfoUI() {
	 *     // 刷新界面
	 * }
	 * function onUsers(users) {
	 *     console.log('收到用户名片列表', users);
	 *     data.users = nim.mergeUsers(data.users, users);
	 * }
	 * function onUpdateUser(user) {
	 *     console.log('用户名片更新了', user);
	 *     data.users = nim.mergeUsers(data.users, user);
	 * }
	 *
	 * function onTeams(teams) {
	 *     console.log('群列表', teams);
	 *     data.teams = nim.mergeTeams(data.teams, teams);
	 *     onInvalidTeams(teams.invalid);
	 * }
	 * function onInvalidTeams(teams) {
	 *     data.teams = nim.cutTeams(data.teams, teams);
	 *     data.invalidTeams = nim.mergeTeams(data.invalidTeams, teams);
	 *     refreshTeamsUI();
	 * }
	 * function onCreateTeam(team) {
	 *     console.log('你创建了一个群', team);
	 *     data.teams = nim.mergeTeams(data.teams, team);
	 *     refreshTeamsUI();
	 *     onTeamMembers({
	 *         teamId: team.teamId,
	 *         members: owner
	 *     });
	 * }
	 * function refreshTeamsUI() {
	 *     // 刷新界面
	 * }
	 * function onTeamMembers(obj) {
	 *     console.log('收到群成员', obj);
	 *     var teamId = obj.teamId;
	 *     var members = obj.members;
	 *     data.teamMembers = data.teamMembers || {};
	 *     data.teamMembers[teamId] = nim.mergeTeamMembers(data.teamMembers[teamId], members);
	 *     data.teamMembers[teamId] = nim.cutTeamMembers(data.teamMembers[teamId], members.invalid);
	 *     refreshTeamMembersUI();
	 * }
	 * function onSyncTeamMembersDone() {
	 *     console.log('同步群列表完成');
	 * }
	 * function onUpdateTeamMember(teamMember) {
	 *     console.log('群成员信息更新了', teamMember);
	 *     onTeamMembers({
	 *         teamId: teamMember.teamId,
	 *         members: teamMember
	 *     });
	 * }
	 * function refreshTeamMembersUI() {
	 *     // 刷新界面
	 * }
	 *
	 * function onSessions(sessions) {
	 *     console.log('收到会话列表', sessions);
	 *     data.sessions = nim.mergeSessions(data.sessions, sessions);
	 *     updateSessionsUI();
	 * }
	 * function onUpdateSession(session) {
	 *     console.log('会话更新了', session);
	 *     data.sessions = nim.mergeSessions(data.sessions, session);
	 *     updateSessionsUI();
	 * }
	 * function updateSessionsUI() {
	 *     // 刷新界面
	 * }
	 *
	 * function onRoamingMsgs(obj) {
	 *     console.log('漫游消息', obj);
	 *     pushMsg(obj.msgs);
	 * }
	 * function onOfflineMsgs(obj) {
	 *     console.log('离线消息', obj);
	 *     pushMsg(obj.msgs);
	 * }
	 * function onMsg(msg) {
	 *     console.log('收到消息', msg.scene, msg.type, msg);
	 *     pushMsg(msg);
	 * }
	 * function pushMsg(msgs) {
	 *     if (!Array.isArray(msgs)) { msgs = [msgs]; }
	 *     var sessionId = msgs[0].sessionId;
	 *     data.msgs = data.msgs || {};
	 *     data.msgs[sessionId] = nim.mergeMsgs(data.msgs[sessionId], msgs);
	 * }
	 *
	 * function onOfflineSysMsgs(sysMsgs) {
	 *     console.log('收到离线系统通知', sysMsgs);
	 *     pushSysMsgs(sysMsgs);
	 * }
	 * function onSysMsg(sysMsg) {
	 *     console.log('收到系统通知', sysMsg)
	 *     pushSysMsgs(sysMsg);
	 * }
	 * function onUpdateSysMsg(sysMsg) {
	 *     pushSysMsgs(sysMsg);
	 * }
	 * function pushSysMsgs(sysMsgs) {
	 *     data.sysMsgs = nim.mergeSysMsgs(data.sysMsgs, sysMsgs);
	 *     refreshSysMsgsUI();
	 * }
	 * function onSysMsgUnread(obj) {
	 *     console.log('收到系统通知未读数', obj);
	 *     data.sysMsgUnread = obj;
	 *     refreshSysMsgsUI();
	 * }
	 * function onUpdateSysMsgUnread(obj) {
	 *     console.log('系统通知未读数更新了', obj);
	 *     data.sysMsgUnread = obj;
	 *     refreshSysMsgsUI();
	 * }
	 * function refreshSysMsgsUI() {
	 *     // 刷新界面
	 * }
	 * function onOfflineCustomSysMsgs(sysMsgs) {
	 *     console.log('收到离线自定义系统通知', sysMsgs);
	 * }
	 * function onCustomSysMsg(sysMsg) {
	 *     console.log('收到自定义系统通知', sysMsg);
	 * }
	 *
	 * function onSyncDone() {
	 *     console.log('同步完成');
	 * }
	 */
	NIM.getInstance = ApiBase.getInstance;
	NIM.rmAllInstances = ApiBase.rmAllInstances;
	/**
	 * 更新配置, 参数格式跟 {@link NIM.getInstance} 保持一致
	 *
	 * @memberOf NIM#
	 * @method setOptions
	 *
	 * @param {Object}              options                                 配置参数
	 * @param {String}              options.token                           帐号的 token, 用于建立连接
	 *
	 * @example
	 * // 更新 token 的例子
	 * nim.setOptions({
	 *     token: 'newToken'
	 * });
	 */

	NIM.genInstanceName = function (options) {
	  return 'NIM-account-' + options.account;
	};

	var NIMFn = NIM.fn = NIM.prototype = Object.create(ApiBase.prototype);

	NIM.info = NIMFn.info = config.info;

	module.exports = NIM;

	__webpack_require__(97);
	__webpack_require__(93);
	__webpack_require__(103);
	__webpack_require__(108);
	__webpack_require__(96);
	__webpack_require__(104);
	__webpack_require__(107);
	__webpack_require__(105);
	__webpack_require__(98);
	__webpack_require__(106);
	__webpack_require__(92);
	__webpack_require__(100);
	__webpack_require__(101);
	__webpack_require__(91);
	__webpack_require__(94);
	__webpack_require__(102);
	__webpack_require__(95);

/***/ },
/* 7 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var has = Object.prototype.hasOwnProperty
	  , prefix = '~';

	/**
	 * Constructor to create a storage for our `EE` objects.
	 * An `Events` instance is a plain object whose properties are event names.
	 *
	 * @constructor
	 * @api private
	 */
	function Events() {}

	//
	// We try to not inherit from `Object.prototype`. In some engines creating an
	// instance in this way is faster than calling `Object.create(null)` directly.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// character to make sure that the built-in object properties are not
	// overridden or used as an attack vector.
	//
	if (Object.create) {
	  Events.prototype = Object.create(null);

	  //
	  // This hack is needed because the `__proto__` property is still inherited in
	  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
	  //
	  if (!new Events().__proto__) prefix = false;
	}

	/**
	 * Representation of a single event listener.
	 *
	 * @param {Function} fn The listener function.
	 * @param {Mixed} context The context to invoke the listener with.
	 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
	 * @constructor
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}

	/**
	 * Minimal `EventEmitter` interface that is molded against the Node.js
	 * `EventEmitter` interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() {
	  this._events = new Events();
	  this._eventsCount = 0;
	}

	/**
	 * Return an array listing the events for which the emitter has registered
	 * listeners.
	 *
	 * @returns {Array}
	 * @api public
	 */
	EventEmitter.prototype.eventNames = function eventNames() {
	  var names = []
	    , events
	    , name;

	  if (this._eventsCount === 0) return names;

	  for (name in (events = this._events)) {
	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	  }

	  if (Object.getOwnPropertySymbols) {
	    return names.concat(Object.getOwnPropertySymbols(events));
	  }

	  return names;
	};

	/**
	 * Return the listeners registered for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Boolean} exists Only check if there are listeners.
	 * @returns {Array|Boolean}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event, exists) {
	  var evt = prefix ? prefix + event : event
	    , available = this._events[evt];

	  if (exists) return !!available;
	  if (!available) return [];
	  if (available.fn) return [available.fn];

	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	    ee[i] = available[i].fn;
	  }

	  return ee;
	};

	/**
	 * Calls each of the listeners registered for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @returns {Boolean} `true` if the event had listeners, else `false`.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) return false;

	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;

	  if (listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }

	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }

	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;

	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }

	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }

	  return true;
	};

	/**
	 * Add a listener for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {Mixed} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this)
	    , evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
	  else if (!this._events[evt].fn) this._events[evt].push(listener);
	  else this._events[evt] = [this._events[evt], listener];

	  return this;
	};

	/**
	 * Add a one-time listener for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {Mixed} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true)
	    , evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
	  else if (!this._events[evt].fn) this._events[evt].push(listener);
	  else this._events[evt] = [this._events[evt], listener];

	  return this;
	};

	/**
	 * Remove the listeners of a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Function} fn Only remove the listeners that match this function.
	 * @param {Mixed} context Only remove the listeners that have this context.
	 * @param {Boolean} once Only remove one-time listeners.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events[evt]) return this;
	  if (!fn) {
	    if (--this._eventsCount === 0) this._events = new Events();
	    else delete this._events[evt];
	    return this;
	  }

	  var listeners = this._events[evt];

	  if (listeners.fn) {
	    if (
	         listeners.fn === fn
	      && (!once || listeners.once)
	      && (!context || listeners.context === context)
	    ) {
	      if (--this._eventsCount === 0) this._events = new Events();
	      else delete this._events[evt];
	    }
	  } else {
	    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
	      if (
	           listeners[i].fn !== fn
	        || (once && !listeners[i].once)
	        || (context && listeners[i].context !== context)
	      ) {
	        events.push(listeners[i]);
	      }
	    }

	    //
	    // Reset the array, or remove it completely if we have no more listeners.
	    //
	    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
	    else if (--this._eventsCount === 0) this._events = new Events();
	    else delete this._events[evt];
	  }

	  return this;
	};

	/**
	 * Remove all listeners, or those of the specified event.
	 *
	 * @param {String|Symbol} [event] The event name.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  var evt;

	  if (event) {
	    evt = prefix ? prefix + event : event;
	    if (this._events[evt]) {
	      if (--this._eventsCount === 0) this._events = new Events();
	      else delete this._events[evt];
	    }
	  } else {
	    this._events = new Events();
	    this._eventsCount = 0;
	  }

	  return this;
	};

	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};

	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;

	//
	// Allow `EventEmitter` to be imported as module namespace.
	//
	EventEmitter.EventEmitter = EventEmitter;

	//
	// Expose the module.
	//
	if (true) {
	  module.exports = EventEmitter;
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*!
	 * Platform.js <https://mths.be/platform>
	 * Copyright 2014-2016 Benjamin Tan <https://demoneaux.github.io/>
	 * Copyright 2011-2013 John-David Dalton <http://allyoucanleet.com/>
	 * Available under MIT license <https://mths.be/mit>
	 */
	;(function() {
	  'use strict';

	  /** Used to determine if values are of the language type `Object`. */
	  var objectTypes = {
	    'function': true,
	    'object': true
	  };

	  /** Used as a reference to the global object. */
	  var root = (objectTypes[typeof window] && window) || this;

	  /** Backup possible global object. */
	  var oldRoot = root;

	  /** Detect free variable `exports`. */
	  var freeExports = objectTypes[typeof exports] && exports;

	  /** Detect free variable `module`. */
	  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

	  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
	  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
	  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
	    root = freeGlobal;
	  }

	  /**
	   * Used as the maximum length of an array-like object.
	   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
	   * for more details.
	   */
	  var maxSafeInteger = Math.pow(2, 53) - 1;

	  /** Regular expression to detect Opera. */
	  var reOpera = /\bOpera/;

	  /** Possible global object. */
	  var thisBinding = this;

	  /** Used for native method references. */
	  var objectProto = Object.prototype;

	  /** Used to check for own properties of an object. */
	  var hasOwnProperty = objectProto.hasOwnProperty;

	  /** Used to resolve the internal `[[Class]]` of values. */
	  var toString = objectProto.toString;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Capitalizes a string value.
	   *
	   * @private
	   * @param {string} string The string to capitalize.
	   * @returns {string} The capitalized string.
	   */
	  function capitalize(string) {
	    string = String(string);
	    return string.charAt(0).toUpperCase() + string.slice(1);
	  }

	  /**
	   * A utility function to clean up the OS name.
	   *
	   * @private
	   * @param {string} os The OS name to clean up.
	   * @param {string} [pattern] A `RegExp` pattern matching the OS name.
	   * @param {string} [label] A label for the OS.
	   */
	  function cleanupOS(os, pattern, label) {
	    // Platform tokens are defined at:
	    // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
	    // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
	    var data = {
	      '10.0': '10',
	      '6.4':  '10 Technical Preview',
	      '6.3':  '8.1',
	      '6.2':  '8',
	      '6.1':  'Server 2008 R2 / 7',
	      '6.0':  'Server 2008 / Vista',
	      '5.2':  'Server 2003 / XP 64-bit',
	      '5.1':  'XP',
	      '5.01': '2000 SP1',
	      '5.0':  '2000',
	      '4.0':  'NT',
	      '4.90': 'ME'
	    };
	    // Detect Windows version from platform tokens.
	    if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) &&
	        (data = data[/[\d.]+$/.exec(os)])) {
	      os = 'Windows ' + data;
	    }
	    // Correct character case and cleanup string.
	    os = String(os);

	    if (pattern && label) {
	      os = os.replace(RegExp(pattern, 'i'), label);
	    }

	    os = format(
	      os.replace(/ ce$/i, ' CE')
	        .replace(/\bhpw/i, 'web')
	        .replace(/\bMacintosh\b/, 'Mac OS')
	        .replace(/_PowerPC\b/i, ' OS')
	        .replace(/\b(OS X) [^ \d]+/i, '$1')
	        .replace(/\bMac (OS X)\b/, '$1')
	        .replace(/\/(\d)/, ' $1')
	        .replace(/_/g, '.')
	        .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
	        .replace(/\bx86\.64\b/gi, 'x86_64')
	        .replace(/\b(Windows Phone) OS\b/, '$1')
	        .replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1')
	        .split(' on ')[0]
	    );

	    return os;
	  }

	  /**
	   * An iteration utility for arrays and objects.
	   *
	   * @private
	   * @param {Array|Object} object The object to iterate over.
	   * @param {Function} callback The function called per iteration.
	   */
	  function each(object, callback) {
	    var index = -1,
	        length = object ? object.length : 0;

	    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
	      while (++index < length) {
	        callback(object[index], index, object);
	      }
	    } else {
	      forOwn(object, callback);
	    }
	  }

	  /**
	   * Trim and conditionally capitalize string values.
	   *
	   * @private
	   * @param {string} string The string to format.
	   * @returns {string} The formatted string.
	   */
	  function format(string) {
	    string = trim(string);
	    return /^(?:webOS|i(?:OS|P))/.test(string)
	      ? string
	      : capitalize(string);
	  }

	  /**
	   * Iterates over an object's own properties, executing the `callback` for each.
	   *
	   * @private
	   * @param {Object} object The object to iterate over.
	   * @param {Function} callback The function executed per own property.
	   */
	  function forOwn(object, callback) {
	    for (var key in object) {
	      if (hasOwnProperty.call(object, key)) {
	        callback(object[key], key, object);
	      }
	    }
	  }

	  /**
	   * Gets the internal `[[Class]]` of a value.
	   *
	   * @private
	   * @param {*} value The value.
	   * @returns {string} The `[[Class]]`.
	   */
	  function getClassOf(value) {
	    return value == null
	      ? capitalize(value)
	      : toString.call(value).slice(8, -1);
	  }

	  /**
	   * Host objects can return type values that are different from their actual
	   * data type. The objects we are concerned with usually return non-primitive
	   * types of "object", "function", or "unknown".
	   *
	   * @private
	   * @param {*} object The owner of the property.
	   * @param {string} property The property to check.
	   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
	   */
	  function isHostType(object, property) {
	    var type = object != null ? typeof object[property] : 'number';
	    return !/^(?:boolean|number|string|undefined)$/.test(type) &&
	      (type == 'object' ? !!object[property] : true);
	  }

	  /**
	   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
	   *
	   * @private
	   * @param {string} string The string to qualify.
	   * @returns {string} The qualified string.
	   */
	  function qualify(string) {
	    return String(string).replace(/([ -])(?!$)/g, '$1?');
	  }

	  /**
	   * A bare-bones `Array#reduce` like utility function.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} callback The function called per iteration.
	   * @returns {*} The accumulated result.
	   */
	  function reduce(array, callback) {
	    var accumulator = null;
	    each(array, function(value, index) {
	      accumulator = callback(accumulator, value, index, array);
	    });
	    return accumulator;
	  }

	  /**
	   * Removes leading and trailing whitespace from a string.
	   *
	   * @private
	   * @param {string} string The string to trim.
	   * @returns {string} The trimmed string.
	   */
	  function trim(string) {
	    return String(string).replace(/^ +| +$/g, '');
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Creates a new platform object.
	   *
	   * @memberOf platform
	   * @param {Object|string} [ua=navigator.userAgent] The user agent string or
	   *  context object.
	   * @returns {Object} A platform object.
	   */
	  function parse(ua) {

	    /** The environment context object. */
	    var context = root;

	    /** Used to flag when a custom context is provided. */
	    var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';

	    // Juggle arguments.
	    if (isCustomContext) {
	      context = ua;
	      ua = null;
	    }

	    /** Browser navigator object. */
	    var nav = context.navigator || {};

	    /** Browser user agent string. */
	    var userAgent = nav.userAgent || '';

	    ua || (ua = userAgent);

	    /** Used to flag when `thisBinding` is the [ModuleScope]. */
	    var isModuleScope = isCustomContext || thisBinding == oldRoot;

	    /** Used to detect if browser is like Chrome. */
	    var likeChrome = isCustomContext
	      ? !!nav.likeChrome
	      : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

	    /** Internal `[[Class]]` value shortcuts. */
	    var objectClass = 'Object',
	        airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
	        enviroClass = isCustomContext ? objectClass : 'Environment',
	        javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),
	        phantomClass = isCustomContext ? objectClass : 'RuntimeObject';

	    /** Detect Java environments. */
	    var java = /\bJava/.test(javaClass) && context.java;

	    /** Detect Rhino. */
	    var rhino = java && getClassOf(context.environment) == enviroClass;

	    /** A character to represent alpha. */
	    var alpha = java ? 'a' : '\u03b1';

	    /** A character to represent beta. */
	    var beta = java ? 'b' : '\u03b2';

	    /** Browser document object. */
	    var doc = context.document || {};

	    /**
	     * Detect Opera browser (Presto-based).
	     * http://www.howtocreate.co.uk/operaStuff/operaObject.html
	     * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
	     */
	    var opera = context.operamini || context.opera;

	    /** Opera `[[Class]]`. */
	    var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera))
	      ? operaClass
	      : (opera = null);

	    /*------------------------------------------------------------------------*/

	    /** Temporary variable used over the script's lifetime. */
	    var data;

	    /** The CPU architecture. */
	    var arch = ua;

	    /** Platform description array. */
	    var description = [];

	    /** Platform alpha/beta indicator. */
	    var prerelease = null;

	    /** A flag to indicate that environment features should be used to resolve the platform. */
	    var useFeatures = ua == userAgent;

	    /** The browser/environment version. */
	    var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();

	    /** A flag to indicate if the OS ends with "/ Version" */
	    var isSpecialCasedOS;

	    /* Detectable layout engines (order is important). */
	    var layout = getLayout([
	      { 'label': 'EdgeHTML', 'pattern': 'Edge' },
	      'Trident',
	      { 'label': 'WebKit', 'pattern': 'AppleWebKit' },
	      'iCab',
	      'Presto',
	      'NetFront',
	      'Tasman',
	      'KHTML',
	      'Gecko'
	    ]);

	    /* Detectable browser names (order is important). */
	    var name = getName([
	      'Adobe AIR',
	      'Arora',
	      'Avant Browser',
	      'Breach',
	      'Camino',
	      'Epiphany',
	      'Fennec',
	      'Flock',
	      'Galeon',
	      'GreenBrowser',
	      'iCab',
	      'Iceweasel',
	      'K-Meleon',
	      'Konqueror',
	      'Lunascape',
	      'Maxthon',
	      { 'label': 'Microsoft Edge', 'pattern': 'Edge' },
	      'Midori',
	      'Nook Browser',
	      'PaleMoon',
	      'PhantomJS',
	      'Raven',
	      'Rekonq',
	      'RockMelt',
	      'SeaMonkey',
	      { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
	      'Sleipnir',
	      'SlimBrowser',
	      { 'label': 'SRWare Iron', 'pattern': 'Iron' },
	      'Sunrise',
	      'Swiftfox',
	      'WebPositive',
	      'Opera Mini',
	      { 'label': 'Opera Mini', 'pattern': 'OPiOS' },
	      'Opera',
	      { 'label': 'Opera', 'pattern': 'OPR' },
	      'Chrome',
	      { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' },
	      { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' },
	      { 'label': 'Firefox for iOS', 'pattern': 'FxiOS' },
	      { 'label': 'IE', 'pattern': 'IEMobile' },
	      { 'label': 'IE', 'pattern': 'MSIE' },
	      'Safari'
	    ]);

	    /* Detectable products (order is important). */
	    var product = getProduct([
	      { 'label': 'BlackBerry', 'pattern': 'BB10' },
	      'BlackBerry',
	      { 'label': 'Galaxy S', 'pattern': 'GT-I9000' },
	      { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' },
	      { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' },
	      { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' },
	      'Google TV',
	      'Lumia',
	      'iPad',
	      'iPod',
	      'iPhone',
	      'Kindle',
	      { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
	      'Nexus',
	      'Nook',
	      'PlayBook',
	      'PlayStation 3',
	      'PlayStation 4',
	      'PlayStation Vita',
	      'TouchPad',
	      'Transformer',
	      { 'label': 'Wii U', 'pattern': 'WiiU' },
	      'Wii',
	      'Xbox One',
	      { 'label': 'Xbox 360', 'pattern': 'Xbox' },
	      'Xoom'
	    ]);

	    /* Detectable manufacturers. */
	    var manufacturer = getManufacturer({
	      'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
	      'Archos': {},
	      'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
	      'Asus': { 'Transformer': 1 },
	      'Barnes & Noble': { 'Nook': 1 },
	      'BlackBerry': { 'PlayBook': 1 },
	      'Google': { 'Google TV': 1, 'Nexus': 1 },
	      'HP': { 'TouchPad': 1 },
	      'HTC': {},
	      'LG': {},
	      'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
	      'Motorola': { 'Xoom': 1 },
	      'Nintendo': { 'Wii U': 1,  'Wii': 1 },
	      'Nokia': { 'Lumia': 1 },
	      'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
	      'Sony': { 'PlayStation 4': 1, 'PlayStation 3': 1, 'PlayStation Vita': 1 }
	    });

	    /* Detectable operating systems (order is important). */
	    var os = getOS([
	      'Windows Phone',
	      'Android',
	      'CentOS',
	      { 'label': 'Chrome OS', 'pattern': 'CrOS' },
	      'Debian',
	      'Fedora',
	      'FreeBSD',
	      'Gentoo',
	      'Haiku',
	      'Kubuntu',
	      'Linux Mint',
	      'OpenBSD',
	      'Red Hat',
	      'SuSE',
	      'Ubuntu',
	      'Xubuntu',
	      'Cygwin',
	      'Symbian OS',
	      'hpwOS',
	      'webOS ',
	      'webOS',
	      'Tablet OS',
	      'Linux',
	      'Mac OS X',
	      'Macintosh',
	      'Mac',
	      'Windows 98;',
	      'Windows '
	    ]);

	    /*------------------------------------------------------------------------*/

	    /**
	     * Picks the layout engine from an array of guesses.
	     *
	     * @private
	     * @param {Array} guesses An array of guesses.
	     * @returns {null|string} The detected layout engine.
	     */
	    function getLayout(guesses) {
	      return reduce(guesses, function(result, guess) {
	        return result || RegExp('\\b' + (
	          guess.pattern || qualify(guess)
	        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
	      });
	    }

	    /**
	     * Picks the manufacturer from an array of guesses.
	     *
	     * @private
	     * @param {Array} guesses An object of guesses.
	     * @returns {null|string} The detected manufacturer.
	     */
	    function getManufacturer(guesses) {
	      return reduce(guesses, function(result, value, key) {
	        // Lookup the manufacturer by product or scan the UA for the manufacturer.
	        return result || (
	          value[product] ||
	          value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] ||
	          RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)
	        ) && key;
	      });
	    }

	    /**
	     * Picks the browser name from an array of guesses.
	     *
	     * @private
	     * @param {Array} guesses An array of guesses.
	     * @returns {null|string} The detected browser name.
	     */
	    function getName(guesses) {
	      return reduce(guesses, function(result, guess) {
	        return result || RegExp('\\b' + (
	          guess.pattern || qualify(guess)
	        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
	      });
	    }

	    /**
	     * Picks the OS name from an array of guesses.
	     *
	     * @private
	     * @param {Array} guesses An array of guesses.
	     * @returns {null|string} The detected OS name.
	     */
	    function getOS(guesses) {
	      return reduce(guesses, function(result, guess) {
	        var pattern = guess.pattern || qualify(guess);
	        if (!result && (result =
	              RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua)
	            )) {
	          result = cleanupOS(result, pattern, guess.label || guess);
	        }
	        return result;
	      });
	    }

	    /**
	     * Picks the product name from an array of guesses.
	     *
	     * @private
	     * @param {Array} guesses An array of guesses.
	     * @returns {null|string} The detected product name.
	     */
	    function getProduct(guesses) {
	      return reduce(guesses, function(result, guess) {
	        var pattern = guess.pattern || qualify(guess);
	        if (!result && (result =
	              RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) ||
	              RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua)
	            )) {
	          // Split by forward slash and append product version if needed.
	          if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
	            result[0] += ' ' + result[1];
	          }
	          // Correct character case and cleanup string.
	          guess = guess.label || guess;
	          result = format(result[0]
	            .replace(RegExp(pattern, 'i'), guess)
	            .replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ')
	            .replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
	        }
	        return result;
	      });
	    }

	    /**
	     * Resolves the version using an array of UA patterns.
	     *
	     * @private
	     * @param {Array} patterns An array of UA patterns.
	     * @returns {null|string} The detected version.
	     */
	    function getVersion(patterns) {
	      return reduce(patterns, function(result, pattern) {
	        return result || (RegExp(pattern +
	          '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
	      });
	    }

	    /**
	     * Returns `platform.description` when the platform object is coerced to a string.
	     *
	     * @name toString
	     * @memberOf platform
	     * @returns {string} Returns `platform.description` if available, else an empty string.
	     */
	    function toStringPlatform() {
	      return this.description || '';
	    }

	    /*------------------------------------------------------------------------*/

	    // Convert layout to an array so we can add extra details.
	    layout && (layout = [layout]);

	    // Detect product names that contain their manufacturer's name.
	    if (manufacturer && !product) {
	      product = getProduct([manufacturer]);
	    }
	    // Clean up Google TV.
	    if ((data = /\bGoogle TV\b/.exec(product))) {
	      product = data[0];
	    }
	    // Detect simulators.
	    if (/\bSimulator\b/i.test(ua)) {
	      product = (product ? product + ' ' : '') + 'Simulator';
	    }
	    // Detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS.
	    if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
	      description.push('running in Turbo/Uncompressed mode');
	    }
	    // Detect IE Mobile 11.
	    if (name == 'IE' && /\blike iPhone OS\b/.test(ua)) {
	      data = parse(ua.replace(/like iPhone OS/, ''));
	      manufacturer = data.manufacturer;
	      product = data.product;
	    }
	    // Detect iOS.
	    else if (/^iP/.test(product)) {
	      name || (name = 'Safari');
	      os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua))
	        ? ' ' + data[1].replace(/_/g, '.')
	        : '');
	    }
	    // Detect Kubuntu.
	    else if (name == 'Konqueror' && !/buntu/i.test(os)) {
	      os = 'Kubuntu';
	    }
	    // Detect Android browsers.
	    else if ((manufacturer && manufacturer != 'Google' &&
	        ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) ||
	        (/\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua))) {
	      name = 'Android Browser';
	      os = /\bAndroid\b/.test(os) ? os : 'Android';
	    }
	    // Detect Silk desktop/accelerated modes.
	    else if (name == 'Silk') {
	      if (!/\bMobi/i.test(ua)) {
	        os = 'Android';
	        description.unshift('desktop mode');
	      }
	      if (/Accelerated *= *true/i.test(ua)) {
	        description.unshift('accelerated');
	      }
	    }
	    // Detect PaleMoon identifying as Firefox.
	    else if (name == 'PaleMoon' && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
	      description.push('identifying as Firefox ' + data[1]);
	    }
	    // Detect Firefox OS and products running Firefox.
	    else if (name == 'Firefox' && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
	      os || (os = 'Firefox OS');
	      product || (product = data[1]);
	    }
	    // Detect false positives for Firefox/Safari.
	    else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
	      // Escape the `/` for Firefox 1.
	      if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
	        // Clear name of false positives.
	        name = null;
	      }
	      // Reassign a generic name.
	      if ((data = product || manufacturer || os) &&
	          (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
	        name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
	      }
	    }
	    // Detect non-Opera (Presto-based) versions (order is important).
	    if (!version) {
	      version = getVersion([
	        '(?:Cloud9|CriOS|CrMo|Edge|FxiOS|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|Silk(?!/[\\d.]+$))',
	        'Version',
	        qualify(name),
	        '(?:Firefox|Minefield|NetFront)'
	      ]);
	    }
	    // Detect stubborn layout engines.
	    if ((data =
	          layout == 'iCab' && parseFloat(version) > 3 && 'WebKit' ||
	          /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') ||
	          /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && 'WebKit' ||
	          !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident') ||
	          layout == 'WebKit' && /\bPlayStation\b(?! Vita\b)/i.test(name) && 'NetFront'
	        )) {
	      layout = [data];
	    }
	    // Detect Windows Phone 7 desktop mode.
	    if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
	      name += ' Mobile';
	      os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
	      description.unshift('desktop mode');
	    }
	    // Detect Windows Phone 8.x desktop mode.
	    else if (/\bWPDesktop\b/i.test(ua)) {
	      name = 'IE Mobile';
	      os = 'Windows Phone 8.x';
	      description.unshift('desktop mode');
	      version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
	    }
	    // Detect IE 11.
	    else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
	      if (name) {
	        description.push('identifying as ' + name + (version ? ' ' + version : ''));
	      }
	      name = 'IE';
	      version = data[1];
	    }
	    // Leverage environment features.
	    if (useFeatures) {
	      // Detect server-side environments.
	      // Rhino has a global function while others have a global object.
	      if (isHostType(context, 'global')) {
	        if (java) {
	          data = java.lang.System;
	          arch = data.getProperty('os.arch');
	          os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
	        }
	        if (isModuleScope && isHostType(context, 'system') && (data = [context.system])[0]) {
	          os || (os = data[0].os || null);
	          try {
	            data[1] = context.require('ringo/engine').version;
	            version = data[1].join('.');
	            name = 'RingoJS';
	          } catch(e) {
	            if (data[0].global.system == context.system) {
	              name = 'Narwhal';
	            }
	          }
	        }
	        else if (
	          typeof context.process == 'object' && !context.process.browser &&
	          (data = context.process)
	        ) {
	          name = 'Node.js';
	          arch = data.arch;
	          os = data.platform;
	          version = /[\d.]+/.exec(data.version)[0];
	        }
	        else if (rhino) {
	          name = 'Rhino';
	        }
	      }
	      // Detect Adobe AIR.
	      else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
	        name = 'Adobe AIR';
	        os = data.flash.system.Capabilities.os;
	      }
	      // Detect PhantomJS.
	      else if (getClassOf((data = context.phantom)) == phantomClass) {
	        name = 'PhantomJS';
	        version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);
	      }
	      // Detect IE compatibility modes.
	      else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
	        // We're in compatibility mode when the Trident version + 4 doesn't
	        // equal the document mode.
	        version = [version, doc.documentMode];
	        if ((data = +data[1] + 4) != version[1]) {
	          description.push('IE ' + version[1] + ' mode');
	          layout && (layout[1] = '');
	          version[1] = data;
	        }
	        version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
	      }
	      os = os && format(os);
	    }
	    // Detect prerelease phases.
	    if (version && (data =
	          /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) ||
	          /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) ||
	          /\bMinefield\b/i.test(ua) && 'a'
	        )) {
	      prerelease = /b/i.test(data) ? 'beta' : 'alpha';
	      version = version.replace(RegExp(data + '\\+?$'), '') +
	        (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
	    }
	    // Detect Firefox Mobile.
	    if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS)\b/.test(os)) {
	      name = 'Firefox Mobile';
	    }
	    // Obscure Maxthon's unreliable version.
	    else if (name == 'Maxthon' && version) {
	      version = version.replace(/\.[\d.]+/, '.x');
	    }
	    // Detect Xbox 360 and Xbox One.
	    else if (/\bXbox\b/i.test(product)) {
	      os = null;
	      if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
	        description.unshift('mobile mode');
	      }
	    }
	    // Add mobile postfix.
	    else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) &&
	        (os == 'Windows CE' || /Mobi/i.test(ua))) {
	      name += ' Mobile';
	    }
	    // Detect IE platform preview.
	    else if (name == 'IE' && useFeatures && context.external === null) {
	      description.unshift('platform preview');
	    }
	    // Detect BlackBerry OS version.
	    // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
	    else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data =
	          (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] ||
	          version
	        )) {
	      data = [data, /BB10/.test(ua)];
	      os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
	      version = null;
	    }
	    // Detect Opera identifying/masking itself as another browser.
	    // http://www.opera.com/support/kb/view/843/
	    else if (this != forOwn && product != 'Wii' && (
	          (useFeatures && opera) ||
	          (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) ||
	          (name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os)) ||
	          (name == 'IE' && (
	            (os && !/^Win/.test(os) && version > 5.5) ||
	            /\bWindows XP\b/.test(os) && version > 8 ||
	            version == 8 && !/\bTrident\b/.test(ua)
	          ))
	        ) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {
	      // When "identifying", the UA contains both Opera and the other browser's name.
	      data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
	      if (reOpera.test(name)) {
	        if (/\bIE\b/.test(data) && os == 'Mac OS') {
	          os = null;
	        }
	        data = 'identify' + data;
	      }
	      // When "masking", the UA contains only the other browser's name.
	      else {
	        data = 'mask' + data;
	        if (operaClass) {
	          name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
	        } else {
	          name = 'Opera';
	        }
	        if (/\bIE\b/.test(data)) {
	          os = null;
	        }
	        if (!useFeatures) {
	          version = null;
	        }
	      }
	      layout = ['Presto'];
	      description.push(data);
	    }
	    // Detect WebKit Nightly and approximate Chrome/Safari versions.
	    if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
	      // Correct build number for numeric comparison.
	      // (e.g. "532.5" becomes "532.05")
	      data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
	      // Nightly builds are postfixed with a "+".
	      if (name == 'Safari' && data[1].slice(-1) == '+') {
	        name = 'WebKit Nightly';
	        prerelease = 'alpha';
	        version = data[1].slice(0, -1);
	      }
	      // Clear incorrect browser versions.
	      else if (version == data[1] ||
	          version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
	        version = null;
	      }
	      // Use the full Chrome version when available.
	      data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
	      // Detect Blink layout engine.
	      if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == 'WebKit') {
	        layout = ['Blink'];
	      }
	      // Detect JavaScriptCore.
	      // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
	      if (!useFeatures || (!likeChrome && !data[1])) {
	        layout && (layout[1] = 'like Safari');
	        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');
	      } else {
	        layout && (layout[1] = 'like Chrome');
	        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
	      }
	      // Add the postfix of ".x" or "+" for approximate versions.
	      layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
	      // Obscure version for some Safari 1-2 releases.
	      if (name == 'Safari' && (!version || parseInt(version) > 45)) {
	        version = data;
	      }
	    }
	    // Detect Opera desktop modes.
	    if (name == 'Opera' &&  (data = /\bzbov|zvav$/.exec(os))) {
	      name += ' ';
	      description.unshift('desktop mode');
	      if (data == 'zvav') {
	        name += 'Mini';
	        version = null;
	      } else {
	        name += 'Mobile';
	      }
	      os = os.replace(RegExp(' *' + data + '$'), '');
	    }
	    // Detect Chrome desktop mode.
	    else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
	      description.unshift('desktop mode');
	      name = 'Chrome Mobile';
	      version = null;

	      if (/\bOS X\b/.test(os)) {
	        manufacturer = 'Apple';
	        os = 'iOS 4.3+';
	      } else {
	        os = null;
	      }
	    }
	    // Strip incorrect OS versions.
	    if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 &&
	        ua.indexOf('/' + data + '-') > -1) {
	      os = trim(os.replace(data, ''));
	    }
	    // Add layout engine.
	    if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (
	        /Browser|Lunascape|Maxthon/.test(name) ||
	        name != 'Safari' && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) ||
	        /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Sleipnir|Web)/.test(name) && layout[1])) {
	      // Don't add layout details to description if they are falsey.
	      (data = layout[layout.length - 1]) && description.push(data);
	    }
	    // Combine contextual information.
	    if (description.length) {
	      description = ['(' + description.join('; ') + ')'];
	    }
	    // Append manufacturer to description.
	    if (manufacturer && product && product.indexOf(manufacturer) < 0) {
	      description.push('on ' + manufacturer);
	    }
	    // Append product to description.
	    if (product) {
	      description.push((/^on /.test(description[description.length - 1]) ? '' : 'on ') + product);
	    }
	    // Parse the OS into an object.
	    if (os) {
	      data = / ([\d.+]+)$/.exec(os);
	      isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
	      os = {
	        'architecture': 32,
	        'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,
	        'version': data ? data[1] : null,
	        'toString': function() {
	          var version = this.version;
	          return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
	        }
	      };
	    }
	    // Add browser/OS architecture.
	    if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
	      if (os) {
	        os.architecture = 64;
	        os.family = os.family.replace(RegExp(' *' + data), '');
	      }
	      if (
	          name && (/\bWOW64\b/i.test(ua) ||
	          (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))
	      ) {
	        description.unshift('32-bit');
	      }
	    }
	    // Chrome 39 and above on OS X is always 64-bit.
	    else if (
	        os && /^OS X/.test(os.family) &&
	        name == 'Chrome' && parseFloat(version) >= 39
	    ) {
	      os.architecture = 64;
	    }

	    ua || (ua = null);

	    /*------------------------------------------------------------------------*/

	    /**
	     * The platform object.
	     *
	     * @name platform
	     * @type Object
	     */
	    var platform = {};

	    /**
	     * The platform description.
	     *
	     * @memberOf platform
	     * @type string|null
	     */
	    platform.description = ua;

	    /**
	     * The name of the browser's layout engine.
	     *
	     * @memberOf platform
	     * @type string|null
	     */
	    platform.layout = layout && layout[0];

	    /**
	     * The name of the product's manufacturer.
	     *
	     * @memberOf platform
	     * @type string|null
	     */
	    platform.manufacturer = manufacturer;

	    /**
	     * The name of the browser/environment.
	     *
	     * @memberOf platform
	     * @type string|null
	     */
	    platform.name = name;

	    /**
	     * The alpha/beta release indicator.
	     *
	     * @memberOf platform
	     * @type string|null
	     */
	    platform.prerelease = prerelease;

	    /**
	     * The name of the product hosting the browser.
	     *
	     * @memberOf platform
	     * @type string|null
	     */
	    platform.product = product;

	    /**
	     * The browser's user agent string.
	     *
	     * @memberOf platform
	     * @type string|null
	     */
	    platform.ua = ua;

	    /**
	     * The browser/environment version.
	     *
	     * @memberOf platform
	     * @type string|null
	     */
	    platform.version = name && version;

	    /**
	     * The name of the operating system.
	     *
	     * @memberOf platform
	     * @type Object
	     */
	    platform.os = os || {

	      /**
	       * The CPU architecture the OS is built for.
	       *
	       * @memberOf platform.os
	       * @type number|null
	       */
	      'architecture': null,

	      /**
	       * The family of the OS.
	       *
	       * Common values include:
	       * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
	       * "Windows XP", "OS X", "Ubuntu", "Debian", "Fedora", "Red Hat", "SuSE",
	       * "Android", "iOS" and "Windows Phone"
	       *
	       * @memberOf platform.os
	       * @type string|null
	       */
	      'family': null,

	      /**
	       * The version of the OS.
	       *
	       * @memberOf platform.os
	       * @type string|null
	       */
	      'version': null,

	      /**
	       * Returns the OS string.
	       *
	       * @memberOf platform.os
	       * @returns {string} The OS string.
	       */
	      'toString': function() { return 'null'; }
	    };

	    platform.parse = parse;
	    platform.toString = toStringPlatform;

	    if (platform.version) {
	      description.unshift(version);
	    }
	    if (platform.name) {
	      description.unshift(name);
	    }
	    if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
	      description.push(product ? '(' + os + ')' : 'on ' + os);
	    }
	    if (description.length) {
	      platform.description = description.join(' ');
	    }
	    return platform;
	  }

	  /*--------------------------------------------------------------------------*/

	  // Export platform.
	  var platform = parse();

	  // Some AMD build optimizers, like r.js, check for condition patterns like the following:
	  if (true) {
	    // Expose platform on the global object to prevent errors when platform is
	    // loaded by a script tag in the presence of an AMD loader.
	    // See http://requirejs.org/docs/errors.html#mismatch for more details.
	    root.platform = platform;

	    // Define as an anonymous module so platform can be aliased through path mapping.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return platform;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
	  else if (freeExports && freeModule) {
	    // Export for CommonJS support.
	    forOwn(platform, function(value, key) {
	      freeExports[key] = value;
	    });
	  }
	  else {
	    // Export to the global object.
	    root.platform = platform;
	  }
	}.call(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)(module), (function() { return this; }())))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/*
	 * Partial support in Safari and iOS 8/9.
	 * - When start a transaction on more than one object stores, Safari throw an error:
	 *     - NotFoundError: DOM IDBDatabase Exception 8: An operation failed because the requested database object could not be found.
	 * - If two objects has same key, when put them into two different object stores, the first one will disappear. (iOS8, not iOS9)
	 * - IndexedDB is not available in iOS 8/9 “UIWebView” (not Safari) or Home screen apps (is standalone)
	 */
	var Promise = __webpack_require__(2).Promise;
	var platform = __webpack_require__(9);
	var deep = __webpack_require__(22);
	var lib = __webpack_require__(39);
	var util = __webpack_require__(1);
	var support = __webpack_require__(46);
	var NIMError = __webpack_require__(4);
	var newSupportDBError = NIMError.newSupportDBError;
	var noDBError = NIMError.noDBError;
	var config = __webpack_require__(110);

	var DBPrefix = 'nim-';
	var _support = false;

	function setSupport(flag) {
	  _support = flag;
	  support.set('db', flag, lib);
	}

	var window = util.getGlobal();

	setSupport(!!window.indexedDB);

	// 如果 chrome 版本小于 50, 那么不启用数据库, 性能太差
	// if (platform.name === 'Chrome') {
	//   try {
	//     const version = parseInt(platform.version)
	//     if (version < 50) {
	//       setSupport(false)
	//     }
	//   } catch (error) {
	//     // ignore error
	//   }
	// }

	// IE 统一不支持数据库, 因为不能使用 array index
	if (platform.name === 'IE') {
	  setSupport(false);
	}

	if (platform.name === 'Microsoft Edge') {
	  setSupport(false);
	}

	if (platform.name === 'Safari') {
	  try {
	    var version = parseInt(platform.version.split('.')[0], 10);
	    // 如果是 iOS8 及以下, 那么不支持数据库, 因为不同的 ObjectStore 使用同一个 key 的话, 后面的记录会覆盖前面的记录
	    if (version < 10) {
	      setSupport(false);
	    }
	  } catch (e) {}
	  // ...

	  // TODO, 统一禁用 Safari 的数据库, 升级到 2.4.0 会有问题, 群和群成员加了字段, 有空再看
	  setSupport(false);
	}

	function DB(options) {
	  this.concurrency = 0;
	  this.pendingTasks = [];
	  this.queue = Promise.resolve();
	  this.logger = options.logger;
	}

	var pro = DB.fn = DB.prototype;

	pro.reset = util.emptyFunc;
	if (_support) {
	  pro.reset = function (o) {
	    // 只有当 o === false 才禁用 db
	    this.enable = o !== false;
	  };
	}

	// 凡是最终调用 lib 或者 self.server 的方法都需要 queue 起来
	// 如果并发太多的话, 数据库会报错, 特别是同步到大量消息/群成员的时候
	pro.addTask = function (task) {
	  var self = this;
	  // return task()
	  return new Promise(function (resolve, reject) {
	    function bingo(cb) {
	      self.concurrency--;
	      var nextTask = self.pendingTasks.shift();
	      if (nextTask) {
	        self.addTask(nextTask);
	      }
	      cb();
	    }
	    if (self.concurrency < 100) {
	      self.concurrency++;
	      return task().then(function (records) {
	        bingo(function () {
	          resolve(records);
	          if (task.resolve) {
	            task.resolve(records);
	          }
	        });
	      }, function (e) {
	        bingo(function () {
	          reject(e);
	          if (task.reject) {
	            task.reject(e);
	          }
	        });
	      });
	    } else {
	      if (!task.resolve) {
	        task.resolve = resolve;
	        task.reject = reject;
	      }
	      self.pendingTasks.push(task);
	    }
	  });
	};

	pro.init = function (name) {
	  var self = this;
	  return self.addTask(function () {
	    if (!self.enable) {
	      return Promise.reject(newSupportDBError());
	    }
	    // 如果已经初始化过了, 那么直接返回
	    if (self.server) {
	      return Promise.resolve();
	    }
	    self.name = DBPrefix + name;
	    return lib.open({
	      server: self.name,
	      version: config.version,
	      schema: config.schema
	    }).then(function (s) {
	      self.logger.warn('init db', self.name);
	      self.server = s;
	    }, function (event) {
	      setSupport(false);
	      self.server = null;
	      self.name = null;
	      throw event;
	    });
	  });
	};

	pro.destroy = function () {
	  var self = this;
	  return self.addTask(function () {
	    if (!self.enable) {
	      return Promise.reject(newSupportDBError());
	    }
	    // 如果已经销毁了, 那么直接返回
	    if (!self.server) {
	      return Promise.resolve();
	    }
	    return lib.remove(self.name).then(function () {
	      self.logger.warn('delete db', self.name);
	      self.server = null;
	      self.name = null;
	    });
	  });
	};

	pro.clear = function () {
	  var self = this;
	  return self.addTask(function () {
	    if (!self.enable) {
	      return Promise.reject(newSupportDBError());
	    }
	    // 如果已经销毁了, 那么直接返回
	    if (!self.server) {
	      return Promise.resolve();
	    }
	    // 先清空 timetag, 然后再清空其它所有数据, 这样就算 timetag 清空失败也是没问题的
	    // 否则的话, 如果 timetag 没被清空, 其它数据被清空了, 同步就会有问题
	    return self.server.clear('timetag').then(function () {
	      var tables = [].slice.call(self.server.getIndexedDB().objectStoreNames);
	      var promiseArray = [];
	      tables.forEach(function (table) {
	        promiseArray.push(self.server.clear(table));
	      });
	      if (promiseArray.length) {
	        return Promise.all(promiseArray).then(function () {
	          self.logger.warn('clear db', self.name);
	        });
	      }
	    });
	  });
	};

	pro.close = function () {
	  var self = this;
	  if (self.server) {
	    self.server.close();
	    self.server = null;
	    self.name = null;
	  }
	};

	pro.remove = function (name, keys) {
	  var self = this;
	  return self.addTask(function () {
	    if (!self.enable) {
	      return Promise.reject(newSupportDBError());
	    }
	    if (!self.server) {
	      return Promise.reject(noDBError());
	    }
	    if (!util.isArray(keys)) {
	      keys = [keys];
	    }
	    // keys = keys.map(function(key) {
	    //     return db.prefixKey(name, key);
	    // });
	    return self.server.remove(name, keys).then(function () {
	      self.logger.warn('delete', name, keys.length === 1 ? keys[0] : keys);
	    });
	  });
	};

	pro.put = function (name, records) {
	  var self = this;
	  return self.addTask(function () {
	    if (!self.enable) {
	      return Promise.reject(newSupportDBError());
	    }
	    if (!self.server) {
	      return Promise.reject(noDBError());
	    }
	    if (!util.isArray(records)) {
	      records = [records];
	    }
	    // records = db.prefixRecords(name, records);
	    return self.server.update(name, records).then(function (records) {
	      var args = ['put', name];
	      var keyPath = config.keyPath(name);
	      var keys = [];
	      if (keyPath) {
	        records.forEach(function (record) {
	          keys.push(deep(record, keyPath));
	        });
	        args.push(keys.length === 1 ? keys[0] : keys);
	      }
	      args.push(records.length === 1 ? records[0] : records);
	      self.logger.warn.apply(self.logger.warn, args);
	      return records;
	    });
	  });
	};

	/*
	 * 如果有记录更新之, 如果没有存储新的
	 */
	pro.modifyOrPut = function (options) {
	  var self = this;
	  var table = options.table;
	  var obj = util.copy(options.obj);
	  var key = options.key;
	  var modifyObjWhenPut = options.modifyObjWhenPut;
	  var modifyObj = util.copy(obj);
	  delete modifyObj[key];
	  return self.getOne(table, null, obj[key], {
	    modifyObj: modifyObj
	  }).then(function (record) {
	    if (!record) {
	      obj = util.merge(obj, modifyObjWhenPut);
	      return self.put(table, obj).then(function (records) {
	        return records[0];
	      });
	    } else {
	      self.logger.warn('update table ' + table, obj);
	      return record;
	    }
	  });
	};

	pro.updateAndDelete = function (name, updates, deletes) {
	  var self = this;
	  return self.addTask(function () {
	    if (!self.enable) {
	      return Promise.reject(newSupportDBError());
	    }
	    if (!self.server) {
	      return Promise.reject(noDBError());
	    }
	    // updates = db.prefixRecords(name, updates);
	    // deletes = db.prefixRecords(name, deletes);
	    return self.server.updateAndDelete(name, updates, deletes);
	  });
	};

	pro.get = function (name, key) {
	  var self = this;
	  return self.addTask(function () {
	    if (!self.enable) {
	      return Promise.reject(newSupportDBError());
	    }
	    if (!self.server) {
	      return Promise.reject(noDBError());
	    }
	    return self.server.get(name, key);
	  });
	};

	pro.getAll = function (name, options) {
	  var self = this;
	  return self.addTask(function () {
	    if (!self.enable) {
	      return Promise.reject(newSupportDBError());
	    }
	    if (!self.server) {
	      return Promise.reject(noDBError());
	    }
	    options = options || {};
	    // 只有明确要 keys desc distinct, 才传 true
	    options.keys = options.keys === true;
	    options.desc = options.desc === true;
	    options.distinct = options.distinct === true;
	    return self.server.query(name, options.index).filter(options.filter).keys(options.keys).desc(options.desc).limit(options.limit).distinct(options.distinct).map(options.mapper).modify(options.modifyObj).execute();
	    // .then(function(records) {
	    //     records = db.unprefixRecords(name, options.keyIsNumber, records);
	    //     return records;
	    // });
	  });
	};

	pro.getOnly = function (name, index, matchValue, options) {
	  var self = this;
	  return self.addTask(function () {
	    if (!self.enable) {
	      throw newSupportDBError();
	    }
	    if (!self.server) {
	      throw noDBError();
	    }
	    options = options || {};
	    // 只有明确要 keys desc distinct remove, 才传 true
	    options.keys = options.keys === true;
	    options.desc = options.desc === true;
	    options.distinct = options.distinct === true;
	    options.remove = options.remove === true;
	    return self.server.query(name, index).only(matchValue).filter(options.filter).keys(options.keys).desc(options.desc).limit(options.limit).distinct(options.distinct).map(options.mapper).modify(options.modifyObj).remove(options.remove).execute();
	  });
	};

	pro.getOne = function () {
	  var self = this;
	  return self.getOnly.apply(self, arguments).then(function (records) {
	    return records[0];
	  });
	};

	pro.clearTable = function (name) {
	  var self = this;
	  return self.addTask(function () {
	    if (!self.enable) {
	      throw newSupportDBError();
	    }
	    if (!self.server) {
	      throw noDBError();
	    }
	    return self.server.clear(name);
	  });
	};

	pro.checkDB = function () {
	  var self = this;
	  if (!self.enable) {
	    throw newSupportDBError();
	  }
	  if (!self.server) {
	    throw noDBError();
	  }
	};

	// TODO openRequest.onblocked, which is triggered when the `onupgradeneeded` event should be triggered but the database is still in use somewhere else.
	// TODO db.onversionchange, which is triggered when the database structure changes in somewhere else.

	module.exports = DB;

	// require('./record');
	__webpack_require__(112);
	__webpack_require__(118);
	__webpack_require__(114);
	__webpack_require__(111);
	__webpack_require__(117);
	__webpack_require__(119);
	__webpack_require__(113);
	__webpack_require__(116);
	__webpack_require__(109);
	__webpack_require__(115);

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var EventEmitter = __webpack_require__(8);
	var Promise = __webpack_require__(2).Promise;
	var util = __webpack_require__(1);
	var notundef = util.notundef;
	var Logger = __webpack_require__(68);
	var CONFIG = __webpack_require__(3);

	function ApiBase() {}

	var instances = {};

	ApiBase.rmAllInstances = function () {
	  instances = {};
	};
	/*
	var nim1 = NIM.getInstance({
	    account: 'zyy1',
	    onmsg: function(msg) {
	        console.log('=======', msg)
	    }
	})
	// true
	nim1 === nim

	var nim2 = new NIM({
	    account: 'zyy1'
	})
	// true
	nim2 === nim

	var chatroom1 = Chatroom.getInstance({
	    account: 'zyy1',
	    chatroomId: 21,
	    onmsgs: function(msgs) {
	        console.log('========', msgs)
	    }
	})
	// true
	chatroom1 === chatroom

	var chatroom2 = new Chatroom({
	    account: 'zyy1',
	    chatroomId: 21
	})
	// true
	chatroom2 === chatroom
	 */
	ApiBase.getInstance = function (options) {
	  var constructor = this;
	  util.verifyOptions(options, 'account');
	  var name = constructor.genInstanceName(options);
	  var instance = instances[name];

	  // 如果此账号已经初始化过实例，那么直接返回该实例
	  if (!instance) {
	    instance = instances[name] = new constructor(options);
	  } else {
	    ApiBase.updateInstance(instance, options);
	  }

	  return instance;
	};

	// 更新配置并连接
	ApiBase.updateInstance = function (instance, options) {
	  instance.setOptions(options);
	  instance.connect();
	};

	var ApiBaseFn = ApiBase.fn = ApiBase.prototype = Object.create(new EventEmitter());

	// new 的时候最终会走到这里，在这里限制单例，逻辑跟 getInstance 一致
	ApiBaseFn.init = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'account');

	  // 将帐号转为字符串
	  var account = self.account = options.account = options.account + '';

	  // 如果此账号已经初始化过实例，那么直接返回该实例
	  var constructor = options.constructor;
	  var name = constructor.genInstanceName(options);
	  var instance = instances[name];

	  // 跳过单例, 用于 debug
	  if (options._disableSingleton) {
	    instance = null;
	  }

	  // 如果此账号已经初始化过实例，那么直接返回该实例
	  if (instance) {
	    ApiBase.updateInstance(instance, options);
	    return instance;
	  } else {
	    self.name = name;
	    instances[name] = self;
	  }

	  // 初始化 logger
	  self.logger = options.logger = new Logger({
	    debug: options.debug,
	    logFunc: options.logFunc,
	    prefix: self.subType
	  });

	  // 初始化 protocol
	  options.api = self;
	  var protocol = self.protocol = new options.Protocol(options);
	  protocol.name = 'Protocol-' + name;
	  protocol.account = account;
	  protocol.api = self;

	  // 初始化 Message
	  protocol.message = self.message = new options.Message({
	    account: account,
	    enabledHttpsForMessage: self.protocol.options.enabledHttpsForMessage || false
	  });

	  self.options = util.copy(options);
	  // self.options.enabledHttpsForInfo
	  // self.options.enabledHttpsForMessage
	  if (options.uploadUrl && options.downloadUrl) {
	    CONFIG.uploadUrl = options.uploadUrl;
	    CONFIG.downloadUrl = options.downloadUrl;
	  }
	  // 私有化通配符url
	  // 拿到一个 bucket  = nim  object = pic ，那么上传得到的地址是 http(s)://nos.netease.com/nim/pic，那么无论是本地还是传给对面，都是这个域名。
	  // 而只有正在在下载的时候才会做加速地址的处理，最后替换完的地址是不暴露给上层开发者知道的
	  CONFIG.replaceUrl = options.replaceUrl || 'http://nos.netease.im';
	  self.reset();
	  return self;
	};

	ApiBaseFn.reset = function () {
	  var self = this;
	  var options = self.options;
	  util.verifyBooleanWithDefault(options, 'exifOrientation', true);
	};

	ApiBaseFn.setOptions = function (newOptions) {
	  this.reset();
	  this.protocol.setOptions(newOptions);
	};

	// 还是不要 destroy 了, destroy 之后还是可以创建新的对象, 还是会有多个链接
	// ApiBaseFn.destroy = function() {
	//     var self = this
	//     self.disconnect()
	//     delete instances[self.name]
	// }

	/**
	 * 异步请求回调函数, 成功时error为null, 发生错误时error包含具体错误信息
	 *
	 * @private
	 * @callback done
	 *
	 * @param {Object} error            错误
	 * @param {Number} error.code       错误码
	 * @param {String} error.message    错误信息
	 * @param {Object} obj              操作失败时包含调用时传入的参数, 操作成功时可能会返回不一样的信息或者会追加一些信息
	 *
	 * @see {@link NIMError.codeMap|错误码错误信息表}
	 * @see {@link NIM}
	 */
	ApiBaseFn.processCallback = function (options, useOptionsAsObj) {
	  _completeOption(options, useOptionsAsObj);
	};

	/**
	 * 用于音视频的补充回调，返回一个promise
	 * @private
	 * @param {Object} options
	 * @param {any} useOptionsAsObj 我也不知道是什么
	 * @returns promise
	 */
	ApiBaseFn.processCallbackPromise = function (options, useOptionsAsObj) {
	  var promise = new Promise(function (resolve, reject) {
	    _completeOption(options, useOptionsAsObj, true, resolve, reject);
	  });
	  return promise;
	};
	/**
	 * 补全配置
	 * @private
	 * @param {Object} option
	 */
	var _completeOption = function _completeOption(options, useOptionsAsObj, usePromise, resolve, reject) {
	  util.verifyCallback(options, 'done');
	  options.callback = function (error, obj, content) {
	    var rawOptions = options.callback.options;
	    obj = obj || rawOptions;
	    if (useOptionsAsObj) {
	      obj = rawOptions;
	    }
	    // 某些协议需要额外特殊处理返回的数据
	    if (util.isFunction(options.cbaop)) {
	      var aopRtn = options.cbaop(error, obj);
	      if (notundef(aopRtn)) {
	        obj = aopRtn;
	      }
	    }
	    var done = options.done;
	    // 删除不需要传给用户的数据
	    if (util.isObject(obj)) {
	      delete obj.done;
	      delete obj.cb;
	      delete obj.callback;
	    }
	    if (usePromise) {
	      if (error) {
	        reject(error);
	      } else {
	        resolve(obj);
	      }
	    } else {
	      done(error, obj, content);
	    }
	  };
	  // 记录原始的options
	  options.callback.options = util.copy(options);
	  return;
	};

	ApiBaseFn.processPs = function (options) {
	  if (util.notexist(options.ps)) {
	    options.ps = '';
	  }
	};

	ApiBaseFn.processCustom = function (options) {
	  if (util.notexist(options.custom)) {
	    options.custom = '';
	  }
	};

	// sendCmd 的callback有三个参数，分别为error, package.obj, package.content
	// obj为发送参数带回来，content为resp参数
	ApiBaseFn.sendCmd = function () {
	  this.protocol.sendCmd.apply(this.protocol, arguments);
	};

	// sendCmdWithResp 的callback有两个参数，分别为error, package.content
	ApiBaseFn.sendCmdWithResp = function (cmd, obj, callback) {
	  this.sendCmd(cmd, obj, function (error, req, res) {
	    if (util.isFunction(callback)) {
	      if (error) {
	        callback(error, req);
	      } else {
	        callback(null, res);
	      }
	    }
	  });
	};

	ApiBaseFn.cbAndSendCmd = function (type, options) {
	  var promise = this.processCallbackPromise(options);
	  this.sendCmd(type, options);
	  return promise;
	};

	ApiBase.use = function (plugin, options) {
	  if (plugin && plugin.install && util.isFunction(plugin.install)) {
	    plugin.install(this, options);
	  }
	};

	module.exports = ApiBase;

	__webpack_require__(49);
	__webpack_require__(51);
	__webpack_require__(52);
	__webpack_require__(53);
	__webpack_require__(50);
	// require('./audio')

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var device = {};

	device.init = function () {
	  // var key = 'nim_web_sdk_deviceId';
	  // var deviceId = ls.get(key);
	  // if (!deviceId) {
	  //     deviceId = util.guid();
	  //     ls.set(key, deviceId)
	  // }
	  // device.deviceId = deviceId;
	  device.deviceId = util.guid();
	};

	device.init();

	// 客户端id对应表
	device.clientTypeMap = {
	  1: 'Android',
	  2: 'iOS',
	  4: 'PC',
	  8: 'WindowsPhone',
	  16: 'Web',
	  32: 'Server',
	  64: 'Mac'
	};

	module.exports = device;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var config = __webpack_require__(3);
	var NIMError = __webpack_require__(4);

	function Protocol(options) {
	  var self = this;
	  if (util.undef(options.secure)) {
	    options.secure = true;
	  }
	  self.options = util.copy(options);
	  self.init();
	  self.connect();
	}

	var ProtocolFn = Protocol.fn = Protocol.prototype;

	// 只有第一次初始化的时候才会被调用
	ProtocolFn.init = function () {
	  var self = this;
	  self.logger = self.options.logger;

	  // 存储所有的命令，会在发送一条命令之后再异步发送下一条命令
	  self.cmdTaskArray = [];
	  // 存储 cmd 对应的 timer, 收到 ack 之后会从此 map 中删除
	  self.timerMap = {};
	  // 存储 cmd 对应的 callback, 收到 ack 或 timeout 之后会从此 map 中删除
	  self.cmdCallbackMap = {};
	  // 存储 cmd 对应的 content, 收到 ack 或 timeout 之后会从此 map 中删除
	  self.cmdContentMap = {};

	  self.initConnect();

	  self.reset();
	};

	// 后续重复获取同一份实例会调用 setOptions, 最终会调用 reset
	// 所有跟 options 相关的参数都要能 reset
	ProtocolFn.reset = function () {
	  var self = this;
	  self.resetConnect();
	};

	ProtocolFn.setOptions = function (newOptions) {
	  var self = this;
	  var oldOptions = self.options;
	  var keys = Object.keys(oldOptions);
	  var index = keys.indexOf('account');
	  if (index !== -1) {
	    keys.splice(index, 1);
	  }
	  newOptions = util.filterObj(newOptions, keys);
	  self.options = util.merge(oldOptions, newOptions);

	  self.reset();
	};

	/**
	 * 发送消息到服务器
	 *
	 * @private
	 * @param  {Object} options 配置参数
	 * @property {String}   cmd       命令名称
	 * @property {Map}      content   命令内容
	 * @property {Function} callback  回调函数
	 * @return {Number}         cmd序列号
	 */
	ProtocolFn.sendCmd = function (cmd) {
	  var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	  var callback = arguments[2];

	  var self = this;
	  self.heartbeat();
	  if (cmd !== 'heartbeat') {
	    self.logger.log('Protocol Command    ' + cmd + '\t', content);
	  }

	  var cmdName = cmd;
	  cmd = self.parser.createCmd(cmd, content);
	  var ser = cmd.SER;
	  var keys;
	  // 如果没有content, 那么分配一个, 然后存储content
	  content = content || {};
	  self.cmdContentMap[ser] = content;
	  // 如果只有一个参数
	  if (content.single) {
	    delete content.single;
	    keys = Object.keys(content);
	    if (keys.length === 1) {
	      self.cmdContentMap[ser] = content[keys[0]];
	    }
	  }
	  // 删掉不存储的参数
	  if (content.NOTSTORE) {
	    keys = content.NOTSTORE.split(' ');
	    keys.forEach(function (key) {
	      delete content[key];
	    });
	    delete content.NOTSTORE;
	  }
	  // 存储 callback
	  callback = callback || content.callback;
	  if (callback) {
	    self.cmdCallbackMap[ser] = callback;
	  }
	  // 存储命令
	  // console.warn('9999999', JSON.stringify(cmd))
	  // iphone 6s/6sp push以后，cmd内会莫名奇妙补数据0:null,7:null...，需要序列号一下
	  self.cmdTaskArray.push({
	    cmdName: cmdName,
	    cmd: JSON.stringify(cmd)
	  });
	  // console.warn('0000000', JSON.stringify(cmd));
	  // 启动命令 timer
	  self.startCmdTaskTimer();
	};

	// 启动任务 timer，异步取出一个任务，执行之，然后再次启动任务 timer
	// 异步的目的是为了让出线程执行时间，这样就算外界循环调用，也不会阻塞线程的执行
	ProtocolFn.startCmdTaskTimer = function () {
	  var self = this;
	  if (!self.cmdTaskTimer) {
	    self.cmdTaskTimer = setTimeout(function () {
	      var cmdTask = self.cmdTaskArray.shift();
	      self.cmdTaskTimer = null;
	      if (cmdTask) {
	        self.executeCmdTask(cmdTask);
	      }
	      if (self.cmdTaskArray.length) {
	        self.startCmdTaskTimer();
	      }
	    }, 0);
	  }
	};

	// 执行任务
	ProtocolFn.executeCmdTask = function (cmdTask) {
	  var self = this;
	  var cmdName = cmdTask.cmdName;
	  var cmd = cmdTask.cmd;
	  // console.warn('33333333333', cmd)
	  cmd = JSON.parse(cmd);
	  var ser = cmd.SER;
	  if (self.isFrequencyControlled(cmdName)) {
	    self.logger.warn('hit frequency control ' + cmdName);
	    self.markCallbackInvalid(ser, NIMError.newFrequencyControlError());
	  } else if (!self.isConnected()) {
	    self.markCallbackInvalid(ser, NIMError.newSocketStateError());
	  } else {
	    self.doSendCmd(cmd);
	  }
	};

	// 检查是否被频控了
	// 重新登录的话，服务器的频控会重置
	ProtocolFn.isFrequencyControlled = function (cmdName) {
	  var config = this.frequencyControlMap && this.frequencyControlMap[cmdName];
	  if (config) {
	    if (Date.now() < config.from + config.duration) {
	      return true;
	    } else {
	      delete this.frequencyControlMap[cmdName];
	    }
	  }
	};

	// 调用 socket 发送命令
	ProtocolFn.doSendCmd = function (cmd) {
	  var self = this;
	  var ser = cmd.SER;
	  // 存储超时
	  self.timerMap[ser] = setTimeout(function () {
	    self.markCallbackInvalid(ser, NIMError.newTimeoutError());
	  }, config.cmdTimeout);
	  // 发送命令
	  try {
	    self.socket.send(JSON.stringify(cmd));
	  } catch (e) {
	    self.markCallbackInvalid(ser, NIMError.newSocketStateError());
	    self.onDisconnect(true);
	  }
	};

	// 获取 ser 对应的 obj
	ProtocolFn.getObjWithSer = function (ser) {
	  var self = this;
	  var obj = self.cmdContentMap[ser];
	  delete self.cmdContentMap[ser];
	  // 如果 obj 存在, 那么返回其拷贝; 如果不存在, 那么直接返回, 即返回 undefined
	  // 请参考 IMProtocolFn.packetFromSync
	  return obj && util.copy(obj);
	};

	// 获取 ser 对应的 callback
	ProtocolFn.getCallbackWithSer = function (ser) {
	  var self = this;
	  var callback = self.cmdCallbackMap[ser];
	  delete self.cmdCallbackMap[ser];
	  return callback;
	};

	// 获取 ser 对应的 timer
	ProtocolFn.getTimerWithSer = function (ser) {
	  var self = this;
	  var timer = self.timerMap[ser];
	  delete self.timerMap[ser];
	  return timer;
	};

	// 清除 ser 对应的 timer
	ProtocolFn.clearTimerWithSer = function (ser) {
	  var self = this;
	  var timer = self.getTimerWithSer(ser);
	  if (timer) {
	    clearTimeout(timer);
	  }
	};

	// 使 ser 对应的 callback 失效
	ProtocolFn.markCallbackInvalid = function (ser, error) {
	  var self = this;
	  // 删除 obj
	  self.getObjWithSer(ser);
	  // 清除 timer
	  self.clearTimerWithSer(ser);
	  var callback = self.getCallbackWithSer(ser);
	  if (callback) {
	    var content = callback.options;
	    // 异步回调
	    setTimeout(function () {
	      callback(error || NIMError.newUnknownError(), content);
	    }, 0);
	  }
	};

	/**
	 * 使所有回调失效
	 */
	ProtocolFn.markAllCallbackInvalid = function (error) {
	  var self = this;
	  Object.keys(this.cmdCallbackMap).forEach(function (ser) {
	    self.markCallbackInvalid(ser, error);
	  });
	};

	// 获取packet关联的content
	ProtocolFn.getPacketObj = function (packet) {
	  var result = null;
	  if (packet) {
	    if (packet.raw) {
	      var ser = packet.raw.ser;
	      if (util.notundef(ser)) {
	        result = this.getObjWithSer(ser);
	      }
	    }
	  }
	  return result;
	};

	// 调用回包确认回调函数
	ProtocolFn.callPacketAckCallback = function (packet) {
	  var self = this;
	  if (!!packet && !!packet.raw) {
	    var ser = packet.raw.ser;
	    if (util.notundef(ser)) {
	      self.clearTimerWithSer(ser);
	      var callback = self.getCallbackWithSer(ser);
	      if (callback) {
	        if (packet.promise) {
	          packet.promise.then(function () {
	            callback(packet.error, packet.obj);
	          }, function (event) {
	            var error = NIMError.newDBError();
	            error.event = event;
	            self.logger.error('promise error', error, event);
	            callback(error, packet.obj, packet.content);
	          });
	        } else {
	          // 第二个参数是自己发的再带回来，第三个参数为服务器发的
	          callback(packet.error, packet.obj, packet.content);
	        }
	      }
	    }
	  }
	};

	/**
	 * 接收到服务端的消息
	 *
	 * @private
	 * @param {String} data 包数据
	 * @return {Void}
	 */
	ProtocolFn.onMessage = function (data) {
	  var self = this;
	  self.heartbeat();
	  var packet = self.parser.parseResponse(data);
	  // 找不到协议
	  if (packet.notFound) {
	    self.logger.log('no config for', packet.notFound);
	  }

	  if (packet.error) {
	    packet.error.message = packet.cmd + ' error: ' + packet.error.message;
	    // self.logger.error('packet error', packet.error)
	  } else if (!packet.content && packet.sid !== 1 && packet.cid !== 2) {
	    // 1_2为心跳包
	    self.logger.warn('packet no content', packet.raw);
	  }
	  // 如果被频控，那么记录当前时间和频控时长
	  if (packet.frequencyControlDuration) {
	    self.logger.warn('server frequency control ' + packet.cmd);
	    self.frequencyControlMap = self.frequencyControlMap || {};
	    self.frequencyControlMap[packet.cmd] = {
	      from: +new Date(),
	      duration: packet.frequencyControlDuration
	    };
	  }
	  // 获取之前存储的对象, by CS
	  packet.obj = self.getPacketObj(packet);
	  if (packet.cmd !== 'heartbeat') {
	    self.logger.log('Protocol Response   ' + packet.cmd + '\t', packet, packet.error || (packet.content ? packet.content : ''));
	  }
	  var method = 'process' + util.capFirstLetter(packet.service);
	  // 如果没有找到对应的服务, 那么不作处理直接返回
	  if (self[method]) {
	    self[method](packet);
	  } else {
	    console.error('not find ' + method);
	  }
	  self.callPacketAckCallback(packet);
	};

	/*
	 * 各种各样的错误
	 * - 同步
	 * - 同步群成员
	 * - 心跳
	 */
	ProtocolFn.onMiscError = function (error, obj, message) {
	  if (error) {
	    error.appendMessage(message);
	    this.notifyError(error, obj);
	  }
	};

	// 只有当建立连接之后才通知错误, 断开连接之后不通知错误
	ProtocolFn.notifyError = function (error, obj) {
	  var self = this;
	  if (self.isConnected()) {
	    var args = ['onError ' + self.name, error];
	    if (error.event) {
	      args.push(error.event);
	    }
	    if (obj) {
	      args.push(obj);
	    }
	    self.logger.error.apply(self.logger.error, args);
	    self.options.onerror(error, obj);
	  }
	};

	ProtocolFn.emitAPI = function (_ref) {
	  var type = _ref.type,
	      obj = _ref.obj;

	  this.api.emit(type, obj);
	};

	module.exports = Protocol;

	__webpack_require__(59);
	__webpack_require__(58);
	__webpack_require__(60);
	__webpack_require__(61);

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 15 */,
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var util = __webpack_require__(1);
	var undef = util.undef;
	var notundef = util.notundef;
	var exist = util.exist;
	var loginPort = __webpack_require__(23);
	var BaseMessage = __webpack_require__(48);

	var ApnsAccountsAll = '#%@all@%#';

	/**
	 * 场景
	 *
	 * - `'p2p'` (单人聊天)
	 * - `'team'` (群聊)
	 *
	 * @memberOf IMMessage
	 * @name scene
	 * @readOnly
	 * @enum {String}
	 */
	var sceneMap = {
	  // 单人聊天
	  p2p: 0,
	  // 群聊
	  team: 1
	};
	var sceneReverseMap = {
	  0: 'p2p',
	  1: 'team'
	};
	var validScenes = Object.keys(sceneMap);

	/**
	 * 消息类型
	 *
	 * - `'text'` (文本)
	 * - `'image'` (图片)
	 * - `'audio'` (音频)
	 * - `'video'` (视频)
	 * - `'file'` (文件)
	 * - `'geo'` (地理位置)
	 * - `'custom'` (自定义消息)
	 * - `'tip'` (提醒消息)
	 * - `'robot'` (机器人消息)
	 *     - 提醒消息用于会话内的状态提醒，如进入会话时出现的欢迎消息，或者会话命中敏感词后的提示消息等等.
	 * - `'notification'` (群通知消息)
	 *     - 某些群操作后所有群成员会收到一条相应的群通知消息, 详细介绍请参考{@link IMMessage.attach.type|群通知消息的类型}
	 *     - 此类消息不会计入未读数
	 *
	 * @memberOf IMMessage
	 * @name type
	 * @readOnly
	 * @enum {String}
	 */
	var typeMap = BaseMessage.typeMap;
	var validTypes = BaseMessage.validTypes;

	/**
	 * IM 消息
	 *
	 * @constructor
	 * @name IMMessage
	 * @property {String}   scene           {@link IMMessage.scene|场景}
	 * @property {String}   from            消息发送方, 帐号
	 * @property {String}   fromNick        消息发送方的昵称
	 * @property {String}   fromClientType  发送方的{@link LoginPort.type|设备类型}
	 * @property {String}   fromDeviceId    发送端设备id
	 * @property {String}   to              消息接收方, 帐号或群id
	 * @property {Number}   time            时间戳
	 * @property {Number}   userUpdateTime  发送方信息更新时间
	 * @property {String}   type            {@link IMMessage.type|消息类型}
	 * @property {String}   sessionId       消息所属的{@link Session|会话}的ID
	 * @property {String}   target          聊天对象, 账号或者群id
	 * @property {String}   flow            消息的流向
	 * - 'in'表示此消息是收到的消息
	 * - 'out'表示此消息是发出的消息
	 * @property {String}   status          消息发送状态
	 * - `'sending'` 发送中
	 * - `'success'` 发送成功
	 * - `'fail'` 发送失败
	 * @property {String}   [text]          文本消息的文本内容, 请参考{@link NIM#sendText|发送文本消息}
	 * @property {Object}   [file]          文件消息的文件对象, 具体字段请参考{@link Image|图片对象}、{@link Audio|音频对象}、{@link Video|视频对象}和{@link File|文件对象}, 请参考{@link NIM#sendFile|发送文件消息}
	 * @property {Object}   [geo]           地理位置消息的{@link Geo|地理位置对象}, 请参考{@link NIM#sendGeo|发送地理位置消息}
	 * @property {String} [tip] 提醒消息的内容, 请参考{@link NIM#sendTipMsg|发送提醒消息}
	 * @property {String}   [content]       自定义消息的消息内容, 开发者可以自行扩展, 建议封装成JSON格式字符串, 请参考{@link NIM#sendCustomMsg|发送自定义消息}
	 * @property {Object}   [attach]        {@link IMMessage.type|群通知消息}的附加信息,
	 *                                      参考{@link IMMessage.attach.type|群通知消息的类型}来查看不同类型的群通知消息对应的附加信息
	 * @property {String}   idClient        SDK生成的消息id, 在发送消息之后会返回给开发者, 开发者可以在发送消息的结果回调里面根据这个ID来判断相应消息的发送状态, 到底是发送成功了还是发送失败了, 然后根据此状态来更新页面的UI。如果发送失败, 那么可以重新发送此消息
	 * @property {String}   [idServer]      服务器用于区分消息用的ID, 用于{@link NIM#getHistoryMsgs|获取历史消息}和{@link NIM#searchHistoryMsgs|获取包含关键词的历史消息}, 此字段可能没有, 所以开发者应该使用`idClient`来唯一标识消息
	 * @property {Boolean}  isMuted         该消息在接收方是否应该被静音
	 * @property {Boolean}  resend          是否是重发的消息
	 * @property {String}   [custom]        扩展字段
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @property {String}   [pushContent]   自定义推送文案
	 * @property {String}   [pushPayload]   自定义的推送属性
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @property {Object}   [apns]          特殊推送选项, 只在群会话中使用
	 * @property {String[]} [apns.accounts] 需要特殊推送的账号列表, 此字段不存在的话表示推送给当前会话内的所有用户
	 * @property {String}   [apns.content]  需要特殊推送的文案
	 * @property {String}   [apns.forcePush] 是否强制推送, true 表示即使推送列表中的用户屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
	 * @property {String}   [localCustom]   本地自定义扩展字段
	 * - 在{@link support.db|支持数据库}时可以调用{@Link NIM#updateLocalMsg|更新本地消息}来更新此字段, 此字段只会被更新到本地数据库, 不会被更新到服务器上
	 * @property {Boolean}  isHistoryable   是否存储云端历史
	 * @property {Boolean}  isRoamingable   是否支持漫游
	 * @property {Boolean}  isSyncable      是否支持发送者多端同步
	 * @property {Boolean}  cc              是否支持抄送
	 * @property {Boolean}  isPushable      是否需要推送
	 * @property {Boolean}  isOfflinable    是否要存离线
	 * @property {Boolean}  isUnreadable    是否计入消息未读数
	 * @property {Boolean}  needPushNick    是否需要推送昵称
	 * @property {Boolean}  isLocal         是否是本地消息, 请查阅{@link NIM#sendText|发送文本消息}
	 */
	function Message(options) {
	  util.verifyOptions(options, 'scene to type');
	  util.verifyParamValid('scene', options.scene, validScenes);
	  var self = this;
	  self.scene = sceneMap[options.scene];
	  self.to = '' + options.to;
	  self.type = typeMap[options.type];
	  self.resend = options.resend ? 1 : 0;
	  // 如果不是重发, 那么生成idClient；如果是重发, 那么由开发者传入idClient
	  if (!options.resend) {
	    self.idClient = util.guid();
	  } else {
	    util.verifyOptions(options, 'idClient');
	    self.idClient = options.idClient;
	  }
	  // 文本字段
	  if (notundef(options.text)) {
	    self.body = '' + options.text;
	  }
	  if (notundef(options.custom)) {
	    self.custom = '' + options.custom;
	  }
	  if (notundef(options.body)) {
	    self.body = '' + options.body;
	  }
	  if (notundef(options.pushContent)) {
	    self.pushContent = '' + options.pushContent;
	  }
	  if (notundef(options.pushPayload)) {
	    self.pushPayload = '' + options.pushPayload;
	  }
	  // 特殊推送选项
	  var apns = options.apns;
	  if (notundef(apns) && options.scene === 'team') {
	    // 需要特殊推送的账号列表
	    var apnsAccounts = apns.accounts;
	    if (notundef(apnsAccounts)) {
	      util.verifyParamType('apns.accounts', apnsAccounts, 'array');
	    }
	    self.apnsAccounts = apnsAccounts ? JSON.stringify(apnsAccounts) : ApnsAccountsAll;
	    // 需要特殊推送的文案
	    self.apnsContent = apns.content || options.pushContent || '';
	    // 是否强制推送
	    util.verifyBooleanWithDefault(apns, 'forcePush', true, 'options.apns');
	    self.apnsForcePush = apns.forcePush ? 1 : 0;
	  }
	  // 开关
	  if (notundef(options.isHistoryable)) {
	    self.isHistoryable = options.isHistoryable ? 1 : 0;
	  }
	  if (notundef(options.isRoamingable)) {
	    self.isRoamingable = options.isRoamingable ? 1 : 0;
	  }
	  if (notundef(options.isSyncable)) {
	    self.isSyncable = options.isSyncable ? 1 : 0;
	  }
	  if (notundef(options.cc)) {
	    self.cc = options.cc ? 1 : 0;
	  }
	  if (notundef(options.isPushable)) {
	    self.isPushable = options.isPushable ? 1 : 0;
	  }
	  if (notundef(options.isOfflinable)) {
	    self.isOfflinable = options.isOfflinable ? 1 : 0;
	  }
	  if (notundef(options.isUnreadable)) {
	    self.isUnreadable = options.isUnreadable ? 1 : 0;
	  }
	  if (notundef(options.needPushNick)) {
	    self.needPushNick = options.needPushNick ? 1 : 0;
	  }
	  if (notundef(options.yidunEnable)) {
	    self.yidunEnable = options.yidunEnable ? 1 : 0;
	  }
	  if (notundef(options.antiSpamContent)) {
	    if (_typeof(options.antiSpamContent) === 'object') {
	      self.logger.warn('antiSpamContent should be json string, auto transfer object');
	      self.antiSpamContent = JSON.stringify(options.antiSpamContent);
	    } else {
	      self.antiSpamContent = '' + options.antiSpamContent;
	    }
	  }
	}

	Message.prototype.getScene = function () {
	  return sceneReverseMap[this.scene];
	};

	Message.getScene = function (msg) {
	  var scene = msg.scene;
	  return sceneReverseMap[scene] || scene;
	};

	Message.getType = BaseMessage.getType;

	Message.reverse = function (msg) {
	  var scene = sceneReverseMap[msg.scene];
	  var obj = {
	    scene: scene || msg.scene,
	    from: msg.from,
	    fromNick: msg.fromNick,
	    fromClientType: loginPort.reverseType(msg.fromClientType),
	    fromDeviceId: msg.fromDeviceId,
	    // to 为第三方账号或者群ID, 强制转为字符串
	    to: '' + msg.to,
	    time: +msg.time,
	    type: Message.getType(msg),
	    // 文本字段
	    text: exist(msg.body) ? msg.body : '',
	    isHistoryable: undef(msg.isHistoryable) || +msg.isHistoryable === 1,
	    isRoamingable: undef(msg.isRoamingable) || +msg.isRoamingable === 1,
	    isSyncable: undef(msg.isSyncable) || +msg.isSyncable === 1,
	    cc: undef(msg.cc) || +msg.cc === 1,
	    isPushable: undef(msg.isPushable) || +msg.isPushable === 1,
	    isOfflinable: undef(msg.isOfflinable) || +msg.isOfflinable === 1,
	    isUnreadable: undef(msg.isUnreadable) || +msg.isUnreadable === 1,
	    needPushNick: undef(msg.needPushNick) || +msg.needPushNick === 1,
	    isLocal: false
	  };

	  // 只有消息接收者才用处理字段 isMuted
	  if (notundef(msg.isMuted)) {
	    obj.isMuted = +msg.isMuted === 1;
	  }
	  if (notundef(msg.resend)) {
	    obj.resend = +msg.resend === 1;
	  }
	  if (notundef(msg.idClient)) {
	    obj.idClient = msg.idClient;
	  }
	  // 漫游消息和离线消息没有 idServer
	  if (notundef(msg.idServer)) {
	    obj.idServer = '' + msg.idServer;
	  }
	  if (notundef(msg.userUpdateTime)) {
	    obj.userUpdateTime = +msg.userUpdateTime;
	  }
	  if (notundef(msg.custom)) {
	    obj.custom = msg.custom;
	  }
	  if (notundef(msg.pushContent)) {
	    obj.pushContent = msg.pushContent;
	  }
	  if (notundef(msg.pushPayload)) {
	    obj.pushPayload = msg.pushPayload;
	  }
	  // 特殊推送选项
	  if (notundef(msg.apnsAccounts)) {
	    obj.apns = {};
	    if (msg.apnsAccounts !== ApnsAccountsAll) {
	      var accounts = msg.apnsAccounts;
	      try {
	        obj.apns.accounts = JSON.parse(accounts);
	      } catch (error) {
	        obj.apns.accounts = [];
	      }
	    }
	    obj.apns.content = msg.apnsContent || '';
	    obj.apns.forcePush = +msg.apnsForcePush === 1;
	  }

	  // SDK 自己加的属性
	  obj.status = msg.status || 'success';
	  if (notundef(msg.filter)) {
	    obj.filter = msg.filter;
	  }
	  return obj;
	};

	Message.setExtra = function (obj, account) {
	  obj.target = Message.getMsgTarget(obj, account);
	  obj.sessionId = obj.scene + '-' + obj.target;
	  BaseMessage.setFlow(obj, account);
	};

	// 获取聊天对象
	Message.getMsgTarget = function (msg, account) {
	  if (msg.scene === 'p2p') {
	    return msg.to === account ? msg.from : msg.to;
	  } else if (msg.scene === 'team') {
	    return msg.to;
	  }
	};

	// 根据 idClient 去重
	Message.deduplication = function (msgs) {
	  var set = {};
	  var array = [];
	  var idClient;
	  msgs.forEach(function (msg) {
	    idClient = msg.idClient;
	    if (!set[idClient]) {
	      set[idClient] = true;
	      array.push(msg);
	    }
	  });
	  return array;
	};

	// 按照时间正序排序, 但是不改变原数组, 并且返回新数组
	Message.sortMsgs = function (msgs) {
	  msgs = msgs.slice(0);
	  util.sortObjArray(msgs, {
	    sortPath: 'time'
	  });
	  return msgs;
	};

	/**
	 * 获取数组中的最后一条消息（时间戳最大的）
	 * @private
	 * @param  {Object[]} msgs  消息数组
	 * @return {Object}         最后一条消息
	 */
	Message.getLastMsg = function (msgs) {
	  msgs = Message.sortMsgs(msgs);
	  return msgs[msgs.length - 1];
	};

	Message.getLastNotIgnoredMsg = function (msgs) {
	  msgs = Message.sortMsgs(msgs);
	  var msg = null;
	  for (var i = msgs.length - 1; i >= 0; i--) {
	    msg = msgs[i];
	    if (!msg.ignore) {
	      return msg;
	    }
	  }
	  return null;
	};

	Message.getMaxTimetag = function (msgs) {
	  return Message.getLastMsg(msgs).time;
	};

	Message.validScenes = validScenes;
	Message.validTypes = validTypes;

	module.exports = Message;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["ZoroBase"] = factory();
		else
			root["ZoroBase"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		exports.__esModule = true;
		
		var _blob = __webpack_require__(1);
		
		var blob = _interopRequireWildcard(_blob);
		
		var _css = __webpack_require__(3);
		
		var css = _interopRequireWildcard(_css);
		
		var _const = __webpack_require__(4);
		
		var consts = _interopRequireWildcard(_const);
		
		var _date = __webpack_require__(5);
		
		var date = _interopRequireWildcard(_date);
		
		var _dom = __webpack_require__(6);
		
		var dom = _interopRequireWildcard(_dom);
		
		var _forOwn = __webpack_require__(8);
		
		var _forOwn2 = _interopRequireDefault(_forOwn);
		
		var _getGlobal = __webpack_require__(2);
		
		var _getGlobal2 = _interopRequireDefault(_getGlobal);
		
		var _id = __webpack_require__(9);
		
		var id = _interopRequireWildcard(_id);
		
		var _json = __webpack_require__(10);
		
		var json = _interopRequireWildcard(_json);
		
		var _mixin = __webpack_require__(11);
		
		var _mixin2 = _interopRequireDefault(_mixin);
		
		var _object = __webpack_require__(12);
		
		var object = _interopRequireWildcard(_object);
		
		var _type = __webpack_require__(7);
		
		var type = _interopRequireWildcard(_type);
		
		var _url = __webpack_require__(13);
		
		var url = _interopRequireWildcard(_url);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
		
		var obj = object.merge({}, blob, css, consts, date, dom, {
		  forOwn: _forOwn2['default'],
		  getGlobal: _getGlobal2['default']
		}, id, json, {
		  mixin: _mixin2['default']
		}, object, type, url);
		
		// TODO obj.__esModule ???
		/**
		* @Author: Yingya Zhang <zyy>
		* @Date:   2016-06-23 13:45:00
		* @Email:  zyy7259@gmail.com
		* @Last modified by:   zyy
		* @Last modified time: 2016-07-13T12:13:51+08:00
		*/
		
		delete obj.__esModule;
		
		exports['default'] = obj;
		module.exports = exports['default'];

	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		exports.__esModule = true;
		exports.blobFromDataURL = blobFromDataURL;
		exports.blobFromCanvas = blobFromCanvas;
		
		var _getGlobal = __webpack_require__(2);
		
		var _getGlobal2 = _interopRequireDefault(_getGlobal);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		function blobFromDataURL(dataURL) {
		  var window = (0, _getGlobal2['default'])();
		  // convert base64/URLEncoded data component to raw binary data held in a string
		  var byteString = void 0;
		  if (dataURL.split(',')[0].indexOf('base64') >= 0) {
		    byteString = window.atob(dataURL.split(',')[1]);
		  } else {
		    byteString = window.decodeURIComponent(dataURL.split(',')[1]);
		  }
		
		  // separate out the mime component
		  var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
		
		  // write the bytes of the string to a typed array
		  var ia = new Uint8Array(byteString.length);
		  for (var i = 0; i < byteString.length; i++) {
		    ia[i] = byteString.charCodeAt(i);
		  }
		
		  return new window.Blob([ia], { type: mimeString });
		} /**
		  * @Author: Yingya Zhang <zyy>
		  * @Date:   2016-07-08 11:29:00
		  * @Email:  zyy7259@gmail.com
		  * @Last modified by:   zyy
		  * @Last modified time: 2016-07-10 12:42:13
		  */
		
		function blobFromCanvas(canvas, cb) {
		  var mimeType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'image/jpeg';
		  var quality = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
		
		  if (canvas.toBlob) {
		    canvas.toBlob(cb, mimeType, quality);
		  } else {
		    var dataURL = canvas.toDataURL(mimeType, quality);
		    cb(blobFromDataURL(dataURL));
		  }
		}

	/***/ },
	/* 2 */
	/***/ function(module, exports) {

		/* WEBPACK VAR INJECTION */(function(global) {'use strict';
		
		exports.__esModule = true;
		
		exports['default'] = function () {
		  if (typeof window !== 'undefined') {
		    return window;
		  }
		  if (typeof self !== 'undefined') {
		    return self;
		  }
		  if (typeof global !== 'undefined') {
		    return global;
		  }
		  return {};
		};
		
		module.exports = exports['default'];
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

	/***/ },
	/* 3 */
	/***/ function(module, exports) {

		'use strict';
		
		exports.__esModule = true;
		exports.detectCSSFeature = detectCSSFeature;
		/*
		* @Author: Zhang Yingya(hzzhangyingya)
		* @Date:   2016-03-30 16:52:45
		* @Last modified by:   zyy
		* @Last modified time: 2016-07-10 12:57:03
		*/
		
		function detectCSSFeature(featurename) {
		  var feature = false;
		  var domPrefixes = 'Webkit Moz ms O'.split(' ');
		  var elm = document.createElement('div');
		  var featurenameCapital = null;
		
		  featurename = featurename.toLowerCase();
		
		  if (elm.style[featurename] !== undefined) {
		    feature = true;
		  }
		
		  if (feature === false) {
		    featurenameCapital = featurename.charAt(0).toUpperCase() + featurename.substr(1);
		    for (var i = 0; i < domPrefixes.length; i++) {
		      if (elm.style[domPrefixes[i] + featurenameCapital] !== undefined) {
		        feature = true;
		        break;
		      }
		    }
		  }
		  return feature;
		}

	/***/ },
	/* 4 */
	/***/ function(module, exports) {

		"use strict";
		
		exports.__esModule = true;
		/**
		* @Author: Yingya Zhang <zyy>
		* @Date:   2016-07-10 12:47:00
		* @Email:  zyy7259@gmail.com
		* @Last modified by:   zyy
		* @Last modified time: 2016-07-10 12:48:49
		*/
		
		var o = exports.o = {};
		var emptyObj = exports.emptyObj = {};
		
		var f = exports.f = function f() {};
		var emptyFunc = exports.emptyFunc = function emptyFunc() {};
		
		var regBlank = exports.regBlank = /\s+/ig;
		var regWhiteSpace = exports.regWhiteSpace = /\s+/ig;

	/***/ },
	/* 5 */
	/***/ function(module, exports) {

		'use strict';
		
		exports.__esModule = true;
		exports.fix = fix;
		exports.getYearStr = getYearStr;
		exports.getMonthStr = getMonthStr;
		exports.getDayStr = getDayStr;
		exports.getHourStr = getHourStr;
		exports.getMinuteStr = getMinuteStr;
		exports.getSecondStr = getSecondStr;
		exports.getMillisecondStr = getMillisecondStr;
		exports.dateFromDateTimeLocal = dateFromDateTimeLocal;
		/**
		* @Author: Yingya Zhang <zyy>
		* @Date:   2016-06-23 13:40:00
		* @Email:  zyy7259@gmail.com
		* @Last modified by:   zyy
		* @Last modified time: 2016-07-10 13:03:62
		*/
		
		function fix(number, count) {
		  count = count || 2;
		  var str = '' + number;
		  while (str.length < count) {
		    str = '0' + str;
		  }
		  return str;
		}
		
		function getYearStr(date) {
		  return '' + date.getFullYear();
		}
		
		function getMonthStr(date) {
		  return fix(date.getMonth() + 1);
		}
		
		function getDayStr(date) {
		  return fix(date.getDate());
		}
		
		function getHourStr(date) {
		  return fix(date.getHours());
		}
		
		function getMinuteStr(date) {
		  return fix(date.getMinutes());
		}
		
		function getSecondStr(date) {
		  return fix(date.getSeconds());
		}
		
		function getMillisecondStr(date) {
		  return fix(date.getMilliseconds(), 3);
		}
		
		var format = exports.format = function () {
		  var reg = /yyyy|MM|dd|hh|mm|ss|SSS/g;
		  var mappers = {
		    yyyy: getYearStr,
		    MM: getMonthStr,
		    dd: getDayStr,
		    hh: getHourStr,
		    mm: getMinuteStr,
		    ss: getSecondStr,
		    SSS: getMillisecondStr
		  };
		  return function (date, format) {
		    date = new Date(date);
		    if (isNaN(+date)) {
		      return 'invalid date';
		    }
		    format = format || 'yyyy-MM-dd';
		    return format.replace(reg, function (match) {
		      return mappers[match](date);
		    });
		  };
		}();
		
		function dateFromDateTimeLocal(str) {
		  str = '' + str;
		  return new Date(str.replace(/-/g, '/').replace('T', ' '));
		}

	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		exports.__esModule = true;
		exports.off = exports.removeEventListener = exports.on = exports.addEventListener = undefined;
		exports.containsNode = containsNode;
		exports.calcHeight = calcHeight;
		exports.remove = remove;
		exports.dataset = dataset;
		exports.target = target;
		exports.createIframe = createIframe;
		exports.html2node = html2node;
		exports.scrollTop = scrollTop;
		
		var _type = __webpack_require__(7);
		
		function containsNode(parent, child) {
		  if (parent === child) {
		    return true;
		  }
		  while (child.parentNode) {
		    if (child.parentNode === parent) {
		      return true;
		    }
		    child = child.parentNode;
		  }
		  return false;
		} /**
		  * @Author: Yingya Zhang <zyy>
		  * @Date:   2016-07-08 11:29:00
		  * @Email:  zyy7259@gmail.com
		  * @Last modified by:   zyy
		  * @Last modified time: 2016-07-12T16:49:46+08:00
		  */
		
		function calcHeight(node) {
		  var parent = node.parentNode || document.body;
		  node = node.cloneNode(true);
		  node.style.display = 'block';
		  node.style.opacity = 0;
		  node.style.height = 'auto';
		  parent.appendChild(node);
		  var height = node.offsetHeight;
		  parent.removeChild(node);
		  return height;
		}
		
		function remove(node) {
		  if (node.parentNode) {
		    node.parentNode.removeChild(node);
		  }
		}
		
		function dataset(node, key, value) {
		  if ((0, _type.exist)(value)) {
		    node.setAttribute('data-' + key, value);
		  } else {
		    return node.getAttribute('data-' + key);
		  }
		}
		
		var addEventListener = exports.addEventListener = function addEventListener(node, type, callback) {
		  if (node.addEventListener) {
		    node.addEventListener(type, callback, false);
		  } else if (node.attachEvent) {
		    node.attachEvent('on' + type, callback);
		  }
		};
		var on = exports.on = addEventListener;
		
		var removeEventListener = exports.removeEventListener = function removeEventListener(node, type, callback) {
		  if (node.removeEventListener) {
		    node.removeEventListener(type, callback, false);
		  } else if (node.detachEvent) {
		    node.detachEvent('on' + type, callback);
		  }
		};
		var off = exports.off = removeEventListener;
		
		function target(event) {
		  return event.target || event.srcElement;
		}
		
		function createIframe(options) {
		  options = options || {};
		  var iframe;
		  if (options.name) {
		    try {
		      iframe = document.createElement('<iframe name="' + options.name + '"></iframe>');
		      iframe.frameBorder = 0;
		    } catch (error) {
		      iframe = document.createElement('iframe');
		      iframe.name = options.name;
		    }
		  } else {
		    iframe = document.createElement('iframe');
		  }
		  if (!options.visible) {
		    iframe.style.display = 'none';
		  }
		  // on load
		  function onIframeLoad(event) {
		    if (!iframe.src) {
		      return;
		    }
		    if (!options.multi) {
		      off(iframe, 'load', onIframeLoad);
		    }
		    options.onload(event);
		  }
		  if ((0, _type.isFunction)(options.onload)) {
		    on(iframe, 'load', onIframeLoad);
		  }
		  // will trigger onload
		  var parent = options.parent;
		  (parent || document.body).appendChild(iframe);
		  // ensure trigger onload async
		  var src = options.src || 'about:blank';
		  setTimeout(function () {
		    iframe.src = src;
		  }, 0);
		  return iframe;
		}
		
		function html2node(html) {
		  var div = document.createElement('div');
		  div.innerHTML = html;
		  var children = [];
		  var i = void 0;
		  var l = void 0;
		  if (div.children) {
		    for (i = 0, l = div.children.length; i < l; i++) {
		      children.push(div.children[i]);
		    }
		  } else {
		    for (i = 0, l = div.childNodes.length; i < l; i++) {
		      var child = div.childNodes[i];
		      if (child.nodeType === 1) {
		        children.push(child);
		      }
		    }
		  }
		  return children.length > 1 ? div : children[0];
		}
		
		function scrollTop(top) {
		  if ((0, _type.exist)(top)) {
		    document.documentElement.scrollTop = document.body.scrollTop = top;
		  }
		  return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
		}

	/***/ },
	/* 7 */
	/***/ function(module, exports) {

		'use strict';
		
		exports.__esModule = true;
		exports.getClass = getClass;
		exports.typeOf = typeOf;
		exports.isString = isString;
		exports.isNumber = isNumber;
		exports.isBoolean = isBoolean;
		exports.isArray = isArray;
		exports.isFunction = isFunction;
		exports.isDate = isDate;
		exports.isRegExp = isRegExp;
		exports.isError = isError;
		exports.isnull = isnull;
		exports.notnull = notnull;
		exports.undef = undef;
		exports.notundef = notundef;
		exports.exist = exist;
		exports.notexist = notexist;
		exports.isObject = isObject;
		exports.isEmpty = isEmpty;
		/**
		* @Author: Yingya Zhang <zyy>
		* @Date:   2016-06-30 09:54:00
		* @Email:  zyy7259@gmail.com
		* @Last modified by:   zyy
		* @Last modified time: 2016-07-10 12:33:38
		*/
		
		/*
		 * 类型相关 API
		 */
		
		function getClass(obj) {
		  return Object.prototype.toString.call(obj).slice(8, -1);
		}
		
		function typeOf(obj) {
		  return getClass(obj).toLowerCase();
		}
		
		function isString(obj) {
		  return typeOf(obj) === 'string';
		}
		
		function isNumber(obj) {
		  return typeOf(obj) === 'number';
		}
		
		function isBoolean(obj) {
		  return typeOf(obj) === 'boolean';
		}
		
		function isArray(obj) {
		  return typeOf(obj) === 'array';
		}
		
		function isFunction(obj) {
		  return typeOf(obj) === 'function';
		}
		
		function isDate(obj) {
		  return typeOf(obj) === 'date';
		}
		
		function isRegExp(obj) {
		  return typeOf(obj) === 'regexp';
		}
		
		function isError(obj) {
		  return typeOf(obj) === 'error';
		}
		
		function isnull(obj) {
		  return obj === null;
		}
		
		function notnull(obj) {
		  return obj !== null;
		}
		
		// 需要用 typeof 来比较，兼容性好
		function undef(obj) {
		  return typeof obj === 'undefined';
		}
		
		function notundef(obj) {
		  return typeof obj !== 'undefined';
		}
		
		function exist(obj) {
		  return notundef(obj) && notnull(obj);
		}
		
		function notexist(obj) {
		  return undef(obj) || isnull(obj);
		}
		
		function isObject(obj) {
		  return exist(obj) && typeOf(obj) === 'object';
		}
		
		/**
		 * 是否是空值
		 * @param  {Object}  obj 待检查的对象
		 * @return {Boolean}     如果是 null/undefined/''/[] 返回 true
		 */
		function isEmpty(obj) {
		  return notexist(obj) || (isString(obj) || isArray(obj)) && obj.length === 0;
		}

	/***/ },
	/* 8 */
	/***/ function(module, exports) {

		"use strict";
		
		exports.__esModule = true;
		
		exports["default"] = function () {
		  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
		  var that = arguments[2];
		
		  for (var key in obj) {
		    if (obj.hasOwnProperty(key)) {
		      callback.call(that, key, obj[key]);
		    }
		  }
		};
		
		module.exports = exports["default"]; /**
		                                     * @Author: Yingya Zhang <zyy>
		                                     * @Date:   2016-07-10 11:22:00
		                                     * @Email:  zyy7259@gmail.com
		                                     * @Last modified by:   zyy
		                                     * @Last modified time: 2016-07-10 11:25:33
		                                     */

	/***/ },
	/* 9 */
	/***/ function(module, exports) {

		'use strict';
		
		exports.__esModule = true;
		/**
		* @Author: Yingya Zhang <zyy>
		* @Date:   2016-07-08 11:29:00
		* @Email:  zyy7259@gmail.com
		* @Last modified by:   zyy
		* @Last modified time: 2016-07-10 12:35:03
		*/
		
		var uniqueID = exports.uniqueID = function () {
		  var id = 0;
		  return function () {
		    return '' + id++;
		  };
		}();

	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		exports.__esModule = true;
		exports.isJSON = isJSON;
		exports.parseJSON = parseJSON;
		
		var _forOwn = __webpack_require__(8);
		
		var _forOwn2 = _interopRequireDefault(_forOwn);
		
		var _type = __webpack_require__(7);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		function isJSON(str) {
		  return (0, _type.isString)(str) && str.indexOf('{') === 0 && str.lastIndexOf('}') === str.length - 1;
		}
		
		function parseJSON(obj) {
		  try {
		    if (isJSON(obj)) {
		      obj = JSON.parse(obj);
		    }
		    if ((0, _type.isObject)(obj)) {
		      (0, _forOwn2['default'])(obj, function (key, value) {
		        switch ((0, _type.typeOf)(value)) {
		          case 'string':
		          case 'object':
		            obj[key] = parseJSON(value);
		            break;
		        }
		      });
		    }
		  } catch (error) {
		    console.error(error);
		  }
		  return obj;
		}

	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		exports.__esModule = true;
		
		var _forOwn = __webpack_require__(8);
		
		var _forOwn2 = _interopRequireDefault(_forOwn);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		exports['default'] = function (target, source) {
		  (0, _forOwn2['default'])(source, function (key, value) {
		    target[key] = value;
		  });
		}; /**
		   * @Author: Yingya Zhang <zyy>
		   * @Date:   2016-07-08 11:29:00
		   * @Email:  zyy7259@gmail.com
		   * @Last modified by:   zyy
		   * @Last modified time: 2016-07-10 11:27:24
		   */

		module.exports = exports['default'];

	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		exports.__esModule = true;
		exports.simpleClone = simpleClone;
		exports.merge = merge;
		exports.fillUndef = fillUndef;
		exports.checkWithDefault = checkWithDefault;
		exports.fetch = fetch;
		exports.string2object = string2object;
		exports.object2string = object2string;
		
		var _mixin = __webpack_require__(11);
		
		var _mixin2 = _interopRequireDefault(_mixin);
		
		var _forOwn = __webpack_require__(8);
		
		var _forOwn2 = _interopRequireDefault(_forOwn);
		
		var _type = __webpack_require__(7);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		function simpleClone(obj) {
		  return JSON.parse(JSON.stringify(obj));
		}
		
		/**
		 * mock Object.assign
		 * - 将 sources 的 enumerable own properties 拷贝到 target
		 * @param  {Object} target={}  目标对象
		 * @param  {Object} ...sources 待拷贝的对象
		 * @return {Object}            目标对象
		 */
		/**
		* @Author: Yingya Zhang <zyy>
		* @Date:   2016-01-07 22:16:00
		* @Email:  zyy7259@gmail.com
		* @Last modified by:   zyy
		* @Last modified time: 2016-08-04T12:05:07+08:00
		*/
		
		function merge() {
		  var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		
		  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		    sources[_key - 1] = arguments[_key];
		  }
		
		  sources.forEach(function (source) {
		    (0, _mixin2['default'])(target, source);
		  });
		  return target;
		}
		
		/**
		 * 对于 source 的 enumerable own properties, 如果 target 没有此属性, 将 source 的值赋给 target
		 * @param  {Object} target 目标对象
		 * @param  {Object} source 源对象
		 * @return {Object}        目标对象
		 */
		function fillUndef(target, source) {
		  (0, _forOwn2['default'])(source, function (key, value) {
		    if ((0, _type.undef)(target[key])) {
		      target[key] = value;
		    }
		  });
		  return target;
		}
		
		/**
		 * 如果 target 没有 key 对应的属性, 那么将 value 赋给他
		 * @param  {Object} target 目标对象
		 * @param  {String} key    属性名
		 * @param  {Object} value  属性值
		 * @return {Object}        属性值
		 */
		function checkWithDefault(target, key, value) {
		  var v = target[key] || target[key.toLowerCase()];
		  if ((0, _type.notexist)(v)) {
		    v = value;
		    target[key] = v;
		  }
		  return v;
		}
		
		/**
		 * 对于 target 的 enumerable own properties, 如果 source 存在对应的值, 将其赋给 target
		 * @param  {Object} target 目标对象
		 * @param  {Object} source 源对象
		 * @return {Object}        目标对象
		 */
		function fetch(target, source) {
		  (0, _forOwn2['default'])(target, function (key, value) {
		    if ((0, _type.exist)(source[key])) {
		      target[key] = source[key];
		    }
		  });
		  return target;
		}
		
		function string2object() {
		  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
		  var sep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';
		
		  var obj = {};
		  string.split(sep).forEach(function (pair) {
		    var arr = pair.split('=');
		    var key = arr.shift();
		    if (!key) {
		      return;
		    }
		    obj[decodeURIComponent(key)] = decodeURIComponent(arr.join('='));
		  });
		  return obj;
		}
		
		function object2string(obj, sep, encode) {
		  if (!obj) {
		    return '';
		  }
		  var arr = [];
		  (0, _forOwn2['default'])(obj, function (key, value) {
		    if ((0, _type.isFunction)(value)) {
		      return;
		    }
		    if ((0, _type.isDate)(value)) {
		      value = value.getTime();
		    } else if ((0, _type.isArray)(value)) {
		      value = value.join(',');
		    } else if ((0, _type.isObject)(value)) {
		      value = JSON.stringify(value);
		    }
		    if (encode) {
		      value = encodeURIComponent(value);
		    }
		    arr.push(encodeURIComponent(key) + '=' + value);
		  });
		  return arr.join(sep || ',');
		}

	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		exports.__esModule = true;
		exports.url2origin = undefined;
		exports.genUrlSep = genUrlSep;
		exports.object2query = object2query;
		
		var _object = __webpack_require__(12);
		
		function genUrlSep(url) {
		  return url.indexOf('?') < 0 ? '?' : '&';
		} /**
		  * @Author: Yingya Zhang <zyy>
		  * @Date:   2016-07-08 11:29:00
		  * @Email:  zyy7259@gmail.com
		  * @Last modified by:   zyy
		  * @Last modified time: 2016-07-10 12:41:71
		  */
		
		function object2query(obj) {
		  return (0, _object.object2string)(obj, '&', true);
		}
		
		var url2origin = exports.url2origin = function () {
		  var reg = /^([\w]+?:\/\/.*?(?=\/|$))/i;
		  return function (url) {
		    if (reg.test(url || '')) {
		      return RegExp.$1.toLowerCase();
		    }
		    return '';
		  };
		}();

	/***/ }
	/******/ ])
	});
	;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var undef = util.undef;
	var NIMError = __webpack_require__(4);

	var configMapIM = __webpack_require__(43);
	var serializeMapIM = __webpack_require__(64);
	var unserializeMapIM = __webpack_require__(66);

	var configMapChatroom = __webpack_require__(62);
	var serializeMapChatroom = __webpack_require__(63);
	var unserializeMapChatroom = __webpack_require__(65);

	function Parser(options) {
	  this.mixin(options);
	}

	Parser.prototype.mixin = function (options) {
	  var _this = this;

	  this.configMap = this.configMap || {};['idMap', 'cmdConfig', 'packetConfig'].forEach(function (key) {
	    _this.configMap[key] = util.merge({}, _this.configMap[key], options.configMap && options.configMap[key]);
	  });['serializeMap', 'unserializeMap'].forEach(function (key) {
	    _this[key] = util.merge({}, _this[key], options[key]);
	  });
	};

	var parserIm = new Parser({
	  configMap: configMapIM,
	  serializeMap: serializeMapIM,
	  unserializeMap: unserializeMapIM
	});

	var parserChatroom = new Parser({
	  configMap: configMapChatroom,
	  serializeMap: serializeMapChatroom,
	  unserializeMap: unserializeMapChatroom
	});

	Parser.getInstance = function (type) {
	  switch (type) {
	    case 'IM':
	      return parserIm;
	    case 'Chatroom':
	      return parserChatroom;
	  }
	};

	/**
	 * 构造命令
	 *
	 * @param  {String} cmd     命令名称
	 * @param  {Map}    content 命令内容
	 * @return {Object}         命令对象
	 */
	Parser.prototype.createCmd = function () {
	  // 发包序列号
	  var serialId = 1;
	  return function (cmd, content) {
	    var self = this;
	    var config = this.configMap.cmdConfig[cmd];
	    cmd = {
	      SID: config.sid,
	      CID: config.cid,
	      SER: cmd === 'heartbeat' ? 0 : serialId++
	    };
	    // 构造参数列表
	    if (config.params) {
	      cmd.Q = [];
	      config.params.forEach(function (param) {
	        var type = param.type;
	        var name = param.name;
	        var entity = param.entity;
	        var value = content[name];
	        if (undef(value)) {
	          return;
	        }
	        switch (type) {
	          case 'PropertyArray':
	            type = 'ArrayMable';
	            value = value.map(function (item) {
	              return {
	                t: 'Property',
	                v: self.serialize(item, entity)
	              };
	            });
	            break;
	          case 'Property':
	            value = self.serialize(value, name);
	            break;
	          case 'bool':
	            value = value ? 'true' : 'false';
	            break;
	          default:
	            break;
	        }
	        cmd.Q.push({ t: type, v: value });
	      });
	    }
	    return cmd;
	  };
	}();

	/**
	 * 解析包内容
	 *
	 * @param  {String} data 包数据
	 * @return {Object}      解析后的包数据
	 * @property {Object} raw       原始包数据
	 * @property {Object} error     错误信息
	 * @property {Object} content   包内容
	 * @property {String} service   包的协议类型
	 * @property {String} cmd       包的命令类型
	 */
	Parser.prototype.parseResponse = function (data) {
	  var self = this;
	  var raw = JSON.parse(data);
	  var packet = {
	    raw: raw,
	    rawStr: data,
	    error: NIMError.genError(raw.code)
	  };
	  // 获取包配置和包内容
	  var config = self.configMap.packetConfig[raw.sid + '_' + raw.cid];
	  if (!config) {
	    packet.notFound = {
	      sid: raw.sid,
	      cid: raw.cid
	    };
	    return packet;
	  }
	  var body = raw.r;
	  // 如果是通知(4_1,4_2), 那么具体内容在内层包里面
	  var isNotify = config.service === 'notify' && !config.cmd;
	  packet.isNotify = isNotify;
	  if (isNotify) {
	    var innerPacket = raw.r[1].headerPacket;
	    config = self.configMap.packetConfig[innerPacket.sid + '_' + innerPacket.cid];
	    body = raw.r[1].body;
	    if (!config) {
	      packet.notFound = {
	        sid: innerPacket.sid,
	        cid: innerPacket.cid
	      };
	      return packet;
	    }
	  }
	  // 附加属性
	  packet.service = config.service;
	  packet.cmd = config.cmd;

	  // 416 频控
	  if (packet.error && packet.error.code === 416) {
	    var duration = body[0];
	    if (duration) {
	      // s -> ms
	      packet.frequencyControlDuration = duration * 1000;
	    }
	  }
	  // 错误是否不影响 response 的解析
	  var errorIsTrivial = false;
	  if (packet.error && config.trivialErrorCodes) {
	    errorIsTrivial = config.trivialErrorCodes.indexOf(packet.error.code) !== -1;
	  }
	  // 如果没错误，或者错误不影响 response 的解析，那么解析 response
	  if ((!packet.error || errorIsTrivial) && !!config.response) {
	    packet.content = {};
	    config.response.forEach(function (res, index) {
	      var value = body[index];
	      if (util.undef(value)) {
	        return;
	      }

	      var type = res.type;
	      var name = res.name;
	      var entity = res.entity || name;
	      switch (type) {
	        case 'Property':
	          packet.content[name] = self.unserialize(value, entity);
	          break;
	        case 'PropertyArray':
	          packet.content[name] = [];
	          value.forEach(function (data) {
	            packet.content[name].push(self.unserialize(data, entity));
	          });
	          break;
	        case 'KVArray':
	          packet.content[name] = value;
	          break;
	        case 'long':
	        case 'Long':
	        case 'byte':
	        case 'Byte':
	        case 'Number':
	          packet.content[name] = +value;
	          break;
	        default:
	          packet.content[name] = value;
	          break;
	      }
	      // 如果是通知, id在整个包内容的第一个位置, 里面的消息和系统消息是没有这个id的
	      // hzzhangyingya
	      if (isNotify && name === 'msg' || name === 'sysMsg') {
	        var obj = packet.content[name];
	        if (util.isObject(obj) && !obj.idServer) {
	          obj.idServer = '' + raw.r[0];
	          if (obj.type && obj.type === '8' && obj.deletedIdClient) {
	            obj.idServer = obj.deletedIdClient;
	          }
	        }
	      }
	    });
	  }

	  return packet;
	};

	/**
	 * 序列化数据
	 *
	 * @param  {Object} obj     待序列化的对象
	 * @param  {String} entity  对应的实体
	 * @return {Object}         序列化后的对象
	 */
	Parser.prototype.serialize = function (obj, entity) {
	  var map = this.serializeMap[entity];
	  var data = {};
	  for (var p in map) {
	    if (obj.hasOwnProperty(p)) {
	      data[map[p]] = obj[p];
	    }
	  }
	  return data;
	};

	/**
	 * 反序列化
	 *
	 * @param  {Object} data   序列化的对象
	 * @param  {String} entity 对应的实体
	 * @return {Object}        反序列化后的对象
	 */
	Parser.prototype.unserialize = function (data, entity) {
	  var map = this.unserializeMap[entity];
	  var obj = {};
	  if (data) {
	    for (var p in map) {
	      // map有可能会有多余项, data不一定有对应内容
	      if (data.hasOwnProperty(p)) {
	        obj[map[p]] = data[p];
	      }
	    }
	  }
	  return obj;
	};

	module.exports = Parser;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/**
	* @Author: Yingya Zhang <zyy>
	* @Date:   2016-06-29 17:32:00
	* @Email:  zyy7259@gmail.com
	* @Last modified by:   zyy
	* @Last modified time: 2016-06-29 19:16:39
	*/

	/*! Socket.IO.js build:0.9.11, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */

	var io = ( false ? {} : module.exports);

	// 将 io 挂在 window 上, 低版本 IE 要用到
	if (!window.io) {
	  window.io = io;
	} else {
	  if (module) {
	    module.exports = io = window.io
	  }
	}

	(function() {

	/**
	 * socket.io io
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	(function (exports, global) {

	  /**
	   * IO namespace.
	   *
	   * @namespace
	   */

	  var io = exports;

	  /**
	   * Socket.IO version
	   *
	   * @api public
	   */

	  io.version = '0.9.11';

	  /**
	   * Protocol implemented.
	   *
	   * @api public
	   */

	  io.protocol = 1;

	  /**
	   * Available transports, these will be populated with the available transports
	   *
	   * @api public
	   */

	  io.transports = [];

	  /**
	   * Keep track of jsonp callbacks.
	   *
	   * @api private
	   */

	  io.j = [];

	  /**
	   * Keep track of our io.Sockets
	   *
	   * @api private
	   */
	  io.sockets = {};


	  /**
	   * Manages connections to hosts.
	   *
	   * @param {String} uri
	   * @Param {Boolean} force creation of new socket (defaults to false)
	   * @api public
	   */

	  io.connect = function (host, details) {
	    var uri = io.util.parseUri(host)
	      , uuri
	      , socket;

	    if (global && global.location) {
	      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);
	      uri.host = uri.host || (global.document
	        ? global.document.domain : global.location.hostname);
	      uri.port = uri.port || global.location.port;
	    }

	    uuri = io.util.uniqueUri(uri);

	    var options = {
	        host: uri.host
	      , secure: 'https' == uri.protocol
	      , port: uri.port || ('https' == uri.protocol ? 443 : 80)
	      , query: uri.query || ''
	    };

	    io.util.merge(options, details);

	    if (options['force new connection'] || !io.sockets[uuri]) {
	      socket = new io.Socket(options);
	    }

	    if (!options['force new connection'] && socket) {
	      io.sockets[uuri] = socket;
	    }

	    socket = socket || io.sockets[uuri];

	    // if path is different from '' or /
	    return socket.of(uri.path.length > 1 ? uri.path : '');
	  };

	})( true ? module.exports : io, window);
	/**
	 * socket.io util
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	(function (exports, global) {

	  /**
	   * Utilities namespace.
	   *
	   * @namespace
	   */

	  var util = exports.util = {};

	  /**
	   * Parses an URI
	   *
	   * @author Steven Levithan <stevenlevithan.com> (MIT license)
	   * @api public
	   */

	  var re = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

	  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',
	               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',
	               'anchor'];

	  util.parseUri = function (str) {
	    var m = re.exec(str || '')
	      , uri = {}
	      , i = 14;

	    while (i--) {
	      uri[parts[i]] = m[i] || '';
	    }

	    return uri;
	  };

	  /**
	   * Produces a unique url that identifies a Socket.IO connection.
	   *
	   * @param {Object} uri
	   * @api public
	   */

	  util.uniqueUri = function (uri) {
	    var protocol = uri.protocol
	      , host = uri.host
	      , port = uri.port;

	    if ('document' in global) {
	      host = host || document.domain;
	      port = port || (protocol == 'https'
	        && document.location.protocol !== 'https:' ? 443 : document.location.port);
	    } else {
	      host = host || 'localhost';

	      if (!port && protocol == 'https') {
	        port = 443;
	      }
	    }

	    return (protocol || 'http') + '://' + host + ':' + (port || 80);
	  };

	  /**
	   * Mergest 2 query strings in to once unique query string
	   *
	   * @param {String} base
	   * @param {String} addition
	   * @api public
	   */

	  util.query = function (base, addition) {
	    var query = util.chunkQuery(base || '')
	      , components = [];

	    util.merge(query, util.chunkQuery(addition || ''));
	    for (var part in query) {
	      if (query.hasOwnProperty(part)) {
	        components.push(part + '=' + query[part]);
	      }
	    }

	    return components.length ? '?' + components.join('&') : '';
	  };

	  /**
	   * Transforms a querystring in to an object
	   *
	   * @param {String} qs
	   * @api public
	   */

	  util.chunkQuery = function (qs) {
	    var query = {}
	      , params = qs.split('&')
	      , i = 0
	      , l = params.length
	      , kv;

	    for (; i < l; ++i) {
	      kv = params[i].split('=');
	      if (kv[0]) {
	        query[kv[0]] = kv[1];
	      }
	    }

	    return query;
	  };

	  /**
	   * Executes the given function when the page is loaded.
	   *
	   *     io.util.load(function () { console.log('page loaded'); });
	   *
	   * @param {Function} fn
	   * @api public
	   */

	  var pageLoaded = false;

	  util.load = function (fn) {
	    if ('document' in global && document.readyState === 'complete' || pageLoaded) {
	      return fn();
	    }

	    util.on(global, 'load', fn, false);
	  };

	  /**
	   * Adds an event.
	   *
	   * @api private
	   */

	  util.on = function (element, event, fn, capture) {
	    if (element.attachEvent) {
	      element.attachEvent('on' + event, fn);
	    } else if (element.addEventListener) {
	      element.addEventListener(event, fn, capture);
	    }
	  };

	  /**
	   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.
	   *
	   * @param {Boolean} [xdomain] Create a request that can be used cross domain.
	   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.
	   * @api private
	   */

	  util.request = function (xdomain) {

	    if (xdomain && 'undefined' != typeof XDomainRequest && !util.ua.hasCORS) {
	      return new XDomainRequest();
	    }

	    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {
	      return new XMLHttpRequest();
	    }

	    if (!xdomain) {
	      try {
	        return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');
	      } catch(e) { }
	    }

	    return null;
	  };

	  /**
	   * XHR based transport constructor.
	   *
	   * @constructor
	   * @api public
	   */

	  /**
	   * Change the internal pageLoaded value.
	   */

	  if ('undefined' != typeof window) {
	    util.load(function () {
	      pageLoaded = true;
	    });
	  }

	  /**
	   * Defers a function to ensure a spinner is not displayed by the browser
	   *
	   * @param {Function} fn
	   * @api public
	   */

	  util.defer = function (fn) {
	    if (!util.ua.webkit || 'undefined' != typeof importScripts) {
	      return fn();
	    }

	    util.load(function () {
	      setTimeout(fn, 100);
	    });
	  };

	  /**
	   * Merges two objects.
	   *
	   * @api public
	   */

	  util.merge = function merge (target, additional, deep, lastseen) {
	    var seen = lastseen || []
	      , depth = typeof deep == 'undefined' ? 2 : deep
	      , prop;

	    for (prop in additional) {
	      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {
	        if (typeof target[prop] !== 'object' || !depth) {
	          target[prop] = additional[prop];
	          seen.push(additional[prop]);
	        } else {
	          util.merge(target[prop], additional[prop], depth - 1, seen);
	        }
	      }
	    }

	    return target;
	  };

	  /**
	   * Merges prototypes from objects
	   *
	   * @api public
	   */

	  util.mixin = function (ctor, ctor2) {
	    util.merge(ctor.prototype, ctor2.prototype);
	  };

	  /**
	   * Shortcut for prototypical and static inheritance.
	   *
	   * @api private
	   */

	  util.inherit = function (ctor, ctor2) {
	    function f() {};
	    f.prototype = ctor2.prototype;
	    ctor.prototype = new f;
	  };

	  /**
	   * Checks if the given object is an Array.
	   *
	   *     io.util.isArray([]); // true
	   *     io.util.isArray({}); // false
	   *
	   * @param Object obj
	   * @api public
	   */

	  util.isArray = Array.isArray || function (obj) {
	    return Object.prototype.toString.call(obj) === '[object Array]';
	  };

	  /**
	   * Intersects values of two arrays into a third
	   *
	   * @api public
	   */

	  util.intersect = function (arr, arr2) {
	    var ret = []
	      , longest = arr.length > arr2.length ? arr : arr2
	      , shortest = arr.length > arr2.length ? arr2 : arr;

	    for (var i = 0, l = shortest.length; i < l; i++) {
	      if (~util.indexOf(longest, shortest[i]))
	        ret.push(shortest[i]);
	    }

	    return ret;
	  };

	  /**
	   * Array indexOf compatibility.
	   *
	   * @see bit.ly/a5Dxa2
	   * @api public
	   */

	  util.indexOf = function (arr, o, i) {

	    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0;
	         i < j && arr[i] !== o; i++) {}

	    return j <= i ? -1 : i;
	  };

	  /**
	   * Converts enumerables to array.
	   *
	   * @api public
	   */

	  util.toArray = function (enu) {
	    var arr = [];

	    for (var i = 0, l = enu.length; i < l; i++)
	      arr.push(enu[i]);

	    return arr;
	  };

	  /**
	   * UA / engines detection namespace.
	   *
	   * @namespace
	   */

	  util.ua = {};

	  /**
	   * Whether the UA supports CORS for XHR.
	   *
	   * @api public
	   */

	  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {
	    try {
	      var a = new XMLHttpRequest();
	    } catch (e) {
	      return false;
	    }

	    return a.withCredentials != undefined;
	  })();

	  /**
	   * Detect webkit.
	   *
	   * @api public
	   */

	  util.ua.webkit = 'undefined' != typeof navigator
	    && /webkit/i.test(navigator.userAgent);

	   /**
	   * Detect iPad/iPhone/iPod.
	   *
	   * @api public
	   */

	  util.ua.iDevice = 'undefined' != typeof navigator
	      && /iPad|iPhone|iPod/i.test(navigator.userAgent);

	})('undefined' != typeof io ? io : module.exports, window);
	/**
	 * socket.io EventEmitter
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	(function (exports, io) {

	  /**
	   * Expose constructor.
	   */

	  exports.EventEmitter = EventEmitter;

	  /**
	   * Event emitter constructor.
	   *
	   * @api public.
	   */

	  function EventEmitter () {};

	  /**
	   * Adds a listener
	   *
	   * @api public
	   */

	  EventEmitter.prototype.on = function (name, fn) {
	    if (!this.$events) {
	      this.$events = {};
	    }

	    if (!this.$events[name]) {
	      this.$events[name] = fn;
	    } else if (io.util.isArray(this.$events[name])) {
	      this.$events[name].push(fn);
	    } else {
	      this.$events[name] = [this.$events[name], fn];
	    }

	    return this;
	  };

	  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	  /**
	   * Adds a volatile listener.
	   *
	   * @api public
	   */

	  EventEmitter.prototype.once = function (name, fn) {
	    var self = this;

	    function on () {
	      self.removeListener(name, on);
	      fn.apply(this, arguments);
	    };

	    on.listener = fn;
	    this.on(name, on);

	    return this;
	  };

	  /**
	   * Removes a listener.
	   *
	   * @api public
	   */

	  EventEmitter.prototype.removeListener = function (name, fn) {
	    if (this.$events && this.$events[name]) {
	      var list = this.$events[name];

	      if (io.util.isArray(list)) {
	        var pos = -1;

	        for (var i = 0, l = list.length; i < l; i++) {
	          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {
	            pos = i;
	            break;
	          }
	        }

	        if (pos < 0) {
	          return this;
	        }

	        list.splice(pos, 1);

	        if (!list.length) {
	          delete this.$events[name];
	        }
	      } else if (list === fn || (list.listener && list.listener === fn)) {
	        delete this.$events[name];
	      }
	    }

	    return this;
	  };

	  /**
	   * Removes all listeners for an event.
	   *
	   * @api public
	   */

	  EventEmitter.prototype.removeAllListeners = function (name) {
	    if (name === undefined) {
	      this.$events = {};
	      return this;
	    }

	    if (this.$events && this.$events[name]) {
	      this.$events[name] = null;
	    }

	    return this;
	  };

	  /**
	   * Gets all listeners for a certain event.
	   *
	   * @api publci
	   */

	  EventEmitter.prototype.listeners = function (name) {
	    if (!this.$events) {
	      this.$events = {};
	    }

	    if (!this.$events[name]) {
	      this.$events[name] = [];
	    }

	    if (!io.util.isArray(this.$events[name])) {
	      this.$events[name] = [this.$events[name]];
	    }

	    return this.$events[name];
	  };

	  /**
	   * Emits an event.
	   *
	   * @api public
	   */

	  EventEmitter.prototype.emit = function (name) {
	    if (!this.$events) {
	      return false;
	    }

	    var handler = this.$events[name];

	    if (!handler) {
	      return false;
	    }

	    var args = Array.prototype.slice.call(arguments, 1);

	    if ('function' == typeof handler) {
	      handler.apply(this, args);
	    } else if (io.util.isArray(handler)) {
	      var listeners = handler.slice();

	      for (var i = 0, l = listeners.length; i < l; i++) {
	        listeners[i].apply(this, args);
	      }
	    } else {
	      return false;
	    }

	    return true;
	  };

	})(
	    'undefined' != typeof io ? io : module.exports
	  , 'undefined' != typeof io ? io : module.parent.exports
	);

	/**
	 * socket.io JSON
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	/**
	 * Based on JSON2 (http://www.JSON.org/js.html).
	 */

	(function (exports, nativeJSON) {
	  "use strict";

	  // use native JSON if it's available
	  if (nativeJSON && nativeJSON.parse){
	    return exports.JSON = {
	      parse: nativeJSON.parse
	    , stringify: nativeJSON.stringify
	    };
	  }

	  var JSON = exports.JSON = {};

	  function f(n) {
	      // Format integers to have at least two digits.
	      return n < 10 ? '0' + n : n;
	  }

	  function date(d, key) {
	    return isFinite(d.valueOf()) ?
	        d.getUTCFullYear()     + '-' +
	        f(d.getUTCMonth() + 1) + '-' +
	        f(d.getUTCDate())      + 'T' +
	        f(d.getUTCHours())     + ':' +
	        f(d.getUTCMinutes())   + ':' +
	        f(d.getUTCSeconds())   + 'Z' : null;
	  };

	  var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	      escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	      gap,
	      indent,
	      meta = {    // table of character substitutions
	          '\b': '\\b',
	          '\t': '\\t',
	          '\n': '\\n',
	          '\f': '\\f',
	          '\r': '\\r',
	          '"' : '\\"',
	          '\\': '\\\\'
	      },
	      rep;


	  function quote(string) {

	      // If the string contains no control characters, no quote characters, and no
	      // backslash characters, then we can safely slap some quotes around it.
	      // Otherwise we must also replace the offending characters with safe escape
	      // sequences.

	      escapable.lastIndex = 0;
	      return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
	          var c = meta[a];
	          return typeof c === 'string' ? c :
	              '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	      }) + '"' : '"' + string + '"';
	  }


	  function str(key, holder) {

	      // Produce a string from holder[key].

	      var i,          // The loop counter.
	          k,          // The member key.
	          v,          // The member value.
	          length,
	          mind = gap,
	          partial,
	          value = holder[key];

	      // If the value has a toJSON method, call it to obtain a replacement value.

	      if (value instanceof Date) {
	          value = date(key);
	      }

	      // If we were called with a replacer function, then call the replacer to
	      // obtain a replacement value.

	      if (typeof rep === 'function') {
	          value = rep.call(holder, key, value);
	      }

	      // What happens next depends on the value's type.

	      switch (typeof value) {
	      case 'string':
	          return quote(value);

	      case 'number':

	          // JSON numbers must be finite. Encode non-finite numbers as null.

	          return isFinite(value) ? String(value) : 'null';

	      case 'boolean':
	      case 'null':

	          // If the value is a boolean or null, convert it to a string. Note:
	          // typeof null does not produce 'null'. The case is included here in
	          // the remote chance that this gets fixed someday.

	          return String(value);

	      // If the type is 'object', we might be dealing with an object or an array or
	      // null.

	      case 'object':

	          // Due to a specification blunder in ECMAScript, typeof null is 'object',
	          // so watch out for that case.

	          if (!value) {
	              return 'null';
	          }

	          // Make an array to hold the partial results of stringifying this object value.

	          gap += indent;
	          partial = [];

	          // Is the value an array?

	          if (Object.prototype.toString.apply(value) === '[object Array]') {

	              // The value is an array. Stringify every element. Use null as a placeholder
	              // for non-JSON values.

	              length = value.length;
	              for (i = 0; i < length; i += 1) {
	                  partial[i] = str(i, value) || 'null';
	              }

	              // Join all of the elements together, separated with commas, and wrap them in
	              // brackets.

	              v = partial.length === 0 ? '[]' : gap ?
	                  '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
	                  '[' + partial.join(',') + ']';
	              gap = mind;
	              return v;
	          }

	          // If the replacer is an array, use it to select the members to be stringified.

	          if (rep && typeof rep === 'object') {
	              length = rep.length;
	              for (i = 0; i < length; i += 1) {
	                  if (typeof rep[i] === 'string') {
	                      k = rep[i];
	                      v = str(k, value);
	                      if (v) {
	                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                      }
	                  }
	              }
	          } else {

	              // Otherwise, iterate through all of the keys in the object.

	              for (k in value) {
	                  if (Object.prototype.hasOwnProperty.call(value, k)) {
	                      v = str(k, value);
	                      if (v) {
	                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                      }
	                  }
	              }
	          }

	          // Join all of the member texts together, separated with commas,
	          // and wrap them in braces.

	          v = partial.length === 0 ? '{}' : gap ?
	              '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
	              '{' + partial.join(',') + '}';
	          gap = mind;
	          return v;
	      }
	  }

	  // If the JSON object does not yet have a stringify method, give it one.

	  JSON.stringify = function (value, replacer, space) {

	      // The stringify method takes a value and an optional replacer, and an optional
	      // space parameter, and returns a JSON text. The replacer can be a function
	      // that can replace values, or an array of strings that will select the keys.
	      // A default replacer method can be provided. Use of the space parameter can
	      // produce text that is more easily readable.

	      var i;
	      gap = '';
	      indent = '';

	      // If the space parameter is a number, make an indent string containing that
	      // many spaces.

	      if (typeof space === 'number') {
	          for (i = 0; i < space; i += 1) {
	              indent += ' ';
	          }

	      // If the space parameter is a string, it will be used as the indent string.

	      } else if (typeof space === 'string') {
	          indent = space;
	      }

	      // If there is a replacer, it must be a function or an array.
	      // Otherwise, throw an error.

	      rep = replacer;
	      if (replacer && typeof replacer !== 'function' &&
	              (typeof replacer !== 'object' ||
	              typeof replacer.length !== 'number')) {
	          throw new Error('JSON.stringify');
	      }

	      // Make a fake root object containing our value under the key of ''.
	      // Return the result of stringifying the value.

	      return str('', {'': value});
	  };

	  // If the JSON object does not yet have a parse method, give it one.

	  JSON.parse = function (text, reviver) {
	      // The parse method takes a text and an optional reviver function, and returns
	      // a JavaScript value if the text is a valid JSON text.

	      var j;

	      function walk(holder, key) {

	          // The walk method is used to recursively walk the resulting structure so
	          // that modifications can be made.

	          var k, v, value = holder[key];
	          if (value && typeof value === 'object') {
	              for (k in value) {
	                  if (Object.prototype.hasOwnProperty.call(value, k)) {
	                      v = walk(value, k);
	                      if (v !== undefined) {
	                          value[k] = v;
	                      } else {
	                          delete value[k];
	                      }
	                  }
	              }
	          }
	          return reviver.call(holder, key, value);
	      }


	      // Parsing happens in four stages. In the first stage, we replace certain
	      // Unicode characters with escape sequences. JavaScript handles many characters
	      // incorrectly, either silently deleting them, or treating them as line endings.

	      text = String(text);
	      cx.lastIndex = 0;
	      if (cx.test(text)) {
	          text = text.replace(cx, function (a) {
	              return '\\u' +
	                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	          });
	      }

	      // In the second stage, we run the text against regular expressions that look
	      // for non-JSON patterns. We are especially concerned with '()' and 'new'
	      // because they can cause invocation, and '=' because it can cause mutation.
	      // But just to be safe, we want to reject all unexpected forms.

	      // We split the second stage into 4 regexp operations in order to work around
	      // crippling inefficiencies in IE's and Safari's regexp engines. First we
	      // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
	      // replace all simple value tokens with ']' characters. Third, we delete all
	      // open brackets that follow a colon or comma or that begin the text. Finally,
	      // we look to see that the remaining characters are only whitespace or ']' or
	      // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

	      if (/^[\],:{}\s]*$/
	              .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
	                  .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
	                  .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

	          // In the third stage we use the eval function to compile the text into a
	          // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
	          // in JavaScript: it can begin a block or an object literal. We wrap the text
	          // in parens to eliminate the ambiguity.

	          j = eval('(' + text + ')');

	          // In the optional fourth stage, we recursively walk the new structure, passing
	          // each name/value pair to a reviver function for possible transformation.

	          return typeof reviver === 'function' ?
	              walk({'': j}, '') : j;
	      }

	      // If the text is not JSON parseable, then a SyntaxError is thrown.

	      throw new SyntaxError('JSON.parse');
	  };

	})(
	    'undefined' != typeof io ? io : module.exports
	  , typeof JSON !== 'undefined' ? JSON : undefined
	);

	/**
	 * socket.io parser
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	(function (exports, io) {

	  /**
	   * Parser namespace.
	   *
	   * @namespace
	   */

	  var parser = exports.parser = {};

	  /**
	   * Packet types.
	   */

	  var packets = parser.packets = [
	      'disconnect'
	    , 'connect'
	    , 'heartbeat'
	    , 'message'
	    , 'json'
	    , 'event'
	    , 'ack'
	    , 'error'
	    , 'noop'
	  ];

	  /**
	   * Errors reasons.
	   */

	  var reasons = parser.reasons = [
	      'transport not supported'
	    , 'client not handshaken'
	    , 'unauthorized'
	  ];

	  /**
	   * Errors advice.
	   */

	  var advice = parser.advice = [
	      'reconnect'
	  ];

	  /**
	   * Shortcuts.
	   */

	  var JSON = io.JSON
	    , indexOf = io.util.indexOf;

	  /**
	   * Encodes a packet.
	   *
	   * @api private
	   */

	  parser.encodePacket = function (packet) {
	    var type = indexOf(packets, packet.type)
	      , id = packet.id || ''
	      , endpoint = packet.endpoint || ''
	      , ack = packet.ack
	      , data = null;

	    switch (packet.type) {
	      case 'error':
	        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''
	          , adv = packet.advice ? indexOf(advice, packet.advice) : '';

	        if (reason !== '' || adv !== '')
	          data = reason + (adv !== '' ? ('+' + adv) : '');

	        break;

	      case 'message':
	        if (packet.data !== '')
	          data = packet.data;
	        break;

	      case 'event':
	        var ev = { name: packet.name };

	        if (packet.args && packet.args.length) {
	          ev.args = packet.args;
	        }

	        data = JSON.stringify(ev);
	        break;

	      case 'json':
	        data = JSON.stringify(packet.data);
	        break;

	      case 'connect':
	        if (packet.qs)
	          data = packet.qs;
	        break;

	      case 'ack':
	        data = packet.ackId
	          + (packet.args && packet.args.length
	              ? '+' + JSON.stringify(packet.args) : '');
	        break;
	    }

	    // construct packet with required fragments
	    var encoded = [
	        type
	      , id + (ack == 'data' ? '+' : '')
	      , endpoint
	    ];

	    // data fragment is optional
	    if (data !== null && data !== undefined)
	      encoded.push(data);

	    return encoded.join(':');
	  };

	  /**
	   * Encodes multiple messages (payload).
	   *
	   * @param {Array} messages
	   * @api private
	   */

	  parser.encodePayload = function (packets) {
	    var decoded = '';

	    if (packets.length == 1)
	      return packets[0];

	    for (var i = 0, l = packets.length; i < l; i++) {
	      var packet = packets[i];
	      decoded += '\ufffd' + packet.length + '\ufffd' + packets[i];
	    }

	    return decoded;
	  };

	  /**
	   * Decodes a packet
	   *
	   * @api private
	   */

	  var regexp = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;

	  parser.decodePacket = function (data) {
	    var pieces = data.match(regexp);

	    if (!pieces) return {};

	    var id = pieces[2] || ''
	      , data = pieces[5] || ''
	      , packet = {
	            type: packets[pieces[1]]
	          , endpoint: pieces[4] || ''
	        };

	    // whether we need to acknowledge the packet
	    if (id) {
	      packet.id = id;
	      if (pieces[3])
	        packet.ack = 'data';
	      else
	        packet.ack = true;
	    }

	    // handle different packet types
	    switch (packet.type) {
	      case 'error':
	        var pieces = data.split('+');
	        packet.reason = reasons[pieces[0]] || '';
	        packet.advice = advice[pieces[1]] || '';
	        break;

	      case 'message':
	        packet.data = data || '';
	        break;

	      case 'event':
	        try {
	          var opts = JSON.parse(data);
	          packet.name = opts.name;
	          packet.args = opts.args;
	        } catch (e) { }

	        packet.args = packet.args || [];
	        break;

	      case 'json':
	        try {
	          packet.data = JSON.parse(data);
	        } catch (e) { }
	        break;

	      case 'connect':
	        packet.qs = data || '';
	        break;

	      case 'ack':
	        var pieces = data.match(/^([0-9]+)(\+)?(.*)/);
	        if (pieces) {
	          packet.ackId = pieces[1];
	          packet.args = [];

	          if (pieces[3]) {
	            try {
	              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];
	            } catch (e) { }
	          }
	        }
	        break;

	      case 'disconnect':
	      case 'heartbeat':
	        break;
	    };

	    return packet;
	  };

	  /**
	   * Decodes data payload. Detects multiple messages
	   *
	   * @return {Array} messages
	   * @api public
	   */

	  parser.decodePayload = function (data) {
	    // IE doesn't like data[i] for unicode chars, charAt works fine
	    var _findEndChar = function(_start,_data){
	      var l=0;
	      for(var i=_start;i<_data.length;i++){
	        if(_data.charAt(i)=='\ufffd'){
	          return l;
	          break;
	        }
	        else
	          l++;
	      }
	      return l;
	    }
	    if (data.charAt(0) == '\ufffd') {
	      var ret = [];
	      for (var i = 1, length = ''; i < data.length; i++) {
	        if (data.charAt(i) == '\ufffd') {
	          var _data = data.substr(i + 1).substr(0, length);
	          if(data.charAt(i + 1+Number(length))!='\ufffd'&&(i + 1+Number(length))!=data.length){
	            var _len = Number(length)
	            l = _findEndChar(i+_len+1,data);
	            _data = data.substr(i + 1).substr(0, _len+l);
	            i+=l;
	          }
	          ret.push(parser.decodePacket(_data));
	          i += Number(length) + 1;
	          length = '';
	        } else {
	          length += data.charAt(i);
	        }
	      }

	      return ret;
	    } else {
	      return [parser.decodePacket(data)];
	    }
	  };

	})(
	    'undefined' != typeof io ? io : module.exports
	  , 'undefined' != typeof io ? io : module.parent.exports
	);
	/**
	 * socket.io Transport template
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	(function (exports, io) {

	  /**
	   * Expose constructor.
	   */

	  exports.Transport = Transport;

	  /**
	   * This is the transport template for all supported transport methods.
	   *
	   * @constructor
	   * @api public
	   */

	  function Transport (socket, sessid) {
	    this.socket = socket;
	    this.sessid = sessid;
	  };

	  /**
	   * Apply EventEmitter mixin.
	   */

	  io.util.mixin(Transport, io.EventEmitter);


	  /**
	   * Indicates whether heartbeats is enabled for this transport
	   *
	   * @api private
	   */

	  Transport.prototype.heartbeats = function () {
	    return true;
	  };

	  /**
	   * Handles the response from the server. When a new response is received
	   * it will automatically update the timeout, decode the message and
	   * forwards the response to the onMessage function for further processing.
	   *
	   * @param {String} data Response from the server.
	   * @api private
	   */

	  Transport.prototype.onData = function (data) {
	    // 当一个 transport 超时之后, 会尝试连接下一个 transport
	    // 但是有可能第一个 transport 还是连上了
	    // 那么这里加一个判断, 如果 this 不是当前的 transport, 那么直接返回 @hzzhangyingya
	    if (this !== this.socket.transport) {return this;}
	    this.clearCloseTimeout();

	    // If the connection in currently open (or in a reopening state) reset the close
	    // timeout since we have just received data. This check is necessary so
	    // that we don't reset the timeout on an explicitly disconnected connection.
	    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {
	      this.setCloseTimeout();
	    }

	    if (data !== '') {
	      // todo: we should only do decodePayload for xhr transports
	      var msgs = io.parser.decodePayload(data);

	      if (msgs && msgs.length) {
	        for (var i = 0, l = msgs.length; i < l; i++) {
	          this.onPacket(msgs[i]);
	        }
	      }
	    }

	    return this;
	  };

	  /**
	   * Handles packets.
	   *
	   * @api private
	   */

	  Transport.prototype.onPacket = function (packet) {
	    this.socket.setHeartbeatTimeout();

	    if (packet.type == 'heartbeat') {
	      return this.onHeartbeat();
	    }

	    if (packet.type == 'connect' && packet.endpoint == '') {
	      this.onConnect();
	    }

	    if (packet.type == 'error' && packet.advice == 'reconnect') {
	      this.isOpen = false;
	    }

	    this.socket.onPacket(packet);

	    return this;
	  };

	  /**
	   * Sets close timeout
	   *
	   * @api private
	   */

	  Transport.prototype.setCloseTimeout = function () {
	    if (!this.closeTimeout) {
	      var self = this;

	      this.closeTimeout = setTimeout(function () {
	        self.onDisconnect();
	      }, this.socket.closeTimeout);
	    }
	  };

	  /**
	   * Called when transport disconnects.
	   *
	   * @api private
	   */

	  Transport.prototype.onDisconnect = function () {
	    if (this.isOpen) this.close();
	    this.clearTimeouts();
	    // 如果当前 socket 的 transport 不是自己, 那么不管 @hzzhangyingya
	    if (this.socket.transport === this) {
	      this.socket.onDisconnect();
	    } else {
	      this.socket.setBuffer(false)
	    }
	    return this;
	  };

	  /**
	   * Called when transport connects
	   *
	   * @api private
	   */

	  Transport.prototype.onConnect = function () {
	    this.socket.onConnect();
	    return this;
	  };

	  /**
	   * Clears close timeout
	   *
	   * @api private
	   */

	  Transport.prototype.clearCloseTimeout = function () {
	    if (this.closeTimeout) {
	      clearTimeout(this.closeTimeout);
	      this.closeTimeout = null;
	    }
	  };

	  /**
	   * Clear timeouts
	   *
	   * @api private
	   */

	  Transport.prototype.clearTimeouts = function () {
	    this.clearCloseTimeout();

	    if (this.reopenTimeout) {
	      clearTimeout(this.reopenTimeout);
	    }
	  };

	  /**
	   * Sends a packet
	   *
	   * @param {Object} packet object.
	   * @api private
	   */

	  Transport.prototype.packet = function (packet) {
	    this.send(io.parser.encodePacket(packet));
	  };

	  /**
	   * Send the received heartbeat message back to server. So the server
	   * knows we are still connected.
	   *
	   * @param {String} heartbeat Heartbeat response from the server.
	   * @api private
	   */

	  Transport.prototype.onHeartbeat = function (heartbeat) {
	    this.packet({ type: 'heartbeat' });
	  };

	  /**
	   * Called when the transport opens.
	   *
	   * @api private
	   */

	  Transport.prototype.onOpen = function () {
	    this.isOpen = true;
	    this.clearCloseTimeout();
	    this.socket.onOpen();
	  };

	  /**
	   * Notifies the base when the connection with the Socket.IO server
	   * has been disconnected.
	   *
	   * @api private
	   */

	  Transport.prototype.onClose = function () {
	    var self = this;

	    /* FIXME: reopen delay causing a infinit loop
	    this.reopenTimeout = setTimeout(function () {
	      self.open();
	    }, this.socket.options['reopen delay']);*/

	    this.isOpen = false;
	    // 如果当前 socket 的 transport 不是自己, 那么不管 @hzzhangyingya
	    if (this.socket.transport === this) {
	      this.socket.onClose();
	    } else {
	      this.socket.setBuffer(false)
	    }
	    this.onDisconnect();
	  };

	  /**
	   * Generates a connection url based on the Socket.IO URL Protocol.
	   * See <https://github.com/learnboost/socket.io-node/> for more details.
	   *
	   * @returns {String} Connection url
	   * @api private
	   */

	  Transport.prototype.prepareUrl = function () {
	    var options = this.socket.options;

	    return this.scheme() + '://'
	      + options.host + ':' + options.port + '/'
	      + options.resource + '/' + io.protocol
	      + '/' + this.name + '/' + this.sessid;
	  };

	  /**
	   * Checks if the transport is ready to start a connection.
	   *
	   * @param {Socket} socket The socket instance that needs a transport
	   * @param {Function} fn The callback
	   * @api private
	   */

	  Transport.prototype.ready = function (socket, fn) {
	    fn.call(this);
	  };
	})(
	    'undefined' != typeof io ? io : module.exports
	  , 'undefined' != typeof io ? io : module.parent.exports
	);
	/**
	 * socket.io Socket
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	(function (exports, io, global) {

	  /**
	   * Expose constructor.
	   */

	  exports.Socket = Socket;

	  /**
	   * Create a new `Socket.IO client` which can establish a persistent
	   * connection with a Socket.IO enabled server.
	   *
	   * @api public
	   */

	  function Socket (options) {
	    this.options = {
	        port: 80
	      , secure: false
	      , document: 'document' in global ? document : false
	      , resource: 'socket.io'
	      , transports: options.transports || io.transports
	      , 'connect timeout': 10000
	      , 'try multiple transports': true
	      , 'reconnect': true
	      , 'reconnection delay': 500
	      , 'reconnection limit': Infinity
	      , 'reopen delay': 3000
	      , 'max reconnection attempts': 10
	      , 'sync disconnect on unload': false
	      , 'auto connect': true
	      , 'flash policy port': 10843
	      , 'manualFlush': false
	    };

	    io.util.merge(this.options, options);

	    this.connected = false;
	    this.open = false;
	    this.connecting = false;
	    this.reconnecting = false;
	    this.namespaces = {};
	    this.buffer = [];
	    this.doBuffer = false;

	    if (this.options['sync disconnect on unload'] &&
	        (!this.isXDomain() || io.util.ua.hasCORS)) {
	      var self = this;
	      io.util.on(global, 'beforeunload', function () {
	        self.disconnectSync();
	      }, false);
	    }

	    if (this.options['auto connect']) {
	      this.connect();
	    }
	  };

	  /**
	   * Apply EventEmitter mixin.
	   */

	  io.util.mixin(Socket, io.EventEmitter);

	  /**
	   * Returns a namespace listener/emitter for this socket
	   *
	   * @api public
	   */

	  Socket.prototype.of = function (name) {
	    if (!this.namespaces[name]) {
	      this.namespaces[name] = new io.SocketNamespace(this, name);

	      if (name !== '') {
	        this.namespaces[name].packet({ type: 'connect' });
	      }
	    }

	    return this.namespaces[name];
	  };

	  /**
	   * Emits the given event to the Socket and all namespaces
	   *
	   * @api private
	   */

	  Socket.prototype.publish = function () {
	    this.emit.apply(this, arguments);

	    var nsp;

	    for (var i in this.namespaces) {
	      if (this.namespaces.hasOwnProperty(i)) {
	        nsp = this.of(i);
	        nsp.$emit.apply(nsp, arguments);
	      }
	    }
	  };

	  /**
	   * Performs the handshake
	   *
	   * @api private
	   */

	  function empty () { };

	  Socket.prototype.handshake = function (fn) {
	    var self = this
	      , options = this.options;

	    function complete (data) {
	      if (data instanceof Error) {
	        self.connecting = false;
	        self.onError(data.message);
	      } else {
	        console.log('D handshake success ' + data)
	        fn.apply(null, data.split(':'));
	      }
	    };

	    var url = [
	          'http' + (options.secure ? 's' : '') + ':/'
	        , options.host + ':' + options.port
	        , options.resource
	        , io.protocol
	        , io.util.query(this.options.query, 't=' + +new Date)
	      ].join('/');
	    if (this.isXDomain() && !io.util.ua.hasCORS) {
	      var insertAt = document.getElementsByTagName('script')[0]
	        , script = document.createElement('script');

	      script.src = url + '&jsonp=' + io.j.length;
	      // https://github.com/Automattic/socket.io/issues/1020#issuecomment-9684494
	      // when script failed to load, trigger onError which will trigger reconnecting
	      script.onreadystatechange = function() {
	        // debugger
	        // 'loaded' means failed (yeah, I know)
	        // github上说loaded的时候是脚本失败了, 但是我发现在IE下, 脚本成功执行, 最后状态也是loaded
	        // 所以再加一个条件, 在此 script 没有被移除的情况下才算失败
	        if(this.readyState == 'loaded' && !!script.parentNode){
	          script.parentNode.removeChild(script);
	          self.connecting = false;
	          !self.reconnecting && self.onError('Server down or port not open');
	          // 注意, 下面这行代码是云信业务专用的, 云信是不自动重连, 需要手动控制重连的逻辑, 在这里通知外部握手失败, 这样就处理重连逻辑
	          self.publish('handshake_failed');
	        }
	      };
	      insertAt.parentNode.insertBefore(script, insertAt);

	      io.j.push(function (data) {
	        complete(data);
	        script.parentNode.removeChild(script);
	      });
	    } else {
	      var xhr = io.util.request();
	      xhr.timeout = 10000; 
	      xhr.open('GET', url, true);
	      if (this.isXDomain()) {
	        xhr.withCredentials = true;
	      }
	      xhr.onreadystatechange = function () {
	        // debugger
	        if (xhr.readyState == 4) {
	          xhr.onreadystatechange = empty;

	          if (xhr.status == 200) {
	            complete(xhr.responseText);
	          } else if (xhr.status == 403) {
	            self.onError(xhr.responseText);
	            // 注意, 下面这行代码是云信业务专用的, 云信是不自动重连, 需要手动控制重连的逻辑, 在这里通知外部握手失败, 这样就处理重连逻辑
	            self.publish('handshake_failed');
	          } else {
	            self.connecting = false;
	            !self.reconnecting && self.onError(xhr.responseText);
	            // 注意, 下面这行代码是云信业务专用的, 云信是不自动重连, 需要手动控制重连的逻辑, 在这里通知外部握手失败, 这样就处理重连逻辑
	            self.publish('handshake_failed');
	          }
	        }
	      };
	      xhr.ontimeout = function (e) {
	        // XMLHttpRequest 超时。在此做某事。
	        self.connecting = false;
	        !self.reconnecting && self.onError(xhr.responseText);
	        self.publish('handshake_failed');
	      };
	      xhr.send(null);
	    }
	  };

	  /**
	   * Connects to the server.
	   *
	   * @param {Function} [fn] Callback.
	   * @returns {io.Socket}
	   * @api public
	   */

	  Socket.prototype.connect = function (fn) {
	    if (this.connecting) {
	      return this;
	    }

	    var self = this;
	    self.connecting = true;

	    this.handshake(function (sid, heartbeat, close, transports) {
	      self.sessionid = sid;
	      self.closeTimeout = close * 1000;
	      self.heartbeatTimeout = heartbeat * 1000;
	      if(!self.transports)
	          self.transports = self.origTransports = (transports ? io.util.intersect(
	              transports.split(',')
	            , self.options.transports
	          ) : self.options.transports);

	      console.log('D options transports: ' + self.options.transports)
	      console.log('D transports: ' + self.transports)

	      self.setHeartbeatTimeout();

	      self.once('connect', function (){
	        clearTimeout(self.connectTimeoutTimer);
	        self.connectTimeoutTimer = null;

	        fn && typeof fn == 'function' && fn();
	      });

	      self.doConnect();
	    });

	    return this;
	  };

	  Socket.prototype.doConnect = function() {
	    var self = this;

	    if (self.transport) self.transport.clearTimeouts();

	    self.transport = self.getTransport(self.transports);

	    if (!self.transport) return self.publish('connect_failed');

	    // once the transport is ready
	    self.transport.ready(self, function () {
	      self.connecting = true;
	      self.publish('connecting', self.transport.name);
	      self.transport.open();

	      if (self.options['connect timeout']) {
	        if (self.connectTimeoutTimer) { clearTimeout(self.connectTimeoutTimer); }
	        self.connectTimeoutTimer = setTimeout(self.tryNextTransport.bind(self), self.options['connect timeout']);
	      }
	    });
	  };

	  /**
	   * Find an available transport based on the options supplied in the constructor.
	   *
	   * @api private
	   */

	  Socket.prototype.getTransport = function (override) {
	    var transports = override || this.transports, match;

	    for (var i = 0, transport; transport = transports[i]; i++) {
	      console.log('D check ' + transport + ' ' + io.Transport[transport].check(this) + ' , cors ' + io.Transport[transport].xdomainCheck(this))
	      if (io.Transport[transport]
	        && io.Transport[transport].check(this)
	        && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {
	      var result = new io.Transport[transport](this, this.sessionid);
	        return result;
	      }
	    }

	    return null;
	  };

	  Socket.prototype.tryNextTransport = function() {
	    console.log('D try next transport')
	    var self = this;
	    if (!self.connected) {
	      self.connecting = false;

	      if (self.options['try multiple transports']) {
	        var remaining = self.transports;

	        while (remaining.length > 0 && remaining.splice(0,1)[0] !=
	               self.transport.name) {}

	        if (remaining.length){
	          self.doConnect();
	        } else {
	          self.publish('connect_failed');
	        }

	      }
	    }
	  };

	  /**
	   * Clears and sets a new heartbeat timeout using the value given by the
	   * server during the handshake.
	   *
	   * @api private
	   */

	  Socket.prototype.setHeartbeatTimeout = function () {
	    clearTimeout(this.heartbeatTimeoutTimer);
	    if(this.transport && !this.transport.heartbeats()) return;

	    var self = this;
	    this.heartbeatTimeoutTimer = setTimeout(function () {
	      self.transport && self.transport.onClose();
	    }, this.heartbeatTimeout);
	  };

	  /**
	   * Sends a message.
	   *
	   * @param {Object} data packet.
	   * @returns {io.Socket}
	   * @api public
	   */

	  Socket.prototype.packet = function (data) {
	    if (this.connected && !this.doBuffer) {
	      this.transport.packet(data);
	    } else {
	      this.buffer.push(data);
	    }

	    return this;
	  };

	  /**
	   * Sets buffer state
	   *
	   * @api private
	   */

	  Socket.prototype.setBuffer = function (v) {
	    this.doBuffer = v;

	    if (!v && this.connected && this.buffer.length) {
	      if (!this.options['manualFlush']) {
	        this.flushBuffer();
	      }
	    }
	  };

	  /**
	   * Flushes the buffer data over the wire.
	   * To be invoked manually when 'manualFlush' is set to true.
	   *
	   * @api public
	   */

	  Socket.prototype.flushBuffer = function() {
	    this.transport.payload(this.buffer);
	    this.buffer = [];
	  };


	  /**
	   * Disconnect the established connect.
	   *
	   * @returns {io.Socket}
	   * @api public
	   */

	  Socket.prototype.disconnect = function () {
	    if (this.connected || this.connecting) {
	      if (this.open) {
	        this.of('').packet({ type: 'disconnect' });
	      }

	      // handle disconnection immediately
	      this.onDisconnect('booted');
	    }

	    return this;
	  };

	  /**
	   * Disconnects the socket with a sync XHR.
	   *
	   * @api private
	   */

	  Socket.prototype.disconnectSync = function () {
	    // ensure disconnection
	    var xhr = io.util.request();
	    var uri = [
	        'http' + (this.options.secure ? 's' : '') + ':/'
	      , this.options.host + ':' + this.options.port
	      , this.options.resource
	      , io.protocol
	      , ''
	      , this.sessionid
	    ].join('/') + '/?disconnect=1';

	    xhr.open('GET', uri, false);
	    xhr.send(null);

	    // handle disconnection immediately
	    this.onDisconnect('booted');
	  };

	  /**
	   * Check if we need to use cross domain enabled transports. Cross domain would
	   * be a different port or different domain name.
	   *
	   * @returns {Boolean}
	   * @api private
	   */

	  Socket.prototype.isXDomain = function () {

	    var port = global.location.port ||
	      ('https:' == global.location.protocol ? 443 : 80);

	    return this.options.host !== global.location.hostname
	      || this.options.port != port;
	  };

	  /**
	   * Called upon handshake.
	   *
	   * @api private
	   */

	  Socket.prototype.onConnect = function () {
	    if (!this.connected) {
	      this.connected = true;
	      this.connecting = false;
	      if (!this.doBuffer) {
	        // make sure to flush the buffer
	        this.setBuffer(false);
	      }
	      this.emit('connect');
	    }
	  };

	  /**
	   * Called when the transport opens
	   *
	   * @api private
	   */

	  Socket.prototype.onOpen = function () {
	    this.open = true;
	  };

	  /**
	   * Called when the transport closes.
	   *
	   * @api private
	   */

	  Socket.prototype.onClose = function () {
	    this.open = false;
	    clearTimeout(this.heartbeatTimeoutTimer);
	  };

	  /**
	   * Called when the transport first opens a connection
	   *
	   * @param text
	   */

	  Socket.prototype.onPacket = function (packet) {
	    this.of(packet.endpoint).onPacket(packet);
	  };

	  /**
	   * Handles an error.
	   *
	   * @api private
	   */

	  Socket.prototype.onError = function (err) {
	    if (err && err.advice) {
	      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {
	        this.disconnect();
	        if (this.options.reconnect) {
	          this.reconnect();
	        }
	      }
	    }

	    this.publish('error', err && err.reason ? err.reason : err);
	  };

	  /**
	   * Called when the transport disconnects.
	   *
	   * @api private
	   */

	  Socket.prototype.onDisconnect = function (reason) {
	    var wasConnected = this.connected
	      , wasConnecting = this.connecting;

	    this.connected = false;
	    this.connecting = false;
	    this.open = false;

	    if (wasConnected || wasConnecting) {
	      this.transport.close();
	      this.transport.clearTimeouts();
	      if (wasConnected) {
	        this.publish('disconnect', reason);

	        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {
	          this.reconnect();
	        }
	      }
	      // 安卓微信有些机器, 在尝试 WS 方式时会直接 WS.prototype.onClose, 然后会走到这里
	      // 此时 connectTimeoutTimer 还未触发, 所以手动尝试下一个 transport
	      if (wasConnecting) {
	        this.tryNextTransport();
	      }
	    }
	  };

	  /**
	   * Called upon reconnection.
	   *
	   * @api private
	   */

	  Socket.prototype.reconnect = function () {
	    this.reconnecting = true;
	    this.reconnectionAttempts = 0;
	    this.reconnectionDelay = this.options['reconnection delay'];

	    var self = this
	      , maxAttempts = this.options['max reconnection attempts']
	      , tryMultiple = this.options['try multiple transports']
	      , limit = this.options['reconnection limit'];

	    function reset () {
	      if (self.connected) {
	        for (var i in self.namespaces) {
	          if (self.namespaces.hasOwnProperty(i) && '' !== i) {
	              self.namespaces[i].packet({ type: 'connect' });
	          }
	        }
	        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);
	      }

	      clearTimeout(self.reconnectionTimer);

	      self.removeListener('connect_failed', maybeReconnect);
	      self.removeListener('connect', maybeReconnect);

	      self.reconnecting = false;

	      delete self.reconnectionAttempts;
	      delete self.reconnectionDelay;
	      delete self.reconnectionTimer;
	      delete self.redoTransports;

	      self.options['try multiple transports'] = tryMultiple;
	    };

	    function maybeReconnect () {
	      if (!self.reconnecting) {
	        return;
	      }

	      if (self.connected) {
	        return reset();
	      };

	      if (self.connecting && self.reconnecting) {
	        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);
	      }

	      if (self.reconnectionAttempts++ >= maxAttempts) {
	        if (!self.redoTransports) {
	          self.on('connect_failed', maybeReconnect);
	          self.options['try multiple transports'] = true;
	          self.transports = self.origTransports;
	          self.transport = self.getTransport();
	          self.redoTransports = true;
	          self.connect();
	        } else {
	          self.publish('reconnect_failed');
	          reset();
	        }
	      } else {
	        if (self.reconnectionDelay < limit) {
	          self.reconnectionDelay *= 2; // exponential back off
	        }

	        self.connect();
	        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);
	        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);
	      }
	    };

	    this.options['try multiple transports'] = false;
	    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);

	    this.on('connect', maybeReconnect);
	  };

	})(
	    'undefined' != typeof io ? io : module.exports
	  , 'undefined' != typeof io ? io : module.parent.exports
	  , window
	);
	/**
	 * socket.io SocketNamespace
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	(function (exports, io) {

	  /**
	   * Expose constructor.
	   */

	  exports.SocketNamespace = SocketNamespace;

	  /**
	   * Socket namespace constructor.
	   *
	   * @constructor
	   * @api public
	   */

	  function SocketNamespace (socket, name) {
	    this.socket = socket;
	    this.name = name || '';
	    this.flags = {};
	    this.json = new Flag(this, 'json');
	    this.ackPackets = 0;
	    this.acks = {};
	  };

	  /**
	   * Apply EventEmitter mixin.
	   */

	  io.util.mixin(SocketNamespace, io.EventEmitter);

	  /**
	   * Copies emit since we override it
	   *
	   * @api private
	   */

	  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;

	  /**
	   * Creates a new namespace, by proxying the request to the socket. This
	   * allows us to use the synax as we do on the server.
	   *
	   * @api public
	   */

	  SocketNamespace.prototype.of = function () {
	    return this.socket.of.apply(this.socket, arguments);
	  };

	  /**
	   * Sends a packet.
	   *
	   * @api private
	   */

	  SocketNamespace.prototype.packet = function (packet) {
	    packet.endpoint = this.name;
	    this.socket.packet(packet);
	    this.flags = {};
	    return this;
	  };

	  /**
	   * Sends a message
	   *
	   * @api public
	   */

	  SocketNamespace.prototype.send = function (data, fn) {
	    var packet = {
	        type: this.flags.json ? 'json' : 'message'
	      , data: data
	    };

	    if ('function' == typeof fn) {
	      packet.id = ++this.ackPackets;
	      packet.ack = true;
	      this.acks[packet.id] = fn;
	    }

	    return this.packet(packet);
	  };

	  /**
	   * Emits an event
	   *
	   * @api public
	   */

	  SocketNamespace.prototype.emit = function (name) {
	    var args = Array.prototype.slice.call(arguments, 1)
	      , lastArg = args[args.length - 1]
	      , packet = {
	            type: 'event'
	          , name: name
	        };

	    if ('function' == typeof lastArg) {
	      packet.id = ++this.ackPackets;
	      packet.ack = 'data';
	      this.acks[packet.id] = lastArg;
	      args = args.slice(0, args.length - 1);
	    }

	    packet.args = args;

	    return this.packet(packet);
	  };

	  /**
	   * Disconnects the namespace
	   *
	   * @api private
	   */

	  SocketNamespace.prototype.disconnect = function () {
	    if (this.name === '') {
	      this.socket.disconnect();
	    } else {
	      this.packet({ type: 'disconnect' });
	      this.$emit('disconnect');
	    }

	    return this;
	  };

	  /**
	   * Handles a packet
	   *
	   * @api private
	   */

	  SocketNamespace.prototype.onPacket = function (packet) {
	    var self = this;

	    function ack () {
	      self.packet({
	          type: 'ack'
	        , args: io.util.toArray(arguments)
	        , ackId: packet.id
	      });
	    };

	    switch (packet.type) {
	      case 'connect':
	        this.$emit('connect');
	        break;

	      case 'disconnect':
	        if (this.name === '') {
	          this.socket.onDisconnect(packet.reason || 'booted');
	        } else {
	          this.$emit('disconnect', packet.reason);
	        }
	        break;

	      case 'message':
	      case 'json':
	        var params = ['message', packet.data];

	        if (packet.ack == 'data') {
	          params.push(ack);
	        } else if (packet.ack) {
	          this.packet({ type: 'ack', ackId: packet.id });
	        }

	        this.$emit.apply(this, params);
	        break;

	      case 'event':
	        var params = [packet.name].concat(packet.args);

	        if (packet.ack == 'data')
	          params.push(ack);

	        this.$emit.apply(this, params);
	        break;

	      case 'ack':
	        if (this.acks[packet.ackId]) {
	          this.acks[packet.ackId].apply(this, packet.args);
	          delete this.acks[packet.ackId];
	        }
	        break;

	      case 'error':
	        if (packet.advice){
	          this.socket.onError(packet);
	        } else {
	          if (packet.reason == 'unauthorized') {
	            this.$emit('connect_failed', packet.reason);
	          } else {
	            this.$emit('error', packet.reason);
	          }
	        }
	        break;
	    }
	  };

	  /**
	   * Flag interface.
	   *
	   * @api private
	   */

	  function Flag (nsp, name) {
	    this.namespace = nsp;
	    this.name = name;
	  };

	  /**
	   * Send a message
	   *
	   * @api public
	   */

	  Flag.prototype.send = function () {
	    this.namespace.flags[this.name] = true;
	    this.namespace.send.apply(this.namespace, arguments);
	  };

	  /**
	   * Emit an event
	   *
	   * @api public
	   */

	  Flag.prototype.emit = function () {
	    this.namespace.flags[this.name] = true;
	    this.namespace.emit.apply(this.namespace, arguments);
	  };

	})(
	    'undefined' != typeof io ? io : module.exports
	  , 'undefined' != typeof io ? io : module.parent.exports
	);

	/**
	 * socket.io WebSocket
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	(function (exports, io, global) {

	  /**
	   * Expose constructor.
	   */

	  exports.websocket = WS;

	  /**
	   * The WebSocket transport uses the HTML5 WebSocket API to establish an
	   * persistent connection with the Socket.IO server. This transport will also
	   * be inherited by the FlashSocket fallback as it provides a API compatible
	   * polyfill for the WebSockets.
	   *
	   * @constructor
	   * @extends {io.Transport}
	   * @api public
	   */

	  function WS (socket) {
	    io.Transport.apply(this, arguments);
	  };

	  /**
	   * Inherits from Transport.
	   */

	  io.util.inherit(WS, io.Transport);

	  /**
	   * Transport name
	   *
	   * @api public
	   */

	  WS.prototype.name = 'websocket';

	  /**
	   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach
	   * all the appropriate listeners to handle the responses from the server.
	   *
	   * @returns {Transport}
	   * @api public
	   */

	  WS.prototype.open = function () {
	    var query = io.util.query(this.socket.options.query)
	      , self = this
	      , Socket


	    if (!Socket) {
	      Socket = global.MozWebSocket || global.WebSocket;
	    }

	    this.websocket = new Socket(this.prepareUrl() + query);

	    this.websocket.onopen = function () {
	      self.onOpen();
	      self.socket.setBuffer(false);
	    };
	    this.websocket.onmessage = function (ev) {
	      self.onData(ev.data);
	    };
	    this.websocket.onclose = function () {
	      // 先 setBuffer, 然后 onClose, 在 onClose 里面可能会再次调用 setBuffer @hzzhangyingya
	      self.socket.setBuffer(true);
	      self.onClose();
	    };
	    this.websocket.onerror = function (e) {
	      self.onError(e);
	    };

	    return this;
	  };

	  /**
	   * Send a message to the Socket.IO server. The message will automatically be
	   * encoded in the correct message format.
	   *
	   * @returns {Transport}
	   * @api public
	   */

	  // Do to a bug in the current IDevices browser, we need to wrap the send in a
	  // setTimeout, when they resume from sleeping the browser will crash if
	  // we don't allow the browser time to detect the socket has been closed
	  if (io.util.ua.iDevice) {
	    WS.prototype.send = function (data) {
	      var self = this;
	      setTimeout(function() {
	         self.websocket.send(data);
	      },0);
	      return this;
	    };
	  } else {
	    WS.prototype.send = function (data) {
	      this.websocket.send(data);
	      return this;
	    };
	  }

	  /**
	   * Payload
	   *
	   * @api private
	   */

	  WS.prototype.payload = function (arr) {
	    for (var i = 0, l = arr.length; i < l; i++) {
	      this.packet(arr[i]);
	    }
	    return this;
	  };

	  /**
	   * Disconnect the established `WebSocket` connection.
	   *
	   * @returns {Transport}
	   * @api public
	   */

	  WS.prototype.close = function () {
	    this.websocket.close();
	    return this;
	  };

	  /**
	   * Handle the errors that `WebSocket` might be giving when we
	   * are attempting to connect or send messages.
	   *
	   * @param {Error} e The error.
	   * @api private
	   */

	  WS.prototype.onError = function (e) {
	    this.socket.onError(e);
	  };

	  /**
	   * Returns the appropriate scheme for the URI generation.
	   *
	   * @api private
	   */
	  WS.prototype.scheme = function () {
	    return this.socket.options.secure ? 'wss' : 'ws';
	  };

	  /**
	   * Checks if the browser has support for native `WebSockets` and that
	   * it's not the polyfill created for the FlashSocket transport.
	   *
	   * @return {Boolean}
	   * @api public
	   */

	  WS.check = function () {
	    return ('WebSocket' in global && !('__addTask' in WebSocket))
	          || 'MozWebSocket' in global;
	  };

	  /**
	   * Check if the `WebSocket` transport support cross domain communications.
	   *
	   * @returns {Boolean}
	   * @api public
	   */

	  WS.xdomainCheck = function () {
	    return true;
	  };

	  /**
	   * Add the transport to your public io.transports array.
	   *
	   * @api private
	   */

	  io.transports.push('websocket');

	})(
	    'undefined' != typeof io ? io.Transport : module.exports
	  , 'undefined' != typeof io ? io : module.parent.exports
	  , window
	);

	/**
	 * socket.io Flashsocket
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	(function (exports, io) {

	  /**
	   * Expose constructor.
	   */

	  exports.flashsocket = Flashsocket;

	  /**
	   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket
	   * specification. It uses a .swf file to communicate with the server. If you want
	   * to serve the .swf file from a other server than where the Socket.IO script is
	   * coming from you need to use the insecure version of the .swf. More information
	   * about this can be found on the github page.
	   *
	   * @constructor
	   * @extends {io.Transport.websocket}
	   * @api public
	   */

	  function Flashsocket () {
	    io.Transport.websocket.apply(this, arguments);
	  };

	  /**
	   * Inherits from Transport.
	   */

	  io.util.inherit(Flashsocket, io.Transport.websocket);

	  /**
	   * Transport name
	   *
	   * @api public
	   */

	  Flashsocket.prototype.name = 'flashsocket';

	  /**
	   * Disconnect the established `FlashSocket` connection. This is done by adding a
	   * new task to the FlashSocket. The rest will be handled off by the `WebSocket`
	   * transport.
	   *
	   * @returns {Transport}
	   * @api public
	   */

	  Flashsocket.prototype.open = function () {
	    var self = this
	      , args = arguments;

	    WebSocket.__addTask(function () {
	      io.Transport.websocket.prototype.open.apply(self, args);
	    });
	    return this;
	  };

	  /**
	   * Sends a message to the Socket.IO server. This is done by adding a new
	   * task to the FlashSocket. The rest will be handled off by the `WebSocket`
	   * transport.
	   *
	   * @returns {Transport}
	   * @api public
	   */

	  Flashsocket.prototype.send = function () {
	    var self = this, args = arguments;
	    WebSocket.__addTask(function () {
	      io.Transport.websocket.prototype.send.apply(self, args);
	    });
	    return this;
	  };

	  /**
	   * Disconnects the established `FlashSocket` connection.
	   *
	   * @returns {Transport}
	   * @api public
	   */

	  Flashsocket.prototype.close = function () {
	    WebSocket.__tasks.length = 0;
	    io.Transport.websocket.prototype.close.call(this);
	    return this;
	  };

	  /**
	   * The WebSocket fall back needs to append the flash container to the body
	   * element, so we need to make sure we have access to it. Or defer the call
	   * until we are sure there is a body element.
	   *
	   * @param {Socket} socket The socket instance that needs a transport
	   * @param {Function} fn The callback
	   * @api private
	   */

	  Flashsocket.prototype.ready = function (socket, fn) {
	    function init () {
	      var options = socket.options
	        , port = options['flash policy port']
	        , path = [
	              'http' + (options.secure ? 's' : '') + ':/'
	            , options.host + ':' + options.port
	            , options.resource
	            , 'static/flashsocket'
	            , 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'
	          ];

	      // Only start downloading the swf file when the checked that this browser
	      // actually supports it
	      if (!Flashsocket.loaded) {
	        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {
	          // Set the correct file based on the XDomain settings
	          WEB_SOCKET_SWF_LOCATION = path.join('/');
	        }

	        if (port !== 843) {
	          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);
	        }

	        WebSocket.__initialize();
	        Flashsocket.loaded = true;
	      }

	      fn.call(self);
	    }

	    var self = this;
	    if (document.body) return init();

	    io.util.load(init);
	  };

	  /**
	   * Check if the FlashSocket transport is supported as it requires that the Adobe
	   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if
	   * the polyfill is correctly loaded.
	   *
	   * @returns {Boolean}
	   * @api public
	   */

	  Flashsocket.check = function () {
	    if (
	        typeof WebSocket == 'undefined'
	      || !('__initialize' in WebSocket) || !swfobject
	    ) return false;

	    return swfobject.getFlashPlayerVersion().major >= 10;
	  };

	  /**
	   * Check if the FlashSocket transport can be used as cross domain / cross origin
	   * transport. Because we can't see which type (secure or insecure) of .swf is used
	   * we will just return true.
	   *
	   * @returns {Boolean}
	   * @api public
	   */

	  Flashsocket.xdomainCheck = function () {
	    return true;
	  };

	  /**
	   * Disable AUTO_INITIALIZATION
	   */

	  if (typeof window != 'undefined') {
	    window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;
	  }

	  /**
	   * Add the transport to your public io.transports array.
	   *
	   * @api private
	   */

	  io.transports.push('flashsocket');
	})(
	    'undefined' != typeof io ? io.Transport : module.exports
	  , 'undefined' != typeof io ? io : module.parent.exports
	);
	/*  SWFObject v2.2 <http://code.google.com/p/swfobject/>
	  is released under the MIT License <http://www.opensource.org/licenses/mit-license.php>
	*/
	if ('undefined' != typeof window && 'undefined' != typeof window.document) {
	var swfobject=function(){var D="undefined",r="object",S="Shockwave Flash",W="ShockwaveFlash.ShockwaveFlash",q="application/x-shockwave-flash",R="SWFObjectExprInst",x="onreadystatechange",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):false,X=!+"\v1",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\s+(\S+\s+\S+$)/,"$1");ag[0]=parseInt(ab.replace(/^(.*)\..*$/,"$1"),10);ag[1]=parseInt(ab.replace(/^.*\.(.*)\s.*$/,"$1"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0}}else{if(typeof O[(['Active'].concat('Object').join('X'))]!=D){try{var ad=new window[(['Active'].concat('Object').join('X'))](W);if(ad){ab=ad.GetVariable("$version");if(ab){X=true;ab=ab.split(" ")[1].split(",");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState=="complete")||(typeof j.readyState==D&&(j.getElementsByTagName("body")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener("DOMContentLoaded",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState=="complete"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll("left")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName("body")[0].appendChild(C("span"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener("load",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener("load",Y,false)}else{if(typeof O.attachEvent!=D){i(O,"onload",Y)}else{if(typeof O.onload=="function"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName("body")[0];var aa=C(r);aa.setAttribute("type",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable("$version");if(ab){ab=ab.split(" ")[1].split(",");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute("width")||"0";ai.height=ae.getAttribute("height")||"0";if(ae.getAttribute("class")){ai.styleclass=ae.getAttribute("class")}if(ae.getAttribute("align")){ai.align=ae.getAttribute("align")}var ah={};var X=ae.getElementsByTagName("param");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute("name").toLowerCase()!="movie"){ah[X[ad].getAttribute("name")]=X[ad].getAttribute("value")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName=="OBJECT"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F("6.0.65")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName=="OBJECT"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width="310"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height="137"}j.title=j.title.slice(0,47)+" - Flash Player Installation";var ad=M.ie&&M.win?(['Active'].concat('').join('X')):"PlugIn",ac="MMredirectURL="+O.location.toString().replace(/&/g,"%26")+"&MMplayerType="+ad+"&MMdoctitle="+j.title;if(typeof ab.flashvars!=D){ab.flashvars+="&"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C("div");X+="SWFObjectNew";Y.setAttribute("id",X);ae.parentNode.insertBefore(Y,ae);ae.style.display="none";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C("div");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display="none";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C("div");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName=="PARAM")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah="";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()=="data"){ag.movie=ai[ae]}else{if(ae.toLowerCase()=="styleclass"){ah+=' class="'+ai[ae]+'"'}else{if(ae.toLowerCase()!="classid"){ah+=" "+ae+'="'+ai[ae]+'"'}}}}}var af="";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name="'+ad+'" value="'+ag[ad]+'" />'}}aa.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+ah+">"+af+"</object>";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute("type",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()=="styleclass"){Z.setAttribute("class",ai[ac])}else{if(ac.toLowerCase()!="classid"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!="movie"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C("param");aa.setAttribute("name",X);aa.setAttribute("value",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName=="OBJECT"){if(M.ie&&M.win){X.style.display="none";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]=="function"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(".");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName("head")[0];if(!aa){return}var X=(ad&&typeof ad=="string")?ad:"screen";if(ab){n=null;G=null}if(!n||G!=X){var Z=C("style");Z.setAttribute("type","text/css");Z.setAttribute("media",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+" {"+Y+"}"))}}}function w(Z,X){if(!m){return}var Y=X?"visible":"hidden";if(J&&c(Z)){c(Z).style.visibility=Y}else{v("#"+Z,"visibility:"+Y)}}function L(Y){var Z=/[\\\"<>\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent("onunload",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+="";ag+="";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+="&"+ai+"="+Z[ai]}else{am.flashvars=ai+"="+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\?/.test(Z)){Z=Z.split("?")[1]}if(aa==null){return L(Z)}var Y=Z.split("&");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf("="))==aa){return L(Y[X].substring((Y[X].indexOf("=")+1)))}}}return""},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display="block"}}if(E){E(B)}}a=false}}}}();
	}
	// Copyright: Hiroshi Ichikawa <http://gimite.net/en/>
	// License: New BSD License
	// Reference: http://dev.w3.org/html5/websockets/
	// Reference: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol

	(function() {

	  if ('undefined' == typeof window || window.WebSocket) return;

	  var console = window.console;
	  if (!console || !console.log || !console.error) {
	    console = {log: function(){ }, error: function(){ }};
	  }

	  if (!swfobject.hasFlashPlayerVersion("10.0.0")) {
	    console.error("Flash Player >= 10.0.0 is required.");
	    return;
	  }
	  if (location.protocol == "file:") {
	    console.error(
	      "WARNING: web-socket-js doesn't work in file:///... URL " +
	      "unless you set Flash Security Settings properly. " +
	      "Open the page via Web server i.e. http://...");
	  }

	  /**
	   * This class represents a faux web socket.
	   * @param {string} url
	   * @param {array or string} protocols
	   * @param {string} proxyHost
	   * @param {int} proxyPort
	   * @param {string} headers
	   */
	  WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {
	    var self = this;
	    self.__id = WebSocket.__nextId++;
	    WebSocket.__instances[self.__id] = self;
	    self.readyState = WebSocket.CONNECTING;
	    self.bufferedAmount = 0;
	    self.__events = {};
	    if (!protocols) {
	      protocols = [];
	    } else if (typeof protocols == "string") {
	      protocols = [protocols];
	    }
	    // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.
	    // Otherwise, when onopen fires immediately, onopen is called before it is set.
	    setTimeout(function() {
	      WebSocket.__addTask(function() {
	        WebSocket.__flash.create(
	            self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);
	      });
	    }, 0);
	  };

	  /**
	   * Send data to the web socket.
	   * @param {string} data  The data to send to the socket.
	   * @return {boolean}  True for success, false for failure.
	   */
	  WebSocket.prototype.send = function(data) {
	    if (this.readyState == WebSocket.CONNECTING) {
	      throw "INVALID_STATE_ERR: Web Socket connection has not been established";
	    }
	    // We use encodeURIComponent() here, because FABridge doesn't work if
	    // the argument includes some characters. We don't use escape() here
	    // because of this:
	    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions
	    // But it looks decodeURIComponent(encodeURIComponent(s)) doesn't
	    // preserve all Unicode characters either e.g. "\uffff" in Firefox.
	    // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require
	    // additional testing.
	    var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));
	    if (result < 0) { // success
	      return true;
	    } else {
	      this.bufferedAmount += result;
	      return false;
	    }
	  };

	  /**
	   * Close this web socket gracefully.
	   */
	  WebSocket.prototype.close = function() {
	    if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {
	      return;
	    }
	    this.readyState = WebSocket.CLOSING;
	    WebSocket.__flash.close(this.__id);
	  };

	  /**
	   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
	   *
	   * @param {string} type
	   * @param {function} listener
	   * @param {boolean} useCapture
	   * @return void
	   */
	  WebSocket.prototype.addEventListener = function(type, listener, useCapture) {
	    if (!(type in this.__events)) {
	      this.__events[type] = [];
	    }
	    this.__events[type].push(listener);
	  };

	  /**
	   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
	   *
	   * @param {string} type
	   * @param {function} listener
	   * @param {boolean} useCapture
	   * @return void
	   */
	  WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {
	    if (!(type in this.__events)) return;
	    var events = this.__events[type];
	    for (var i = events.length - 1; i >= 0; --i) {
	      if (events[i] === listener) {
	        events.splice(i, 1);
	        break;
	      }
	    }
	  };

	  /**
	   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
	   *
	   * @param {Event} event
	   * @return void
	   */
	  WebSocket.prototype.dispatchEvent = function(event) {
	    var events = this.__events[event.type] || [];
	    for (var i = 0; i < events.length; ++i) {
	      events[i](event);
	    }
	    var handler = this["on" + event.type];
	    if (handler) handler(event);
	  };

	  /**
	   * Handles an event from Flash.
	   * @param {Object} flashEvent
	   */
	  WebSocket.prototype.__handleEvent = function(flashEvent) {
	    if ("readyState" in flashEvent) {
	      this.readyState = flashEvent.readyState;
	    }
	    if ("protocol" in flashEvent) {
	      this.protocol = flashEvent.protocol;
	    }

	    var jsEvent;
	    if (flashEvent.type == "open" || flashEvent.type == "error") {
	      jsEvent = this.__createSimpleEvent(flashEvent.type);
	    } else if (flashEvent.type == "close") {
	      // TODO implement jsEvent.wasClean
	      jsEvent = this.__createSimpleEvent("close");
	    } else if (flashEvent.type == "message") {
	      var data = decodeURIComponent(flashEvent.message);
	      jsEvent = this.__createMessageEvent("message", data);
	    } else {
	      throw "unknown event type: " + flashEvent.type;
	    }

	    this.dispatchEvent(jsEvent);
	  };

	  WebSocket.prototype.__createSimpleEvent = function(type) {
	    if (document.createEvent && window.Event) {
	      var event = document.createEvent("Event");
	      event.initEvent(type, false, false);
	      return event;
	    } else {
	      return {type: type, bubbles: false, cancelable: false};
	    }
	  };

	  WebSocket.prototype.__createMessageEvent = function(type, data) {
	    if (document.createEvent && window.MessageEvent && !window.opera) {
	      var event = document.createEvent("MessageEvent");
	      event.initMessageEvent("message", false, false, data, null, null, window, null);
	      return event;
	    } else {
	      // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.
	      return {type: type, data: data, bubbles: false, cancelable: false};
	    }
	  };

	  /**
	   * Define the WebSocket readyState enumeration.
	   */
	  WebSocket.CONNECTING = 0;
	  WebSocket.OPEN = 1;
	  WebSocket.CLOSING = 2;
	  WebSocket.CLOSED = 3;

	  WebSocket.__flash = null;
	  WebSocket.__instances = {};
	  WebSocket.__tasks = [];
	  WebSocket.__nextId = 0;

	  /**
	   * Load a new flash security policy file.
	   * @param {string} url
	   */
	  WebSocket.loadFlashPolicyFile = function(url){
	    WebSocket.__addTask(function() {
	      WebSocket.__flash.loadManualPolicyFile(url);
	    });
	  };

	  /**
	   * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.
	   */
	  WebSocket.__initialize = function() {
	    if (WebSocket.__flash) return;

	    if (WebSocket.__swfLocation) {
	      // For backword compatibility.
	      window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;
	    }
	    if (!window.WEB_SOCKET_SWF_LOCATION) {
	      console.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");
	      return;
	    }
	    var container = document.createElement("div");
	    container.id = "webSocketContainer";
	    // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents
	    // Flash from loading at least in IE. So we move it out of the screen at (-100, -100).
	    // But this even doesn't work with Flash Lite (e.g. in Droid Incredible). So with Flash
	    // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is
	    // the best we can do as far as we know now.
	    container.style.position = "absolute";
	    if (WebSocket.__isFlashLite()) {
	      container.style.left = "0px";
	      container.style.top = "0px";
	    } else {
	      container.style.left = "-100px";
	      container.style.top = "-100px";
	    }
	    var holder = document.createElement("div");
	    holder.id = "webSocketFlash";
	    container.appendChild(holder);
	    document.body.appendChild(container);
	    // See this article for hasPriority:
	    // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html
	    swfobject.embedSWF(
	      WEB_SOCKET_SWF_LOCATION,
	      "webSocketFlash",
	      "1" /* width */,
	      "1" /* height */,
	      "10.0.0" /* SWF version */,
	      null,
	      null,
	      {hasPriority: true, swliveconnect : true, allowScriptAccess: "always"},
	      null,
	      function(e) {
	        if (!e.success) {
	          console.error("[WebSocket] swfobject.embedSWF failed");
	        }
	      });
	  };

	  /**
	   * Called by Flash to notify JS that it's fully loaded and ready
	   * for communication.
	   */
	  WebSocket.__onFlashInitialized = function() {
	    // We need to set a timeout here to avoid round-trip calls
	    // to flash during the initialization process.
	    setTimeout(function() {
	      WebSocket.__flash = document.getElementById("webSocketFlash");
	      WebSocket.__flash.setCallerUrl(location.href);
	      WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
	      for (var i = 0; i < WebSocket.__tasks.length; ++i) {
	        WebSocket.__tasks[i]();
	      }
	      WebSocket.__tasks = [];
	    }, 0);
	  };

	  /**
	   * Called by Flash to notify WebSockets events are fired.
	   */
	  WebSocket.__onFlashEvent = function() {
	    setTimeout(function() {
	      try {
	        // Gets events using receiveEvents() instead of getting it from event object
	        // of Flash event. This is to make sure to keep message order.
	        // It seems sometimes Flash events don't arrive in the same order as they are sent.
	        var events = WebSocket.__flash.receiveEvents();
	        for (var i = 0; i < events.length; ++i) {
	          WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);
	        }
	      } catch (e) {
	        console.error(e);
	      }
	    }, 0);
	    return true;
	  };

	  var getNowStr = function () {
	    var formatTimeUnit = function(num, count) {
	        count = count || 2;
	        var str = '' + num;
	        while (str.length < count) {
	            str = '0' + str;
	        }
	        return str;
	    };
	    var date = new Date();
	    var dateStr = date.getFullYear() + '-' + formatTimeUnit((date.getMonth()+1)) + '-' + formatTimeUnit(date.getDate()) + ' ' + formatTimeUnit(date.getHours()) + ':' + formatTimeUnit(date.getMinutes()) + ':' + formatTimeUnit(date.getSeconds()) + ':' + formatTimeUnit(date.getMilliseconds(), 3);
	    return dateStr
	  }

	  // Called by Flash.
	  WebSocket.__log = function(message) {
	    console.log(getNowStr(), decodeURIComponent(message));
	  };

	  // Called by Flash.
	  WebSocket.__error = function(message) {
	    console.error(getNowStr(), decodeURIComponent(message));
	  };

	  WebSocket.__addTask = function(task) {
	    if (WebSocket.__flash) {
	      task();
	    } else {
	      WebSocket.__tasks.push(task);
	    }
	  };

	  /**
	   * Test if the browser is running flash lite.
	   * @return {boolean} True if flash lite is running, false otherwise.
	   */
	  WebSocket.__isFlashLite = function() {
	    if (!window.navigator || !window.navigator.mimeTypes) {
	      return false;
	    }
	    var mimeType = window.navigator.mimeTypes["application/x-shockwave-flash"];
	    if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {
	      return false;
	    }
	    return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;
	  };

	  if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {
	    if (window.addEventListener) {
	      window.addEventListener("load", function(){
	        WebSocket.__initialize();
	      }, false);
	    } else {
	      window.attachEvent("onload", function(){
	        WebSocket.__initialize();
	      });
	    }
	  }

	})();

	/**
	 * socket.io XHR
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	(function (exports, io, global) {

	  /**
	   * Expose constructor.
	   *
	   * @api public
	   */

	  exports.XHR = XHR;

	  /**
	   * XHR constructor
	   *
	   * @costructor
	   * @api public
	   */

	  function XHR (socket) {
	    if (!socket) return;

	    io.Transport.apply(this, arguments);
	    this.sendBuffer = [];
	  };

	  /**
	   * Inherits from Transport.
	   */

	  io.util.inherit(XHR, io.Transport);

	  /**
	   * Establish a connection
	   *
	   * @returns {Transport}
	   * @api public
	   */

	  XHR.prototype.open = function () {
	    this.socket.setBuffer(false);
	    this.onOpen();
	    this.get();

	    // we need to make sure the request succeeds since we have no indication
	    // whether the request opened or not until it succeeded.
	    this.setCloseTimeout();

	    return this;
	  };

	  /**
	   * Check if we need to send data to the Socket.IO server, if we have data in our
	   * buffer we encode it and forward it to the `post` method.
	   *
	   * @api private
	   */

	  XHR.prototype.payload = function (payload) {
	    var msgs = [];

	    for (var i = 0, l = payload.length; i < l; i++) {
	      msgs.push(io.parser.encodePacket(payload[i]));
	    }

	    this.send(io.parser.encodePayload(msgs));
	  };

	  /**
	   * Send data to the Socket.IO server.
	   *
	   * @param data The message
	   * @returns {Transport}
	   * @api public
	   */

	  XHR.prototype.send = function (data) {
	    this.post(data);
	    return this;
	  };

	  /**
	   * Posts a encoded message to the Socket.IO server.
	   *
	   * @param {String} data A encoded message.
	   * @api private
	   */

	  function empty () { };

	  XHR.prototype.post = function (data) {
	    var self = this;
	    this.socket.setBuffer(true);

	    function stateChange () {
	      if (this.readyState == 4) {
	        this.onreadystatechange = empty;
	        self.posting = false;

	        if (this.status == 200){
	          self.socket.setBuffer(false);
	        } else {
	          self.onClose();
	        }
	      }
	    }

	    function onload () {
	      this.onload = empty;
	      self.socket.setBuffer(false);
	    };

	    this.sendXHR = this.request('POST');

	    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {
	      this.sendXHR.onload = this.sendXHR.onerror = onload;
	    } else {
	      this.sendXHR.onreadystatechange = stateChange;
	    }

	    this.sendXHR.send(data);
	  };

	  /**
	   * Disconnects the established `XHR` connection.
	   *
	   * @returns {Transport}
	   * @api public
	   */

	  XHR.prototype.close = function () {
	    this.onClose();
	    return this;
	  };

	  /**
	   * Generates a configured XHR request
	   *
	   * @param {String} url The url that needs to be requested.
	   * @param {String} method The method the request should use.
	   * @returns {XMLHttpRequest}
	   * @api private
	   */

	  XHR.prototype.request = function (method) {
	    var req = io.util.request(this.socket.isXDomain())
	      , query = io.util.query(this.socket.options.query, 't=' + +new Date);

	    req.open(method || 'GET', this.prepareUrl() + query, true);

	    if (method == 'POST') {
	      try {
	        if (req.setRequestHeader) {
	          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        } else {
	          // XDomainRequest
	          req.contentType = 'text/plain';
	        }
	      } catch (e) {}
	    }

	    return req;
	  };

	  /**
	   * Returns the scheme to use for the transport URLs.
	   *
	   * @api private
	   */

	  XHR.prototype.scheme = function () {
	    return this.socket.options.secure ? 'https' : 'http';
	  };

	  /**
	   * Check if the XHR transports are supported
	   *
	   * @param {Boolean} xdomain Check if we support cross domain requests.
	   * @returns {Boolean}
	   * @api public
	   */

	  XHR.check = function (socket, xdomain) {
	    try {
	      var request = io.util.request(xdomain),
	          usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),
	          socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),
	          isXProtocol = (global.location && socketProtocol != global.location.protocol);
	      if (request && !(usesXDomReq && isXProtocol)) {
	        return true;
	      }
	    } catch(e) {}

	    return false;
	  };

	  /**
	   * Check if the XHR transport supports cross domain requests.
	   *
	   * @returns {Boolean}
	   * @api public
	   */

	  XHR.xdomainCheck = function (socket) {
	    return XHR.check(socket, true);
	  };

	})(
	    'undefined' != typeof io ? io.Transport : module.exports
	  , 'undefined' != typeof io ? io : module.parent.exports
	  , window
	);
	/**
	 * socket.io HTMLFile
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	(function (exports, io) {

	  /**
	   * Expose constructor.
	   */

	  exports.htmlfile = HTMLFile;

	  /**
	   * The HTMLFile transport creates a `forever iframe` based transport
	   * for Internet Explorer. Regular forever iframe implementations will
	   * continuously trigger the browsers buzy indicators. If the forever iframe
	   * is created inside a `htmlfile` these indicators will not be trigged.
	   *
	   * @constructor
	   * @extends {io.Transport.XHR}
	   * @api public
	   */

	  function HTMLFile (socket) {
	    io.Transport.XHR.apply(this, arguments);
	  };

	  /**
	   * Inherits from XHR transport.
	   */

	  io.util.inherit(HTMLFile, io.Transport.XHR);

	  /**
	   * Transport name
	   *
	   * @api public
	   */

	  HTMLFile.prototype.name = 'htmlfile';

	  /**
	   * Creates a new Ac...eX `htmlfile` with a forever loading iframe
	   * that can be used to listen to messages. Inside the generated
	   * `htmlfile` a reference will be made to the HTMLFile transport.
	   *
	   * @api private
	   */

	  HTMLFile.prototype.get = function () {
	    this.doc = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
	    this.doc.open();
	    this.doc.write('<html></html>');
	    this.doc.close();
	    this.doc.parentWindow.s = this;

	    var iframeC = this.doc.createElement('div');
	    iframeC.className = 'socketio';

	    this.doc.body.appendChild(iframeC);
	    this.iframe = this.doc.createElement('iframe');

	    iframeC.appendChild(this.iframe);

	    var self = this
	      , query = io.util.query(this.socket.options.query, 't='+ +new Date);

	    this.iframe.src = this.prepareUrl() + query;

	    io.util.on(window, 'unload', function () {
	      self.destroy();
	    });
	  };

	  /**
	   * The Socket.IO server will write script tags inside the forever
	   * iframe, this function will be used as callback for the incoming
	   * information.
	   *
	   * @param {String} data The message
	   * @param {document} doc Reference to the context
	   * @api private
	   */

	  HTMLFile.prototype._ = function (data, doc) {
	    this.onData(data);
	    try {
	      var script = doc.getElementsByTagName('script')[0];
	      script.parentNode.removeChild(script);
	    } catch (e) { }
	  };

	  /**
	   * Destroy the established connection, iframe and `htmlfile`.
	   * And calls the `CollectGarbage` function of Internet Explorer
	   * to release the memory.
	   *
	   * @api private
	   */

	  HTMLFile.prototype.destroy = function () {
	    if (this.iframe){
	      try {
	        this.iframe.src = 'about:blank';
	      } catch(e){}

	      this.doc = null;
	      this.iframe.parentNode.removeChild(this.iframe);
	      this.iframe = null;

	      CollectGarbage();
	    }
	  };

	  /**
	   * Disconnects the established connection.
	   *
	   * @returns {Transport} Chaining.
	   * @api public
	   */

	  HTMLFile.prototype.close = function () {
	    this.destroy();
	    return io.Transport.XHR.prototype.close.call(this);
	  };

	  /**
	   * Checks if the browser supports this transport. The browser
	   * must have an `Ac...eXObject` implementation.
	   *
	   * @return {Boolean}
	   * @api public
	   */

	  HTMLFile.check = function (socket) {
	    if (typeof window != "undefined" && (['Active'].concat('Object').join('X')) in window){
	      try {
	        var a = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
	        return a && io.Transport.XHR.check(socket);
	      } catch(e){}
	    }
	    return false;
	  };

	  /**
	   * Check if cross domain requests are supported.
	   *
	   * @returns {Boolean}
	   * @api public
	   */

	  HTMLFile.xdomainCheck = function () {
	    // we can probably do handling for sub-domains, we should
	    // test that it's cross domain but a subdomain here
	    return false;
	  };

	  /**
	   * Add the transport to your public io.transports array.
	   *
	   * @api private
	   */

	  io.transports.push('htmlfile');

	})(
	    'undefined' != typeof io ? io.Transport : module.exports
	  , 'undefined' != typeof io ? io : module.parent.exports
	);

	/**
	 * socket.io XHRPolling
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	(function (exports, io, global) {

	  /**
	   * Expose constructor.
	   */

	  exports['xhr-polling'] = XHRPolling;

	  /**
	   * The XHR-polling transport uses long polling XHR requests to create a
	   * "persistent" connection with the server.
	   *
	   * @constructor
	   * @api public
	   */

	  function XHRPolling () {
	    io.Transport.XHR.apply(this, arguments);
	  };

	  /**
	   * Inherits from XHR transport.
	   */

	  io.util.inherit(XHRPolling, io.Transport.XHR);

	  /**
	   * Merge the properties from XHR transport
	   */

	  io.util.merge(XHRPolling, io.Transport.XHR);

	  /**
	   * Transport name
	   *
	   * @api public
	   */

	  XHRPolling.prototype.name = 'xhr-polling';

	  /**
	   * Indicates whether heartbeats is enabled for this transport
	   *
	   * @api private
	   */

	  XHRPolling.prototype.heartbeats = function () {
	    return false;
	  };

	  /**
	   * Establish a connection, for iPhone and Android this will be done once the page
	   * is loaded.
	   *
	   * @returns {Transport} Chaining.
	   * @api public
	   */

	  XHRPolling.prototype.open = function () {
	    var self = this;

	    io.Transport.XHR.prototype.open.call(self);
	    return false;
	  };

	  /**
	   * Starts a XHR request to wait for incoming messages.
	   *
	   * @api private
	   */

	  function empty () {};

	  XHRPolling.prototype.get = function () {
	    if (!this.isOpen) return;

	    var self = this;

	    function stateChange () {
	      if (this.readyState == 4) {
	        this.onreadystatechange = empty;

	        if (this.status == 200) {
	          self.onData(this.responseText);
	          self.get();
	        } else {
	          self.onClose();
	        }
	      }
	    };

	    function onload () {
	      this.onload = empty;
	      this.onerror = empty;
	      self.retryCounter = 1;
	      self.onData(this.responseText);
	      self.get();
	    };

	    function onerror () {
	      self.retryCounter ++;
	      if(!self.retryCounter || self.retryCounter > 3) {
	        self.onClose();
	      } else {
	        self.get();
	      }
	    };

	    this.xhr = this.request();

	    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {
	      this.xhr.onload = onload;
	      this.xhr.onerror = onerror;
	    } else {
	      this.xhr.onreadystatechange = stateChange;
	    }

	    this.xhr.send(null);
	  };

	  /**
	   * Handle the unclean close behavior.
	   *
	   * @api private
	   */

	  XHRPolling.prototype.onClose = function () {
	    io.Transport.XHR.prototype.onClose.call(this);

	    if (this.xhr) {
	      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;
	      try {
	        this.xhr.abort();
	      } catch(e){}
	      this.xhr = null;
	    }
	  };

	  /**
	   * Webkit based browsers show a infinit spinner when you start a XHR request
	   * before the browsers onload event is called so we need to defer opening of
	   * the transport until the onload event is called. Wrapping the cb in our
	   * defer method solve this.
	   *
	   * @param {Socket} socket The socket instance that needs a transport
	   * @param {Function} fn The callback
	   * @api private
	   */

	  XHRPolling.prototype.ready = function (socket, fn) {
	    var self = this;

	    io.util.defer(function () {
	      fn.call(self);
	    });
	  };

	  /**
	   * Add the transport to your public io.transports array.
	   *
	   * @api private
	   */

	  io.transports.push('xhr-polling');

	})(
	    'undefined' != typeof io ? io.Transport : module.exports
	  , 'undefined' != typeof io ? io : module.parent.exports
	  , window
	);

	/**
	 * socket.io JSONPPolling
	 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	(function (exports, io, global) {
	  /**
	   * There is a way to hide the loading indicator in Firefox. If you create and
	   * remove a iframe it will stop showing the current loading indicator.
	   * Unfortunately we can't feature detect that and UA sniffing is evil.
	   *
	   * @api private
	   */

	  var indicator = global.document && "MozAppearance" in
	    global.document.documentElement.style;

	  /**
	   * Expose constructor.
	   */

	  exports['jsonp-polling'] = JSONPPolling;

	  /**
	   * The JSONP transport creates an persistent connection by dynamically
	   * inserting a script tag in the page. This script tag will receive the
	   * information of the Socket.IO server. When new information is received
	   * it creates a new script tag for the new data stream.
	   *
	   * @constructor
	   * @extends {io.Transport.xhr-polling}
	   * @api public
	   */

	  function JSONPPolling (socket) {
	    io.Transport['xhr-polling'].apply(this, arguments);

	    this.index = io.j.length;

	    var self = this;

	    io.j.push(function (msg) {
	      self._(msg);
	    });
	  };

	  /**
	   * Inherits from XHR polling transport.
	   */

	  io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);

	  /**
	   * Transport name
	   *
	   * @api public
	   */

	  JSONPPolling.prototype.name = 'jsonp-polling';

	  /**
	   * Posts a encoded message to the Socket.IO server using an iframe.
	   * The iframe is used because script tags can create POST based requests.
	   * The iframe is positioned outside of the view so the user does not
	   * notice it's existence.
	   *
	   * @param {String} data A encoded message.
	   * @api private
	   */

	  JSONPPolling.prototype.post = function (data) {
	    var self = this
	      , query = io.util.query(
	             this.socket.options.query
	          , 't='+ (+new Date) + '&i=' + this.index
	        );

	    if (!this.form) {
	      var form = document.createElement('form')
	        , area = document.createElement('textarea')
	        , id = this.iframeId = 'socketio_iframe_' + this.index
	        , iframe;

	      form.className = 'socketio';
	      form.style.position = 'absolute';
	      form.style.top = '0px';
	      form.style.left = '0px';
	      form.style.display = 'none';
	      form.target = id;
	      form.method = 'POST';
	      form.setAttribute('accept-charset', 'utf-8');
	      area.name = 'd';
	      form.appendChild(area);
	      document.body.appendChild(form);

	      this.form = form;
	      this.area = area;
	    }

	    this.form.action = this.prepareUrl() + query;

	    function complete () {
	      initIframe();
	      self.socket.setBuffer(false);
	    };

	    function initIframe () {
	      if (self.iframe) {
	        self.form.removeChild(self.iframe);
	      }

	      try {
	        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	        iframe = document.createElement('<iframe name="'+ self.iframeId +'">');
	      } catch (e) {
	        iframe = document.createElement('iframe');
	        iframe.name = self.iframeId;
	      }

	      iframe.id = self.iframeId;

	      self.form.appendChild(iframe);
	      self.iframe = iframe;
	    };

	    initIframe();

	    // we temporarily stringify until we figure out how to prevent
	    // browsers from turning `\n` into `\r\n` in form inputs
	    this.area.value = io.JSON.stringify(data);

	    try {
	      this.form.submit();
	    } catch(e) {}

	    if (this.iframe.attachEvent) {
	      iframe.onreadystatechange = function () {
	        if (self.iframe.readyState == 'complete') {
	          complete();
	        }
	      };
	    } else {
	      this.iframe.onload = complete;
	    }

	    this.socket.setBuffer(true);
	  };

	  /**
	   * Creates a new JSONP poll that can be used to listen
	   * for messages from the Socket.IO server.
	   *
	   * @api private
	   */

	  JSONPPolling.prototype.get = function () {
	    var self = this
	      , script = document.createElement('script')
	      , query = io.util.query(
	             this.socket.options.query
	          , 't='+ (+new Date) + '&i=' + this.index
	        );

	    if (this.script) {
	      this.script.parentNode.removeChild(this.script);
	      this.script = null;
	    }

	    script.async = true;
	    script.src = this.prepareUrl() + query;
	    script.onerror = function () {
	      self.onClose();
	    };

	    var insertAt = document.getElementsByTagName('script')[0];
	    insertAt.parentNode.insertBefore(script, insertAt);
	    this.script = script;

	    if (indicator) {
	      setTimeout(function () {
	        var iframe = document.createElement('iframe');
	        document.body.appendChild(iframe);
	        document.body.removeChild(iframe);
	      }, 100);
	    }
	  };

	  /**
	   * Callback function for the incoming message stream from the Socket.IO server.
	   *
	   * @param {String} data The message
	   * @api private
	   */

	  JSONPPolling.prototype._ = function (msg) {
	    this.onData(msg);
	    if (this.isOpen) {
	      this.get();
	    }
	    return this;
	  };

	  /**
	   * The indicator hack only works after onload
	   *
	   * @param {Socket} socket The socket instance that needs a transport
	   * @param {Function} fn The callback
	   * @api private
	   */

	  JSONPPolling.prototype.ready = function (socket, fn) {
	    var self = this;
	    if (!indicator) return fn.call(this);

	    io.util.load(function () {
	      fn.call(self);
	    });
	  };

	  /**
	   * Checks if browser supports this transport.
	   *
	   * @return {Boolean}
	   * @api public
	   */

	  JSONPPolling.check = function () {
	    return 'document' in global;
	  };

	  /**
	   * Check if cross domain requests are supported
	   *
	   * @returns {Boolean}
	   * @api public
	   */

	  JSONPPolling.xdomainCheck = function () {
	    return true;
	  };

	  /**
	   * Add the transport to your public io.transports array.
	   *
	   * @api private
	   */

	  io.transports.push('jsonp-polling');

	})(
	    'undefined' != typeof io ? io.Transport : module.exports
	  , 'undefined' != typeof io ? io : module.parent.exports
	  , window
	);

	if (true) {
	  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return io;
	  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	})();

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)(module)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var notundef = util.notundef;
	var fillPropertyWithDefault = util.fillPropertyWithDefault;

	/**
	 * 群成员类型
	 *
	 * - `'normal'` (普通成员)
	 * - `'owner'` (群主)
	 * - `'manager'` (管理员)
	 *
	 * @memberOf TeamMember
	 * @name type
	 * @readOnly
	 * @enum {String}
	 */
	var typeReverseMap = {
	    0: 'normal',
	    1: 'owner',
	    2: 'manager'
	};

	/**
	 * 群成员
	 *
	 * @constructor
	 * @property {Number}   teamId          群ID
	 * @property {String}   account         帐号
	 * @property {String}   type            {@link TeamMember.type|群成员类型}
	 * @property {String}   nickInTeam      在群里面的昵称
	 * @property {Boolean}  muteTeam        是否关闭此群的消息提醒, `true`表示关闭提醒, 但是SDK仍然会收到这个群的消息, SDK只是记录这个设置, 具体根据这个设置要执行的操作由第三方APP决定
	 * @property {Number}   joinTime        入群时间
	 * @property {Number}   updateTime      更新时间
	 * @property {Boolean}  active          普通群拉人进来的时候, 被拉的人处于未激活状态, 未激活状态下看不到这个群, 当有人说话后自动转为激活状态, 能看到该群
	 * @property {Boolean} mute 是否被禁言
	 * @property {String} custom 第三方扩展字段
	 */
	function TeamMember(options) {
	    var self = this;
	    util.verifyOptions(options, 'teamId');
	    util.verifyParamAtLeastPresentOne(options, 'nickInTeam muteTeam muteNotiType custom');
	    self.teamId = options.teamId;
	    // 当更新自己的昵称时, 不会传`account`
	    if (notundef(options.account)) {
	        self.account = options.account;
	    }
	    if (notundef(options.nickInTeam)) {
	        self.nickInTeam = options.nickInTeam;
	    }
	    if (notundef(options.muteNotiType)) {
	        self.bits = options.muteNotiType;
	    } else if (notundef(options.muteTeam)) {
	        self.bits = 0;
	        if (options.muteTeam) {
	            self.bits += 1 << 0;
	        }
	    }
	    if (notundef(options.mute)) {
	        self.mute = options.mute ? 1 : 0;
	    }
	    if (notundef(options.custom)) {
	        self.custom = '' + options.custom;
	    }
	}

	TeamMember.reverse = function (teamMember) {
	    var obj = util.copy(teamMember);
	    if (notundef(obj.teamId)) {
	        obj.teamId = '' + obj.teamId;
	    }
	    if (notundef(obj.type)) {
	        obj.type = typeReverseMap[obj.type];
	    }
	    if (notundef(obj.active)) {
	        obj.active = +obj.active === 1;
	    }
	    if (notundef(obj.valid)) {
	        obj.valid = +obj.valid === 1;
	    }
	    if (notundef(obj.mute)) {
	        obj.mute = +obj.mute === 1;
	    }
	    if (notundef(obj.joinTime)) {
	        obj.joinTime = +obj.joinTime;
	    }
	    if (notundef(obj.updateTime)) {
	        obj.updateTime = +obj.updateTime;
	    }
	    if (notundef(obj.bits)) {
	        // 需要同时知道其他标志位的值才能正确设置, 目前只有一个标志位所以是没问题
	        var bits = obj.bits;
	        delete obj.bits;
	        obj.muteTeam = !!(bits & 1);
	        obj.muteNotiType = bits;
	    }
	    // 添加 ID
	    if (notundef(obj.teamId) && notundef(obj.account)) {
	        obj.id = TeamMember.genId(obj.teamId, obj.account);
	    }
	    return obj;
	};

	TeamMember.reverseMembers = function (members) {
	    return members.map(function (member) {
	        return TeamMember.reverse(member);
	    });
	};

	/**
	 * 升级数据库后, 有些字段老的记录是没有的, 此方法用于补全这些字段
	 */
	TeamMember.fillProperties = function (teamMember) {
	    var fill1 = fillPropertyWithDefault(teamMember, 'mute', false);
	    var fill2 = fillPropertyWithDefault(teamMember, 'custom', '');
	    return fill1 || fill2;
	};

	TeamMember.genId = function (teamId, account) {
	    return teamId + '-' + account;
	};

	TeamMember.accounts2ids = function (teamId, accounts) {
	    return accounts.map(function (a) {
	        return TeamMember.genId(teamId, a);
	    });
	};

	TeamMember.assembleMembers = function (team, accounts) {
	    if (!util.isArray(accounts)) {
	        accounts = [accounts];
	    }
	    return accounts.map(function (account) {
	        return TeamMember.assembleMember(team, account);
	    });
	};

	TeamMember.assembleMember = function (team, account) {
	    return {
	        id: TeamMember.genId(team.teamId, account),
	        account: account,
	        teamId: team.teamId,
	        type: 'normal',
	        nickInTeam: "",
	        muteTeam: false,
	        mute: false,
	        joinTime: team.memberUpdateTime,
	        updateTime: team.memberUpdateTime,
	        active: true,
	        valid: true
	    };
	};

	TeamMember.assembleOwner = function (team) {
	    var owner = TeamMember.assembleMember(team, team.owner);
	    owner.type = 'owner';
	    return owner;
	};

	module.exports = TeamMember;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(17));
		else if(typeof define === 'function' && define.amd)
			define(["ZoroBase"], factory);
		else if(typeof exports === 'object')
			exports["ZoroAjax"] = factory(require("zoro-base"));
		else
			root["ZoroAjax"] = factory(root["ZoroBase"]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		var ajax = __webpack_require__(1);
		var json = __webpack_require__(11);
		var upload = __webpack_require__(12);
		
		ajax.json = json;
		ajax.upload = upload;
		
		module.exports = ajax;

	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		var util = __webpack_require__(2);
		var ProxyXhr = __webpack_require__(3);
		var ProxyUpload = __webpack_require__(7);
		var ProxyFrame = __webpack_require__(10);
		
		var cache = {};
		var doFilter = util.f;
		
		function getProxyByMode(options) {
		  var mode = options.mode;
		  var Constructor = ProxyXhr;
		  // 如果是 IE 7/8/9 并且跨域, 那么使用 iframe 模式
		  var window = util.getGlobal();
		  if (!window.FormData) {
		    mode = 'iframe';
		  }
		  if (mode === 'iframe') {
		    Constructor = options.upload ? ProxyUpload : ProxyFrame;
		  }
		  return new Constructor(options);
		}
		
		function getProxy(options) {
		  var upload = options.upload = (options.headers || util.o)['Content-Type'] === 'multipart/form-data';
		  var cors = false;
		  try {
		    var origin1 = (location.protocol + '//' + location.host).toLowerCase();
		    var origin2 = util.url2origin(options.url);
		    cors = origin1 !== origin2;
		  } catch (error) {
		    // ignore error in weixin app
		  }
		  options.cors = cors;
		  if (!upload && !cors && !options.mode) {
		    return new ProxyXhr(options);
		  }
		  return getProxyByMode(options);
		}
		
		function clear(sn) {
		  var c = cache[sn];
		  if (!c) {
		    return;
		  }
		  c.req.destroy();
		  delete cache[sn];
		}
		
		function parseExtData(c, data) {
		  data = {
		    data: data
		  };
		  var keys = c.result.headers;
		  if (keys) {
		    data.headers = c.req.header(keys);
		  }
		  return data;
		}
		
		function callback(sn, type, data) {
		  var c = cache[sn];
		  if (!c) {
		    return;
		  }
		  if (type === 'onload' && c.result) {
		    data = parseExtData(c, data);
		  }
		  clear(sn);
		  var event = {
		    type: type,
		    result: data
		  };
		  doFilter(event);
		  if (!event.stopped) {
		    c[type](event.result);
		  }
		}
		
		function onLoad(sn, data) {
		  callback(sn, 'onload', data);
		}
		
		function onError(sn, error) {
		  callback(sn, 'onerror', error);
		}
		
		function mergeUrl(url, data) {
		  var sep = util.genUrlSep(url);
		  data = data || '';
		  if (util.isObject(data)) {
		    data = util.object2query(data);
		  }
		  if (data) {
		    url += sep + data;
		  }
		  return url;
		}
		
		/**
		 * ajax
		 * @param  {String} url     请求地址
		 * @param  {Object} options 配置参数
		 * @property {String} [options.method='GET'] 请求方法, 可选值如下
		 * - 'GET'
		 * - 'POST'
		 * @property {Boolean} [options.sync=false] 是否是同步请求
		 * @property {Object|String} [options.query] 'GET' 请求的请求参数, 会拼接到 url
		 * @property {Object|String} [options.data] 'POST' 请求要发送的数据, 如果是 'GET' 请求, 那么此参数会被拼接到 url
		 * @property {Object} [options.headers] 头信息
		 * @property {Boolean} [options.cookie=false] 是否设置`withCredentials`
		 * @property {Number} [options.timeout=6000] ms, 超时时间, 0 表示不设置超时
		 * @property {String} [options.type='text'] 请求成功时, 返回的数据格式, 可选的值如下
		 * - 'text': 文本
		 * - 'json': 对象
		 * @property {Function} [options.onbeforesend] 发送之前的回调
		 * @property {Function} [options.onload] 请求完成回调函数
		 * @property {Function} [options.onerror] 请求失败回调函数
		 * @property {String} [options.mode='auto'] 跨域或者文件上传所使用的模式
		 * - 'auto': 自动, 高版本使用 HTML5, 低版本使用 iframe
		 * - 'iframe': 全部使用 iframe
		 * @property {Object} [options.result] onload回调时需包含的额外结果, 可选如下
		 * - headers, 字符串或字符串数组, 那么会返回相应的头信息
		 * @return {String}         序列号
		 */
		function ajax(url, options) {
		  options = options || {};
		  // cache callback
		  var sn = util.uniqueID();
		  var c = {
		    result: options.result,
		    onload: options.onload || util.f,
		    onerror: options.onerror || util.f
		  };
		  cache[sn] = c;
		  options.onload = onLoad.bind(null, sn);
		  options.onerror = onError.bind(null, sn);
		  // append query
		  if (options.query) {
		    url = mergeUrl(url, options.query);
		  }
		  // append data for get
		  var method = options.method || '';
		  if ((!method || /get/i.test(method)) && options.data) {
		    url = mergeUrl(url, options.data);
		    options.data = null;
		  }
		  options.url = url;
		  c.req = getProxy(options);
		  return sn;
		}
		
		ajax.filter = function (filter) {
		  if (util.isFunction(filter)) {
		    doFilter = filter;
		  }
		};
		
		ajax.abort = function (sn) {
		  var c = cache[sn];
		  if (c) {
		    c.req.abort();
		  }
		};
		
		module.exports = ajax;

	/***/ },
	/* 2 */
	/***/ function(module, exports) {

		module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		/**
		* @Author: Zhang Yingya(hzzhangyingya) <zyy>
		* @Date:   2016-01-08T16:37:15+08:00
		* @Email:  zyy7259@gmail.com
		* @Last modified by:   zyy
		* @Last modified time: 2016-08-01T14:56:19+08:00
		*/
		
		var util = __webpack_require__(2);
		var pu = __webpack_require__(4);
		var Proxy = __webpack_require__(5);
		
		function ProxyXhr(options) {
		  var self = this;
		  // addListeners
		  if (options.onuploading) {
		    self.on('uploading', options.onuploading);
		  }
		  Proxy.call(self, options);
		}
		
		var sp = Proxy.prototype;
		var pro = ProxyXhr.prototype = Object.create(sp);
		
		pro.doSend = function () {
		  var self = this;
		  var options = self.options;
		  var headers = options.headers;
		  var xhr = self.xhr = new XMLHttpRequest();
		  // add event listener
		  // upload progress
		  if (headers['Content-Type'] === 'multipart/form-data') {
		    delete headers['Content-Type'];
		    xhr.upload.onprogress = self.onProgress.bind(self);
		    xhr.upload.onload = self.onProgress.bind(self);
		    var data = options.data;
		    options.data = new window.FormData();
		    if (data) {
		      pu.getKeys(data, options.putFileAtEnd).forEach(function (key) {
		        var value = data[key];
		        if (value.tagName && value.tagName.toUpperCase() === 'INPUT') {
		          if (value.type === 'file') {
		            [].forEach.call(value.files, function (file) {
		              options.data.append(util.dataset(value, 'name') || value.name || file.name || 'file-' + util.uniqueID(), file);
		            });
		          }
		        } else {
		          options.data.append(key, value);
		        }
		      });
		    }
		  }
		  // state change
		  xhr.onreadystatechange = self.onStateChange.bind(self);
		  // timeout
		  if (options.timeout !== 0) {
		    self.timer = setTimeout(self.onTimeout.bind(self), options.timeout);
		  }
		  // prepare and send
		  xhr.open(options.method, options.url, !options.sync);
		  Object.keys(headers).forEach(function (key) {
		    xhr.setRequestHeader(key, headers[key]);
		  });
		  if (!!options.cookie && 'withCredentials' in xhr) {
		    xhr.withCredentials = true;
		  }
		  xhr.send(options.data);
		  self.afterSend();
		};
		
		pro.onProgress = function (event) {
		  // IE 10很神奇的, 在upload的load事件之后还会再触发一次progress, 并且loaded比total大。。。
		  if (event.lengthComputable && event.loaded <= event.total) {
		    this.emit('uploading', event);
		  }
		};
		
		pro.onStateChange = function () {
		  var self = this;
		  var xhr = self.xhr;
		  if (xhr.readyState === 4) {
		    self.onLoad({
		      status: xhr.status,
		      result: xhr.responseText || ''
		    });
		  }
		};
		
		pro.getResponseHeader = function (key) {
		  var xhr = this.xhr;
		  return !xhr ? '' : xhr.getResponseHeader(key);
		};
		
		pro.destroy = function () {
		  var self = this;
		  // clear timeout
		  clearTimeout(self.timer);
		  // clear request
		  try {
		    self.xhr.onreadystatechange = util.f;
		    self.xhr.abort();
		  } catch (e) {
		    console.error('ignore error ajax destroy,', e);
		  }
		  sp.destroy.call(self);
		};
		
		module.exports = ProxyXhr;

	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		/*
		* @Author: Zhang Yingya(hzzhangyingya)
		* @Date:   2016-06-03 15:07:41
		* @Last Modified by:   Zhang Yingya(hzzhangyingya)
		* @Last Modified time: 2016-06-03 16:13:45
		*/
		
		var u = __webpack_require__(2);
		
		var util = {};
		
		util.isFileInput = function (value) {
		  var window = u.getGlobal();
		  return value.tagName && value.tagName.toUpperCase() === 'INPUT' || window.Blob && value instanceof window.Blob;
		};
		
		/**
		 * 获取所有的 keys
		 * putFileAtEnd 表示将文件对应的 keys 放在最后
		 */
		util.getKeys = function (data, putFileAtEnd) {
		  var keys = Object.keys(data);
		  if (putFileAtEnd) {
		    keys.sort(function (key1, key2) {
		      var value1IsFileInput = util.isFileInput(data[key1]);
		      var value2IsFileInput = util.isFileInput(data[key2]);
		      // 如果两个值相等, 说明都是文件或者都不是文件, 那么顺序不变
		      if (value1IsFileInput === value2IsFileInput) {
		        return 0;
		      } else {
		        return value1IsFileInput ? 1 : -1;
		      }
		    });
		  }
		  return keys;
		};
		
		module.exports = util;

	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		var util = __webpack_require__(2);
		var f = util.f;
		var EventEmitter = __webpack_require__(6);
		
		function Proxy(options) {
		  var self = this;
		  // addListeners
		  if (options.onload) {
		    self.once('load', options.onload);
		  }
		  if (options.onerror) {
		    self.once('error', options.onerror);
		  }
		  if (options.onbeforesend) {
		    self.once('beforesend', options.onbeforesend);
		  }
		  if (options.onaftersend) {
		    self.once('aftersend', options.onaftersend);
		  }
		  // handle options
		  options = self.options = util.fetch({
		    method: 'GET',
		    url: '',
		    sync: false,
		    data: null,
		    headers: {},
		    cookie: false,
		    timeout: 60000,
		    type: 'text',
		    // 文件上传用到的参数
		    form: null,
		    input: null,
		    // 是否将文件放在末尾
		    putFileAtEnd: false,
		    // iframe 模式用到的代理地址
		    proxyUrl: ''
		  }, options);
		  // headers
		  var headers = options.headers;
		  var contentType = 'Content-Type';
		  if (util.notexist(headers[contentType])) {
		    headers[contentType] = 'application/x-www-form-urlencoded';
		  }
		  self.send();
		}
		
		var pro = Proxy.prototype = Object.create(EventEmitter.prototype);
		
		pro.send = function () {
		  var self = this;
		  var options = self.options;
		  setTimeout(function () {
		    try {
		      try {
		        self.emit('beforesend', options);
		      } catch (error) {
		        console.error('ignore error ajax beforesend,', error);
		      }
		      self.doSend();
		    } catch (error) {
		      console.error('ignore error server error,', error);
		      self.onError('serverError', '请求失败:' + error.message);
		    }
		  }, 0);
		};
		
		pro.doSend = f;
		
		pro.afterSend = function () {
		  var self = this;
		  setTimeout(function () {
		    self.emit('aftersend', self.options);
		  }, 0);
		};
		
		pro.onLoad = function (event) {
		  var self = this;
		  var options = self.options;
		  var status = event.status;
		  var result = event.result;
		  // check status
		  if (('' + status).indexOf('2') !== 0) {
		    self.onError('serverError', '服务器返回异常状态', {
		      status: status,
		      result: result
		    });
		    return;
		  }
		  // parse json
		  if (options.type === 'json') {
		    try {
		      result = JSON.parse(result);
		    } catch (e) {
		      console.error('ignore error parse json,', e);
		      self.onError('parseError', result);
		      return;
		    }
		  }
		  // onload
		  self.emit('load', result);
		};
		
		pro.onError = function (code, message, ext) {
		  var obj = util.isObject(ext) ? ext : {};
		  obj.code = code || 'error';
		  obj.message = message || '发生错误';
		  this.emit('error', obj);
		};
		
		pro.onTimeout = function () {
		  this.onError('timeout', '请求超时');
		};
		
		pro.abort = function () {
		  this.onError('abort', '客户端中止');
		};
		
		pro.header = function (key) {
		  var self = this;
		  if (!util.isArray(key)) {
		    return self.getResponseHeader(key || '');
		  }
		  var result = {};
		  key.forEach(function (k) {
		    result[k] = self.header(k);
		  });
		  return result;
		};
		
		pro.getResponseHeader = f;
		
		pro.destroy = f;
		
		module.exports = Proxy;

	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_RESULT__;/*!
		 * EventEmitter v5.1.0 - git.io/ee
		 * Unlicense - http://unlicense.org/
		 * Oliver Caldwell - http://oli.me.uk/
		 * @preserve
		 */
		
		;(function (exports) {
		    'use strict';
		
		    /**
		     * Class for managing events.
		     * Can be extended to provide event functionality in other classes.
		     *
		     * @class EventEmitter Manages event registering and emitting.
		     */
		    function EventEmitter() {}
		
		    // Shortcuts to improve speed and size
		    var proto = EventEmitter.prototype;
		    var originalGlobalValue = exports.EventEmitter;
		
		    /**
		     * Finds the index of the listener for the event in its storage array.
		     *
		     * @param {Function[]} listeners Array of listeners to search through.
		     * @param {Function} listener Method to look for.
		     * @return {Number} Index of the specified listener, -1 if not found
		     * @api private
		     */
		    function indexOfListener(listeners, listener) {
		        var i = listeners.length;
		        while (i--) {
		            if (listeners[i].listener === listener) {
		                return i;
		            }
		        }
		
		        return -1;
		    }
		
		    /**
		     * Alias a method while keeping the context correct, to allow for overwriting of target method.
		     *
		     * @param {String} name The name of the target method.
		     * @return {Function} The aliased method
		     * @api private
		     */
		    function alias(name) {
		        return function aliasClosure() {
		            return this[name].apply(this, arguments);
		        };
		    }
		
		    /**
		     * Returns the listener array for the specified event.
		     * Will initialise the event object and listener arrays if required.
		     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
		     * Each property in the object response is an array of listener functions.
		     *
		     * @param {String|RegExp} evt Name of the event to return the listeners from.
		     * @return {Function[]|Object} All listener functions for the event.
		     */
		    proto.getListeners = function getListeners(evt) {
		        var events = this._getEvents();
		        var response;
		        var key;
		
		        // Return a concatenated array of all matching events if
		        // the selector is a regular expression.
		        if (evt instanceof RegExp) {
		            response = {};
		            for (key in events) {
		                if (events.hasOwnProperty(key) && evt.test(key)) {
		                    response[key] = events[key];
		                }
		            }
		        }
		        else {
		            response = events[evt] || (events[evt] = []);
		        }
		
		        return response;
		    };
		
		    /**
		     * Takes a list of listener objects and flattens it into a list of listener functions.
		     *
		     * @param {Object[]} listeners Raw listener objects.
		     * @return {Function[]} Just the listener functions.
		     */
		    proto.flattenListeners = function flattenListeners(listeners) {
		        var flatListeners = [];
		        var i;
		
		        for (i = 0; i < listeners.length; i += 1) {
		            flatListeners.push(listeners[i].listener);
		        }
		
		        return flatListeners;
		    };
		
		    /**
		     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
		     *
		     * @param {String|RegExp} evt Name of the event to return the listeners from.
		     * @return {Object} All listener functions for an event in an object.
		     */
		    proto.getListenersAsObject = function getListenersAsObject(evt) {
		        var listeners = this.getListeners(evt);
		        var response;
		
		        if (listeners instanceof Array) {
		            response = {};
		            response[evt] = listeners;
		        }
		
		        return response || listeners;
		    };
		
		    function isValidListener (listener) {
		        if (typeof listener === 'function' || listener instanceof RegExp) {
		            return true
		        } else if (listener && typeof listener === 'object') {
		            return isValidListener(listener.listener)
		        } else {
		            return false
		        }
		    }
		
		    /**
		     * Adds a listener function to the specified event.
		     * The listener will not be added if it is a duplicate.
		     * If the listener returns true then it will be removed after it is called.
		     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to attach the listener to.
		     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addListener = function addListener(evt, listener) {
		        if (!isValidListener(listener)) {
		            throw new TypeError('listener must be a function');
		        }
		
		        var listeners = this.getListenersAsObject(evt);
		        var listenerIsWrapped = typeof listener === 'object';
		        var key;
		
		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
		                listeners[key].push(listenerIsWrapped ? listener : {
		                    listener: listener,
		                    once: false
		                });
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of addListener
		     */
		    proto.on = alias('addListener');
		
		    /**
		     * Semi-alias of addListener. It will add a listener that will be
		     * automatically removed after its first execution.
		     *
		     * @param {String|RegExp} evt Name of the event to attach the listener to.
		     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addOnceListener = function addOnceListener(evt, listener) {
		        return this.addListener(evt, {
		            listener: listener,
		            once: true
		        });
		    };
		
		    /**
		     * Alias of addOnceListener.
		     */
		    proto.once = alias('addOnceListener');
		
		    /**
		     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
		     * You need to tell it what event names should be matched by a regex.
		     *
		     * @param {String} evt Name of the event to create.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.defineEvent = function defineEvent(evt) {
		        this.getListeners(evt);
		        return this;
		    };
		
		    /**
		     * Uses defineEvent to define multiple events.
		     *
		     * @param {String[]} evts An array of event names to define.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.defineEvents = function defineEvents(evts) {
		        for (var i = 0; i < evts.length; i += 1) {
		            this.defineEvent(evts[i]);
		        }
		        return this;
		    };
		
		    /**
		     * Removes a listener function from the specified event.
		     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to remove the listener from.
		     * @param {Function} listener Method to remove from the event.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeListener = function removeListener(evt, listener) {
		        var listeners = this.getListenersAsObject(evt);
		        var index;
		        var key;
		
		        for (key in listeners) {
		            if (listeners.hasOwnProperty(key)) {
		                index = indexOfListener(listeners[key], listener);
		
		                if (index !== -1) {
		                    listeners[key].splice(index, 1);
		                }
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of removeListener
		     */
		    proto.off = alias('removeListener');
		
		    /**
		     * Adds listeners in bulk using the manipulateListeners method.
		     * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
		     * You can also pass it a regular expression to add the array of listeners to all events that match it.
		     * Yeah, this function does quite a bit. That's probably a bad thing.
		     *
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to add.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.addListeners = function addListeners(evt, listeners) {
		        // Pass through to manipulateListeners
		        return this.manipulateListeners(false, evt, listeners);
		    };
		
		    /**
		     * Removes listeners in bulk using the manipulateListeners method.
		     * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
		     * You can also pass it an event name and an array of listeners to be removed.
		     * You can also pass it a regular expression to remove the listeners from all events that match it.
		     *
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to remove.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeListeners = function removeListeners(evt, listeners) {
		        // Pass through to manipulateListeners
		        return this.manipulateListeners(true, evt, listeners);
		    };
		
		    /**
		     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
		     * The first argument will determine if the listeners are removed (true) or added (false).
		     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
		     * You can also pass it an event name and an array of listeners to be added/removed.
		     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
		     *
		     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
		     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
		     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		        var i;
		        var value;
		        var single = remove ? this.removeListener : this.addListener;
		        var multiple = remove ? this.removeListeners : this.addListeners;
		
		        // If evt is an object then pass each of its properties to this method
		        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
		            for (i in evt) {
		                if (evt.hasOwnProperty(i) && (value = evt[i])) {
		                    // Pass the single listener straight through to the singular method
		                    if (typeof value === 'function') {
		                        single.call(this, i, value);
		                    }
		                    else {
		                        // Otherwise pass back to the multiple function
		                        multiple.call(this, i, value);
		                    }
		                }
		            }
		        }
		        else {
		            // So evt must be a string
		            // And listeners must be an array of listeners
		            // Loop over it and pass each one to the multiple method
		            i = listeners.length;
		            while (i--) {
		                single.call(this, evt, listeners[i]);
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Removes all listeners from a specified event.
		     * If you do not specify an event then all listeners will be removed.
		     * That means every event will be emptied.
		     * You can also pass a regex to remove all events that match it.
		     *
		     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.removeEvent = function removeEvent(evt) {
		        var type = typeof evt;
		        var events = this._getEvents();
		        var key;
		
		        // Remove different things depending on the state of evt
		        if (type === 'string') {
		            // Remove all listeners for the specified event
		            delete events[evt];
		        }
		        else if (evt instanceof RegExp) {
		            // Remove all events matching the regex.
		            for (key in events) {
		                if (events.hasOwnProperty(key) && evt.test(key)) {
		                    delete events[key];
		                }
		            }
		        }
		        else {
		            // Remove all listeners in all events
		            delete this._events;
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of removeEvent.
		     *
		     * Added to mirror the node API.
		     */
		    proto.removeAllListeners = alias('removeEvent');
		
		    /**
		     * Emits an event of your choice.
		     * When emitted, every listener attached to that event will be executed.
		     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
		     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
		     * So they will not arrive within the array on the other side, they will be separate.
		     * You can also pass a regular expression to emit to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
		     * @param {Array} [args] Optional array of arguments to be passed to each listener.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.emitEvent = function emitEvent(evt, args) {
		        var listenersMap = this.getListenersAsObject(evt);
		        var listeners;
		        var listener;
		        var i;
		        var key;
		        var response;
		
		        for (key in listenersMap) {
		            if (listenersMap.hasOwnProperty(key)) {
		                listeners = listenersMap[key].slice(0);
		
		                for (i = 0; i < listeners.length; i++) {
		                    // If the listener returns true then it shall be removed from the event
		                    // The function is executed either with a basic call or an apply if there is an args array
		                    listener = listeners[i];
		
		                    if (listener.once === true) {
		                        this.removeListener(evt, listener.listener);
		                    }
		
		                    response = listener.listener.apply(this, args || []);
		
		                    if (response === this._getOnceReturnValue()) {
		                        this.removeListener(evt, listener.listener);
		                    }
		                }
		            }
		        }
		
		        return this;
		    };
		
		    /**
		     * Alias of emitEvent
		     */
		    proto.trigger = alias('emitEvent');
		
		    /**
		     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
		     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
		     *
		     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
		     * @param {...*} Optional additional arguments to be passed to each listener.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.emit = function emit(evt) {
		        var args = Array.prototype.slice.call(arguments, 1);
		        return this.emitEvent(evt, args);
		    };
		
		    /**
		     * Sets the current value to check against when executing listeners. If a
		     * listeners return value matches the one set here then it will be removed
		     * after execution. This value defaults to true.
		     *
		     * @param {*} value The new value to check for when executing listeners.
		     * @return {Object} Current instance of EventEmitter for chaining.
		     */
		    proto.setOnceReturnValue = function setOnceReturnValue(value) {
		        this._onceReturnValue = value;
		        return this;
		    };
		
		    /**
		     * Fetches the current value to check against when executing listeners. If
		     * the listeners return value matches this one then it should be removed
		     * automatically. It will return true by default.
		     *
		     * @return {*|Boolean} The current value to check for or the default, true.
		     * @api private
		     */
		    proto._getOnceReturnValue = function _getOnceReturnValue() {
		        if (this.hasOwnProperty('_onceReturnValue')) {
		            return this._onceReturnValue;
		        }
		        else {
		            return true;
		        }
		    };
		
		    /**
		     * Fetches the events object and creates one if required.
		     *
		     * @return {Object} The events storage object.
		     * @api private
		     */
		    proto._getEvents = function _getEvents() {
		        return this._events || (this._events = {});
		    };
		
		    /**
		     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
		     *
		     * @return {Function} Non conflicting EventEmitter class.
		     */
		    EventEmitter.noConflict = function noConflict() {
		        exports.EventEmitter = originalGlobalValue;
		        return EventEmitter;
		    };
		
		    // Expose the class either via AMD, CommonJS or the global object
		    if (true) {
		        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
		            return EventEmitter;
		        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		    }
		    else if (typeof module === 'object' && module.exports){
		        module.exports = EventEmitter;
		    }
		    else {
		        exports.EventEmitter = EventEmitter;
		    }
		}(this || {}));


	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		var util = __webpack_require__(2);
		var pu = __webpack_require__(4);
		var Proxy = __webpack_require__(5);
		var message = __webpack_require__(8);
		
		var flag = 'NEJ-UPLOAD-RESULT:';
		var cache = {};
		
		function ProxyUpload(options) {
		  var self = this;
		  self.init();
		  Proxy.call(self, options);
		}
		
		var sp = Proxy.prototype;
		var pro = ProxyUpload.prototype = Object.create(sp);
		
		pro.init = function () {
		  var init = false;
		  function onMessage(event) {
		    var data = event.data;
		    if (data.indexOf(flag) !== 0) {
		      return;
		    }
		    data = JSON.parse(data.replace(flag, ''));
		    var key = data.key;
		    var proxy = cache[key];
		    if (!proxy) {
		      return;
		    }
		    delete cache[key];
		    data.result = decodeURIComponent(data.result || '');
		    proxy.onLoad(data.result);
		  }
		  function initMessage() {
		    if (!init) {
		      init = true;
		      var window = util.getGlobal();
		      if (window.postMessage) {
		        util.on(window, 'message', onMessage);
		      } else {
		        message.addMsgListener(onMessage);
		        message.startTimer();
		      }
		    }
		  }
		  return function () {
		    initMessage();
		  };
		}();
		
		pro.doSend = function () {
		  var self = this;
		  var options = self.options;
		  var key = self.key = 'zoro-ajax-upload-iframe-' + util.uniqueID();
		  cache[key] = self;
		  // create form
		  var form = self.form = util.html2node('<form style="display:none;"></form>');
		  document.body.appendChild(form);
		  form.target = key;
		  form.method = 'POST';
		  form.enctype = 'multipart/form-data';
		  form.encoding = 'multipart/form-data';
		  var url = options.url;
		  var sep = util.genUrlSep(url);
		  form.action = url + sep + '_proxy_=form';
		  // 处理参数
		  var data = options.data;
		  var files = [];
		  var fileClones = [];
		  if (data) {
		    pu.getKeys(data, options.putFileAtEnd).forEach(function (key) {
		      var value = data[key];
		      if (value.tagName && value.tagName.toUpperCase() === 'INPUT') {
		        if (value.type === 'file') {
		          var file = value;
		          var fileClone = file.cloneNode(true);
		          file.parentNode.insertBefore(fileClone, file);
		          var name = util.dataset(file, 'name');
		          if (name) {
		            file.name = name;
		          }
		          form.appendChild(file);
		          if (util.isFunction(file.setAttribute)) {
		            // Remove the HTML5 form attribute from the input
		            file.setAttribute('form', '');
		            file.removeAttribute('form');
		          }
		          files.push(value);
		          fileClones.push(fileClone);
		        }
		      } else {
		        var input = util.html2node('<input type="hidden"/>');
		        input.name = key;
		        input.value = value;
		        form.appendChild(input);
		      }
		    });
		  }
		  function restoreFiles() {
		    // 将 input 放回原处
		    files.forEach(function (file, index) {
		      var fileClone = fileClones[index];
		      // just in case, fuck ie 8
		      if (fileClone.parentNode) {
		        file.name = fileClone.name;
		        if (util.isFunction(file.setAttribute)) {
		          file.setAttribute('form', fileClone.getAttribute('form'));
		        }
		        fileClone.parentNode.replaceChild(file, fileClone);
		      }
		    });
		  }
		  // create iframe
		  var iframe = self.iframe = util.createIframe({
		    name: key,
		    onload: function onload() {
		      // check aborted
		      if (self.aborted) {
		        restoreFiles();
		        return;
		      }
		      util.on(iframe, 'load', self.checkResult.bind(self));
		      form.submit();
		      restoreFiles();
		      self.afterSend();
		    }
		  });
		};
		
		// same domain upload result check
		pro.checkResult = function () {
		  var self = this;
		  var body;
		  var text;
		  try {
		    body = self.iframe.contentWindow.document.body;
		    text = (body.innerText || body.textContent || '').trim();
		    // if same domain with upload proxy html, use post message path
		    if (text.indexOf(flag) >= 0 || body.innerHTML.indexOf(flag) >= 0) {
		      return;
		    }
		  } catch (error) {
		    console.error('ignore error if not same domain,', error);
		    return;
		  }
		  self.onLoad(text);
		};
		
		pro.onLoad = function (result) {
		  var self = this;
		  sp.onLoad.call(self, {
		    status: 200,
		    result: result
		  });
		  // do the destroy work
		  util.remove(self.form);
		  util.remove(self.iframe);
		  sp.destroy.call(self);
		};
		
		// do nothing when destroy, this will let the iframe load, so we can restoreFiles.
		pro.destroy = function () {
		  util.remove(this.iframe);
		  util.remove(this.form);
		};
		
		pro.abort = function () {
		  var self = this;
		  self.aborted = true;
		  delete cache[self.key];
		  sp.abort.call(self);
		};
		
		module.exports = ProxyUpload;

	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		var _util = __webpack_require__(9);
		
		var _util2 = _interopRequireDefault(_util);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		var window = _util2['default'].getGlobal();
		var message = {};
		
		var _self = window.name || '_parent';
		var _listeners = [];
		var _key = 'MSG|';
		var _queue = [];
		
		// for post message and onmessage event
		message.addMsgListener = function (cb) {
		  _listeners.push(cb);
		};
		
		var onMessage = function onMessage(_event) {
		  for (var i = 0, l = _listeners.length; i < l; i++) {
		    try {
		      _listeners[i].call(null, _event);
		    } catch (e) {}
		  }
		};
		
		var formatOrigin = function () {
		  var _reg = /^([\w]+?:\/\/.*?(?=\/|$))/i;
		  return function (_origin) {
		    _origin = _origin || '';
		    if (_reg.test(_origin)) {
		      return RegExp.$1;
		    }
		    return '*';
		  };
		}();
		
		// 检测window.name变化情况
		var checkWindowName = function checkWindowName() {
		  // check name
		  var _name = unescape(window.name || '').trim();
		  if (!_name || _name.indexOf(_key) !== 0) {
		    return;
		  }
		  window.name = '';
		  // check result
		  var _result = _util2['default'].string2object(_name.replace(_key, ''), '|');
		  var _origin = (_result.origin || '').toLowerCase();
		  // check origin
		  if (!!_origin && _origin !== '*' && location.href.toLowerCase().indexOf(_origin) !== 0) {
		    return;
		  }
		  // dispatch onmessage event
		  onMessage({
		    data: JSON.parse(_result.data || 'null'),
		    source: window.frames[_result.self] || _result.self,
		    origin: formatOrigin(_result.ref || document.referrer)
		  });
		};
		
		var checkNameQueue = function () {
		  var _checklist;
		  var _hasItem = function _hasItem(_list, _item) {
		    for (var i = 0, l = _list.length; i < l; i++) {
		      if (_list[i] === _item) {
		        return !0;
		      }
		    }
		    return !1;
		  };
		  return function () {
		    if (!_queue.length) return;
		    _checklist = [];
		    for (var i = _queue.length - 1, _map; i >= 0; i--) {
		      _map = _queue[i];
		      if (!_hasItem(_checklist, _map.w)) {
		        _checklist.push(_map.w);
		        _queue.splice(i, 1);
		        // set window.name
		        _map.w.name = _map.d;
		      }
		    }
		    _checklist = null;
		  };
		}();
		
		var startTimer = message.startTimer = function () {
		  var flag = false;
		  return function () {
		    if (!flag) {
		      flag = true;
		      if (!window.postMessage) {
		        setInterval(checkNameQueue, 100);
		        setInterval(checkWindowName, 20);
		      }
		    }
		  };
		}();
		
		message.postMessage = function (w) {
		  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		
		  _util2['default'].fillUndef(options, {
		    origin: '*',
		    source: _self
		  });
		  if (!window.postMessage) {
		    startTimer();
		    if (_util2['default'].isObject(options)) {
		      var _result = {};
		      _result.origin = options.origin || '';
		      _result.ref = location.href;
		      _result.self = options.source;
		      _result.data = JSON.stringify(options.data);
		      options = _key + _util2['default'].object2string(_result, '|', !0);
		    }
		    _queue.unshift({
		      w: w,
		      d: escape(options)
		    });
		  } else {
		    var data = options.data;
		    if (!window.FormData) {
		      data = JSON.stringify(data);
		    }
		    w.postMessage(data, options.origin);
		  }
		};
		
		module.exports = message;

	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		module.exports = __webpack_require__(2);

	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		var util = __webpack_require__(2);
		var message = __webpack_require__(8);
		var Proxy = __webpack_require__(5);
		
		var cache = {};
		
		function ProxyFrame(options) {
		  var self = this;
		  self.init();
		  Proxy.call(self, options);
		}
		
		var sp = Proxy.prototype;
		var pro = ProxyFrame.prototype = Object.create(sp);
		
		pro.init = function () {
		  var flag = 'NEJ-AJAX-DATA:';
		  var init = false;
		  function onMessage(event) {
		    var data = event.data;
		    if (data.indexOf(flag) !== 0) {
		      return;
		    }
		    data = JSON.parse(data.replace(flag, ''));
		    var key = data.key;
		    var proxy = cache[key];
		    if (!proxy) {
		      return;
		    }
		    delete cache[key];
		    data.result = decodeURIComponent(data.result || '');
		    proxy.onLoad(data);
		  }
		  function initMessage() {
		    if (!init) {
		      init = true;
		      var window = util.getGlobal();
		      if (window.postMessage) {
		        util.on(window, 'message', onMessage);
		      } else {
		        message.addMsgListener(onMessage);
		      }
		    }
		  }
		  return function () {
		    initMessage();
		  };
		}();
		
		pro.doSend = function () {
		  var self = this;
		  var options = self.options;
		  var origin = util.url2origin(options.url);
		  var proxyUrl = options.proxyUrl || origin + '/res/nej_proxy_frame.html';
		  var frame = cache[proxyUrl];
		  // callback list
		  if (util.isArray(frame)) {
		    frame.push(self.doSend.bind(self, options));
		    return;
		  }
		  // build frame proxy
		  if (!frame) {
		    cache[proxyUrl] = [self.doSend.bind(self, options)];
		    util.createIframe({
		      src: proxyUrl,
		      onload: function onload(event) {
		        var cbs = cache[proxyUrl];
		        cache[proxyUrl] = util.target(event).contentWindow;
		        cbs.forEach(function (cb) {
		          try {
		            cb();
		          } catch (e) {
		            // ignore
		            console.error(e);
		          }
		        });
		      }
		    });
		    return;
		  }
		  // check aborted
		  if (self.aborted) {
		    return;
		  }
		  // send message to frame
		  var key = self.key = util.uniqueID();
		  cache[key] = self;
		  var data = util.fetch({
		    method: 'GET',
		    url: '',
		    data: null,
		    headers: {},
		    timeout: 0
		  }, options);
		  data.key = key;
		  message.postMessage(frame, { data: data });
		  self.afterSend();
		};
		
		pro.abort = function () {
		  var self = this;
		  self.aborted = true;
		  delete cache[self.key];
		  sp.abort.call(self);
		};
		
		module.exports = ProxyFrame;

	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		var util = __webpack_require__(2);
		var ajax = __webpack_require__(1);
		
		var json = function () {
		  var regJson = /json/i;
		  var regPost = /post/i;
		  return function (url, options) {
		    options = options || {};
		    var data = options.data = options.data || {};
		    // parse headers
		    var headers = options.headers = options.headers || {};
		    var accept = util.checkWithDefault(headers, 'Accept', 'application/json');
		    var contentType = util.checkWithDefault(headers, 'Content-Type', 'application/json');
		    // response data format
		    if (regJson.test(accept)) {
		      options.type = 'json';
		    }
		    // post data
		    if (regPost.test(options.method) && regJson.test(contentType)) {
		      options.data = JSON.stringify(data);
		    }
		    return ajax(url, options);
		  };
		}();
		
		module.exports = json;

	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		
		var ajax = __webpack_require__(1);
		
		var upload = function upload(url, options) {
		  options.method = 'POST';
		  options.headers = options.headers || {};
		  options.headers['Content-Type'] = 'multipart/form-data';
		  options.timeout = 0;
		  options.type = options.type || 'json';
		  return ajax(url, options);
		};
		
		module.exports = upload;

	/***/ }
	/******/ ])
	});
	;


/***/ },
/* 22 */
/***/ function(module, exports) {

	module.exports = deep;

	function deep (obj, prop) {
	  var segs = prop.split('.');
	  while (segs.length) {
	    var seg = segs.shift();
	    var existential = false;
	    if (seg[seg.length - 1] == '?') {
	      seg = seg.slice(0, -1);
	      existential = true;
	    }
	    obj = obj[seg];
	    if (!obj && existential) return obj;
	  }
	  return obj;
	}


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _device = __webpack_require__(12);

	var _device2 = _interopRequireDefault(_device);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var typeReverseMap = _device2['default'].clientTypeMap;

	/**
	 * 云信允许多端同时登录, LoginPort代表一个登录端
	 *
	 * @constructor
	 * @property {String}   type            登录的{@link LoginPort.type|设备类型}
	 * @property {String}   os              登录设备的操作系统
	 * @property {String}   mac             登录设备的 mac 地址
	 * @property {String}   deviceId        登录设备ID, uuid
	 * @property {String}   account         登录的帐号
	 * @property {Number}   connectionId    登录设备的连接号
	 * @property {String}   ip              登录的服务器 IP
	 * @property {Number}   time            登录时间
	 * @property {Boolean}  online          是否在线
	 */
	/**
	 * 设备类型
	 * 
	 * - `'Android'` (安卓)
	 * - `'iOS'` (苹果)
	 * - `'PC'` (桌面)
	 * - `'WindowsPhone'` (微软)
	 * - `'Web'` (浏览器)
	 *
	 * @memberOf LoginPort
	 * @name type
	 * @readOnly
	 * @enum {String}
	 */

	function LoginPort() {}

	LoginPort.reverse = function (loginPort) {
	  var obj = loginPort;
	  obj.type = typeReverseMap[obj.type];
	  return obj;
	};

	LoginPort.reverseType = function (type) {
	  return typeReverseMap[type] || type;
	};

	module.exports = LoginPort;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);

	/**
	 * @constructor
	 * @property {String}   id                  会话ID
	 * @property {String}   scene               {@link IMMessage.type|场景}
	 * @property {String}   to                  聊天对象, 账号或群ID
	 * @property {Long}     updateTime          会话更新的时间
	 * @property {Number}   unread              未读数
	 * @property {Message}  lastMsg             此会话的最后一条消息
	 * @property {Long}     [msgReceiptTime]    消息已读回执时间戳, 如果有此字段, 说明此时间戳之前的所有消息对方均已读
	 * - 目前仅对{@link IMMessage.type|`'p2p'`}会话起作用
	 * - 此字段不一定有, 只有对方发送过已读回执之后才会有
	 * - 调用接口{@link NIM#sendMsgReceipt|sendMsgReceipt}来发送消息已读回执
	 * - 调用接口{@link NIM#isMsgRemoteRead|isMsgRemoteRead}来查询消息是否被对方读过了
	 * @property {String}   localCustom         本地自定义扩展字段
	 * - 在{@link support.db|支持数据库}时可以调用{@Link NIM#updateLocalSession|更新本地会话}来更新此字段, 此字段只会被更新到本地数据库, 不会被更新到服务器上
	 */
	function Session() {}

	Session.parse = function (session) {
	    var arr = session.split('|');
	    return {
	        scene: arr[0],
	        to: arr[1]
	    };
	};

	Session.genSessionByMsg = function (msg) {
	    var session = {
	        id: msg.sessionId,
	        scene: msg.scene,
	        to: msg.target,
	        updateTime: msg.time,
	        lastMsg: msg
	    };
	    return session;
	};

	// lastTypeMsg: lastTextMsg, lastImageMsg, etc.
	// lastFlowMsg: lastInMsg, lastOutmsg
	// 无卵用, 去掉吧
	Session.appendLastMsg = function (session) {
	    var msg = session.lastMsg;
	    var type = util.capFirstLetter(msg.type);
	    session['last' + type + 'Msg'] = msg;
	    var flow = util.capFirstLetter(msg.flow);
	    session['last' + flow + 'Msg'] = msg;
	};

	// 根据最后一条未被忽略的消息来生成会话
	Session.genSessionByMsgs = function (Message, msgs) {
	    var lastMsg = Message.getLastNotIgnoredMsg(msgs);
	    if (lastMsg) {
	        return Session.genSessionByMsg(lastMsg);
	    }
	    return null;
	};

	Session.trim = function (session) {
	    delete session.msgReceiptSendTime;
	    delete session.msgReceiptServerTime;
	    delete session.ack;
	    delete session.unreadMsgs;
	};

	Session.isComplete = function (session) {
	    return session.id && session.scene && session.to;
	};

	module.exports = Session;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var undef = util.undef;
	var notundef = util.notundef;
	var parser = __webpack_require__(18).getInstance('IM');
	var team = __webpack_require__(26);
	var TeamMember = __webpack_require__(20);

	/**
	 * 系统通知类型
	 *
	 * - `'addFriend'`
	 *     - {@link NIM#addFriend|直接加某个用户为好友}后, 对方不需要确认, 直接成为当前登录用户的好友。
	 *     - 对方会收到一条类型为`'addFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号。
	 * - `'applyFriend'`
	 *     - {@link NIM#applyFriend|申请加某个用户为好友}后, 对方会收到一条类型为`'applyFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号, 用户在收到好友申请后, 可以选择通过或者拒绝好友申请。
	 *         - 如果{@link NIM#passFriendApply|通过好友申请}, 那么申请方会收到一条类型为`'passFriendApply'`的{@link SystemMessage.type|系统通知}, 此类群通知消息的`from`字段的值为通过方的帐号, `to`字段的值为申请方的账号。
	 *         - 如果{@link NIM#rejectFriendApply|拒绝好友申请}, 那么申请方会收到一条类型为`'rejectFriendApply'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为申请方的账号。
	 * - `'passFriendApply'`
	 *     - 见 `'applyFriend'`
	 * - `'rejectFriendApply'`
	 *     - 见 `'applyFriend'`
	 * - `'deleteFriend'`
	 *     - {@link NIM#deleteFriend|删除好友}后, 被删除的人会收到一条类型为`'deleteFriend'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为删除方的帐号, `to`字段的值为被删除方的账号。
	 * - `'teamInvite'`
	 *     - 高级群的群主和管理员在邀请成员加入群（通过操作{@link NIM#createTeam|创建群}或{@link NIM#addTeamMembers|拉人入群}）之后, 被邀请的人会收到一条类型为`'teamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为邀请方的帐号, `to`字段的值为对应的群ID, 此类系统通知的`attach`有一个字段`team`的值为被邀请进入的{@link Team|群}, 被邀请的人可以选择接受邀请或者拒绝邀请。
	 *         - 如果{@link NIM#acceptTeamInvite|接受入群邀请}, 那么该群的所有群成员会收到一条类型为`'acceptTeamInvite'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为接受入群邀请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`members`的值为接收入群邀请的群成员列表。
	 *         - 如果{@link NIM#rejectTeamInvite|拒绝入群邀请}, 那么邀请你的人会收到一条类型为`'rejectTeamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝入群邀请的人的帐号, `to`字段的值为对应的群ID。
	 * - `'rejectTeamInvite'`
	 *     - 见`'teamInvite'`
	 * - `'applyTeam'`
	 *     - 用户可以主动{@link NIM#applyTeam|申请加入高级群}, 目标群的群主和管理员会收到一条类型为`'applyTeam'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为对应的群ID, 高级群的群主和管理员在收到入群申请后, 可以选择通过或者拒绝入群申请。
	 *         - 如果{@link NIM#passTeamApply|通过入群申请}, 那么该群的所有群成员会收到一条类型为`'passTeamApply'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为通过入群申请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`包含了申请方的帐号, `attach`有一个字段`members`的值为被通过申请的群成员列表。
	 *         - 如果{@link NIM#rejectTeamApply|拒绝入群申请}, 那么申请人会收到一条类型为`'rejectTeamApply'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群}。
	 * - `'rejectTeamApply'`
	 *     - 见`'applyTeam'`
	 * - `'deleteMsg'`
	 *     - {@link NIM#deleteMsg|撤回消息}后, 消息接收方会收到一条类型为`'deleteMsg'`的{@link SystemMessage|系统通知}, 此类系统通知的 `msg` 为被删除的消息的部分字段。如果是群消息, 那么群里的所有人都会收到这条系统通知. 如果同时在多个端登录了同一个账号, 那么其它端也会收到这条系统通知.
	 * - `'custom'`
	 *     - 自定义系统通知
	 *
	 * @memberOf SystemMessage
	 * @name type
	 * @readOnly
	 * @enum {String}
	 */
	var typeMap = {
	    customP2p: 100,
	    customTeam: 101,
	    deleteMsgP2p: 7,
	    deleteMsgTeam: 8
	};
	var typeReverseMap = {
	    0: 'applyTeam',
	    1: 'rejectTeamApply',
	    2: 'teamInvite',
	    3: 'rejectTeamInvite',
	    5: 'friendRequest',
	    6: 'deleteFriend',
	    7: 'deleteMsgP2p',
	    8: 'deleteMsgTeam',
	    // 自定义系统通知
	    100: 'customP2p',
	    101: 'customTeam',
	    // 云商服自定义系统通知, 直接复用100
	    102: 'customP2p'
	};
	var friendRequestReverseMap = {
	    1: 'addFriend',
	    2: 'applyFriend',
	    3: 'passFriendApply',
	    4: 'rejectFriendApply'
	};

	var categoryTeam = 'team';
	var categoryFriend = 'friend';
	var categoryMsg = 'msg';
	var categories = [categoryTeam, categoryFriend, categoryMsg];
	var type2category = {
	    applyTeam: categoryTeam,
	    rejectTeamApply: categoryTeam,
	    teamInvite: categoryTeam,
	    rejectTeamInvite: categoryTeam,
	    addFriend: categoryFriend,
	    applyFriend: categoryFriend,
	    passFriendApply: categoryFriend,
	    rejectFriendApply: categoryFriend,
	    deleteFriend: categoryFriend,
	    deleteMsg: categoryMsg
	};

	/**
	 * 内建系统通知的种类
	 * - `'team'`
	 * - `'friend'`
	 *
	 * @memberOf SystemMessage
	 * @name category
	 * @readOnly
	 * @enum {String}
	 */

	/**
	 * 内建系统通知的状态
	 * - `'init'`: 未处理状态
	 * - `'passed'`: 已通过
	 * - `'rejected'`: 已拒绝
	 * - `'error'`: 错误
	 *
	 * @memberOf SystemMessage
	 * @name state
	 * @readOnly
	 * @enum {String}
	 */

	/**
	 * 系统通知
	 *
	 * 系统通知分为两种
	 * - 内建系统通知
	 *     - 目前所有的内建系统通知都是与高级群相关的通知, 某些群操作后相关的群成员会收到相应的系统通知。
	 *     - 内建系统通知与{@link IMMessage.type|群通知消息}的区别是系统通知是发给单人的通知, 群通知消息是发给所有群成员的消息。
	 * - 自定义系统通知
	 *     - 开发者可以向其他用户或群{@link NIM#sendCustomSysMsg|发送自定义系统通知}
	 *     - 自定义系统通知和自定义消息的区别如下
	 *         - 自定义消息属于{@link IMMessage|消息}, 会存储在云信的消息数据库中, 需要跟其他{@link IMMessage|消息}一同展现给用户。
	 *         - 自定义系统通知属于{@link SystemMessage|系统通知}, 用于第三方通知自己, 不会存储在云信的数据库中, SDK不会解析这些通知, SDK仅仅负责传递这些通知。
	 * - 请参考{@link NIM|初始化SDK}时传入的`onofflinesysmsgs`、`onofflinecustomsysmsgs`、`onsysmsg`、`oncustomsysmsg`等回调。
	 *
	 * @constructor
	 * @property {Number}           time                    时间戳
	 * @property {String}           [type]                  {@link SystemMessage.type|系统通知类型}
	 * @property {String}           from                    系统通知的来源, 账号或者群ID
	 * @property {String}           to                      系统通知的目标, 账号或者群ID
	 * @property {String}           [idServer]              内建系统通知的 idServer
	 * @property {Boolean}          [read]                  内建系统通知是否已读
	 * @property {String}           [category]              {@link SystemMessage.category|内建系统通知的种类}
	 * @property {String}           [state]                 内建系统通知的{@link SystemMessage|state}
	 * @property {NIMError}         [error]                 内建系统通知的{@link SystemMessage.state|state} 为 `'error'` 时, 此字段包含错误的信息
	 * @property {String}           [localCustom]           内建系统通知的本地自定义扩展字段
	 * - 在{@link support.db|支持数据库}时可以调用{@Link NIM#updateLocalSysMsg|更新本地系统通知}来更新此字段, 此字段只会被更新到本地数据库, 不会被更新到服务器上
	 * @property {String}           [ps]                    内建系统通知的附言
	 * @property {Object}           [attach]                内建系统通知的附加信息, 参考{@link SystemMessage.type|系统通知类型}来查看不同类型的系统通知对应的附加信息
	 * @property {String}           [attach.custom]         附加消息的扩展字段, 可能没有
	 * @property {String}           [scene]                 自定义系系统通知的场景, 参考{@link IMMessage.scene|消息场景}
	 * @property {String}           [content]               自定义系统通知的内容
	 * @property {Boolean}          isPushable              是否需要推送
	 * @property {String}           [apnsText]              自定义系统通知的推送文案, 仅对接收方为iOS设备有效
	 * @property {String}           [pushPayload]           自定义系统通知的推送属性
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @property {Boolean}          needPushNick            是否需要推送昵称
	 * @property {Boolean}          [sendToOnlineUsersOnly] 自定义系统通知是否只发送给在线用户。
	 * - `true`时只发送给在线用户, 适合发送即时通知, 比如正在输入。
	 * - `false`时假如目标用户或群不在线, 会在其上线后推送过去。
	 * - 该参数只对点对点自定义系统通知有效, 对群自定义系统通知无效, 群自定义系统通知只会发给在线的群成员, 不会存离线。
	 * @property {Boolean}          cc                      自定义系统通知是否抄送
	 */
	function SystemMessage(options) {
	    var self = this;
	    util.verifyOptions(options, 'type to');
	    util.verifyParamValid('type', options.type, SystemMessage.validTypes);
	    if (options.type.indexOf('custom') !== -1) {
	        util.verifyOptions(options, 'content');
	        self.attach = options.content;
	        if (notundef(options.apnsText)) {
	            self.apnsText = '' + options.apnsText;
	        }
	        if (notundef(options.pushPayload)) {
	            self.pushPayload = '' + options.pushPayload;
	        }
	        // 开关
	        if (notundef(options.sendToOnlineUsersOnly)) {
	            self.sendToOnlineUsersOnly = !!options.sendToOnlineUsersOnly ? 0 : 1;
	        }
	        if (notundef(options.cc)) {
	            self.cc = !!options.cc ? 1 : 0;
	        }
	        if (notundef(options.isPushable)) {
	            self.isPushable = options.isPushable ? 1 : 0;
	        }
	        if (notundef(options.isUnreadable)) {
	            self.isUnreadable = options.isUnreadable ? 1 : 0;
	        }
	        if (notundef(options.needPushNick)) {
	            self.needPushNick = options.needPushNick ? 1 : 0;
	        }
	    }
	    self.time = options.time || +new Date();
	    self.type = typeMap[options.type];
	    self.to = options.to;
	    if (notundef(options.from)) {
	        self.from = options.from;
	    }
	    if (notundef(options.ps)) {
	        self.ps = options.ps;
	    }
	    if (notundef(options.deletedIdClient)) {
	        self.deletedIdClient = options.deletedIdClient;
	    }
	    if (notundef(options.deletedIdServer)) {
	        self.deletedIdServer = options.deletedIdServer;
	    }
	    if (notundef(options.yidunEnable)) {
	        self.yidunEnable = options.yidunEnable ? 1 : 0;
	    }
	    if (notundef(options.antiSpamContent)) {
	        self.antiSpamContent = '' + options.antiSpamContent;
	    }
	    self.idClient = options.idClient || util.guid();
	}

	SystemMessage.validTypes = Object.keys(typeMap).concat(Object.keys(type2category));
	SystemMessage.validCategories = ['team', 'friend'];

	SystemMessage.isCustom = function (sysMsg) {
	    return sysMsg.type === 'custom';
	};

	SystemMessage.reverse = function (sysMsg) {
	    var obj = {
	        time: +sysMsg.time,
	        to: sysMsg.to,
	        type: typeReverseMap[sysMsg.type]
	    };

	    if (notundef(sysMsg.from)) {
	        obj.from = sysMsg.from;
	    }
	    if (notundef(sysMsg.idServer)) {
	        obj.idServer = '' + sysMsg.idServer;
	    }
	    if (notundef(sysMsg.deletedIdClient)) {
	        obj.deletedIdClient = sysMsg.deletedIdClient;
	    }
	    if (notundef(sysMsg.deletedIdServer)) {
	        obj.deletedIdServer = '' + sysMsg.deletedIdServer;
	    }
	    if (notundef(sysMsg.deletedMsgTime)) {
	        obj.deletedMsgTime = +sysMsg.deletedMsgTime;
	    }
	    if (notundef(sysMsg.deletedMsgFromNick)) {
	        obj.deletedMsgFromNick = '' + sysMsg.deletedMsgFromNick;
	    }
	    if (notundef(sysMsg.ps)) {
	        obj.ps = sysMsg.ps;
	    }

	    // 内建系统通知, attach里面是额外数据
	    sysMsg.attach = !!sysMsg.attach ? '' + sysMsg.attach : '';
	    if (obj.type === 'customP2p' || obj.type === 'customTeam') {
	        // 自定义的系统通知
	        obj.content = sysMsg.attach;
	        if (notundef(sysMsg.apnsText)) {
	            obj.apnsText = sysMsg.apnsText;
	        }
	        if (notundef(sysMsg.pushPayload)) {
	            obj.pushPayload = sysMsg.pushPayload;
	        }
	        // 开关
	        util.merge(obj, {
	            sendToOnlineUsersOnly: undef(sysMsg.sendToOnlineUsersOnly) || +sysMsg.sendToOnlineUsersOnly === 0,
	            cc: undef(sysMsg.cc) || +sysMsg.cc === 1,
	            isPushable: undef(sysMsg.isPushable) || +sysMsg.isPushable === 1,
	            isUnreadable: undef(sysMsg.isUnreadable) || +sysMsg.isUnreadable === 1,
	            needPushNick: notundef(sysMsg.needPushNick) && +sysMsg.needPushNick === 1
	        });
	        // 设置 scene
	        obj.scene = obj.type.slice(6).toLowerCase();
	        // 最终展示给用户的类型就是`'custome'`
	        obj.type = 'custom';
	    } else if (obj.type === 'deleteMsgP2p' || obj.type === 'deleteMsgTeam') {
	        // 撤回消息的通知
	        obj.scene = obj.type.slice(9).toLowerCase();
	        obj.type = 'deleteMsg';
	    } else {
	        if (!!sysMsg.attach) {
	            obj.attach = {};
	            var attach = JSON.parse(sysMsg.attach);
	            if (notundef(attach.vt)) {
	                // 好友系统请求
	                obj.type = friendRequestReverseMap[attach.vt];
	                delete obj.attach;
	            } else {
	                // 群系统通知
	                if (notundef(attach.tinfo)) {
	                    obj.attach.team = team.reverse(parser.unserialize(attach.tinfo, 'team'));
	                }
	                if (notundef(attach.tlist)) {
	                    obj.attach.member = TeamMember.reverse(parser.unserialize(attach.tlist, 'teamMember'));
	                }
	                if (notundef(attach.attach)) {
	                    obj.attach.custom = attach.attach;
	                }
	            }
	        }
	        obj.category = type2category[obj.type];
	        obj.read = false;
	        obj.state = 'init';
	    }

	    // 开关
	    if (notundef(sysMsg.cc)) {
	        obj.cc = +sysMsg.cc === 1;
	    }

	    // SDK 自己加的属性
	    obj.status = sysMsg.status || 'success';
	    if (notundef(sysMsg.filter)) {
	        obj.filter = sysMsg.filter;
	    }

	    return obj;
	};

	SystemMessage.reverseSysMsgs = function (sysMsgs, options) {
	    options = options || {};
	    var mapper = options.mapper;
	    var needMap = util.isFunction(mapper);
	    return sysMsgs.map(function (sysMsg) {
	        sysMsg = SystemMessage.reverse(sysMsg);
	        if (needMap) {
	            sysMsg = mapper(sysMsg);
	        }
	        return sysMsg;
	    });
	};

	SystemMessage.completeUnread = function (sysMsgUnread) {
	    sysMsgUnread = sysMsgUnread || {};
	    categories.forEach(function (category) {
	        delete sysMsgUnread[category];
	    });
	    var category;
	    Object.keys(type2category).forEach(function (type) {
	        sysMsgUnread[type] = sysMsgUnread[type] || 0;
	        if (sysMsgUnread[type] < 0) {
	            sysMsgUnread[type] = 0;
	        }
	        category = type2category[type];
	        sysMsgUnread[category] = sysMsgUnread[category] || 0;
	        sysMsgUnread[category] = sysMsgUnread[category] + sysMsgUnread[type];
	    });
	    sysMsgUnread.total = 0;
	    categories.forEach(function (category) {
	        sysMsgUnread.total += sysMsgUnread[category];
	    });
	    return sysMsgUnread;
	};

	module.exports = SystemMessage;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var notundef = util.notundef;
	var fillPropertyWithDefault = util.fillPropertyWithDefault;
	var objKeys = Object.keys;

	var map = {};
	var reverseMap = {};
	var modeNames = [];
	var validMap = {};

	/**
	 * 群类型
	 *
	 * - `'normal'` (普通群)
	 * - `'advanced'` (高级群)
	 *
	 * 普通群没有群简介/群公告/群加入方式/群被邀请模式/群邀请模式/群信息修改权限/群信息自定义字段修改权限
	 *
	 * @memberOf Team
	 * @name type
	 * @readOnly
	 * @enum {String}
	 */
	var typeMap = {
	    normal: 0,
	    advanced: 1
	};
	var typeReverseMap = {
	    0: 'normal',
	    1: 'advanced'
	};
	var validTypes = objKeys(typeMap);

	/**
	 * 群加入方式
	 *
	 * - `'noVerify'` (不需要验证)
	 * - `'needVerify'` (需要验证)
	 * - `'rejectAll'` (禁止任何人加入)
	 *
	 * @memberOf Team
	 * @name joinMode
	 * @readOnly
	 * @enum {String}
	 */
	var joinModeMap = map.joinMode = {
	    noVerify: 0,
	    needVerify: 1,
	    rejectAll: 2
	};
	reverseMap.joinMode = {
	    0: 'noVerify',
	    1: 'needVerify',
	    2: 'rejectAll'
	};
	modeNames.push('join');
	validMap.joinMode = objKeys(joinModeMap);

	/**
	 * 群被邀请模式
	 * - `'needVerify'` (需要邀请方同意)
	 * - `'noVerify'` (不需要邀请方同意)
	 * @memberOf Team
	 * @name beInviteMode
	 * @readOnly
	 * @enum {String}
	 */
	var beInviteModeMap = map.beInviteMode = {
	    'needVerify': 0,
	    'noVerify': 1
	};
	reverseMap.beInviteMode = {
	    0: 'needVerify',
	    1: 'noVerify'
	};
	modeNames.push('beInvite');
	validMap.beInviteMode = objKeys(beInviteModeMap);

	/**
	 * 群邀请模式
	 * - `'manager'` (只有管理员/群主可以邀请他人入群)
	 * - `'all'` (所有人可以邀请他人入群)
	 * @memberOf Team
	 * @name  inviteMode
	 * @readOnly
	 * @enum {String}
	 */
	var inviteModeMap = map.inviteMode = {
	    'manager': 0,
	    'all': 1
	};
	reverseMap.inviteMode = {
	    0: 'manager',
	    1: 'all'
	};
	modeNames.push('invite');
	validMap.inviteMode = objKeys(inviteModeMap);

	/**
	 * 群信息修改权限
	 * - `'manager'` (只有管理员/群主可以修改)
	 * - `'all'` (所有人可以修改)
	 * @memberOf Team
	 * @name  updateTeamMode
	 * @readOnly
	 * @enum {String}
	 */
	var updateTeamModeMap = map.updateTeamMode = {
	    'manager': 0,
	    'all': 1
	};
	reverseMap.updateTeamMode = {
	    0: 'manager',
	    1: 'all'
	};
	modeNames.push('updateTeam');
	validMap.updateTeamMode = objKeys(updateTeamModeMap);

	/**
	 * 群信息自定义字段修改权限
	 * - `'manager'` (只有管理员/群主可以修改)
	 * - `'all'` (所有人可以修改)
	 * @memberOf Team
	 * @name  updateCustomMode
	 * @readOnly
	 * @enum {String}
	 */
	var updateCustomModeMap = map.updateCustomMode = {
	    'manager': 0,
	    'all': 1
	};
	reverseMap.updateCustomMode = {
	    0: 'manager',
	    1: 'all'
	};
	modeNames.push('updateCustom');
	validMap.updateCustomMode = objKeys(updateCustomModeMap);

	/**
	 * 群
	 *
	 * @constructor
	 * @property {String}   teamId                  群Id
	 * @property {String}   type                    {@link Team.type|群类型}
	 * @property {String}   name                    群名字
	 * @property {String}   avatar                  群头像
	 * @property {String}   intro                   群简介
	 * @property {String}   announcement            群公告
	 * @property {String}   joinMode                {@link Team.joinMode|群加入方式}, 仅限高级群
	 * @property {String}   beInviteMode            {@link Team.beInviteMode|群被邀请模式}, 仅限高级群
	 * @property {String}   inviteMode              {@link Team.inviteMode|群邀请模式}, 仅限高级群
	 * @property {String}   updateTeamMode          {@link Team.updateTeamMode|群信息修改权限}, 仅限高级群
	 * @property {String}   updateCustomMode        {@link Team.updateCustomMode|群信息自定义字段修改权限}, 仅限高级群
	 * @property {String}   owner                   群主
	 * @property {Number}   level                   群人数上限
	 * @property {Number}   memberNum               群成员数量
	 * @property {Number}   memberUpdateTime        群成员最后更新时间
	 * @property {Number}   createTime              群创建时间
	 * @property {Number}   updateTime              群最后更新时间
	 * @property {String}   custom                  第三方扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
	 * @property {String}   serverCustom            第三方服务器扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
	 * @property {Boolean}  valid                   是否有效, 解散后该群无效
	 * @property {Boolean}  validToCurrentUser      该群是否对当前用户有效, 如果无效, 那么说明被踢了
	 * @property {Boolean}  mute                    是否禁言, 禁言状态下普通成员不能发送消息, 创建者和管理员可以发送消息
	 */
	function Team(options) {
	    var self = this;
	    util.verifyOptions(options, 'action');
	    // 根据不同的action来验证不同的参数
	    switch (options.action) {
	        case 'create':
	            util.verifyOptions(options, 'teamId', false);
	            util.verifyOptions(options, 'type name');
	            util.verifyParamValid('type', options.type, validTypes);
	            break;
	        case 'update':
	            util.verifyOptions(options, 'teamId');
	            util.verifyOptions(options, 'type', false);
	            break;
	        default:
	            break;
	    }
	    if (notundef(options.teamId)) {
	        self.teamId = options.teamId;
	    }
	    if (notundef(options.type)) {
	        self.type = typeMap[options.type];
	    }
	    if (notundef(options.avatar)) {
	        self.avatar = '' + options.avatar;
	    }
	    if (notundef(options.name)) {
	        self.name = '' + options.name;
	    }
	    if (notundef(options.intro)) {
	        self.intro = '' + options.intro;
	    }
	    if (notundef(options.announcement)) {
	        self.announcement = '' + options.announcement;
	    }
	    modeNames.forEach(self.setMode.bind(self, options));
	    if (notundef(options.custom)) {
	        self.custom = '' + options.custom;
	    }
	}

	var pro = Team.prototype;

	// 设置各种模式, 验证其正确性
	pro.setMode = function (options, name) {
	    var self = this;
	    name = name + 'Mode';
	    if (notundef(options[name])) {
	        util.verifyParamValid(name, options[name], validMap[name]);
	        self[name] = map[name][options[name]];
	    }
	};

	/**
	 * 逆转team, 因为可能是更新team信息, 可能只有部分信息, 所以用filter过滤不存在的信息
	 *
	 * @private
	 * @param  {Team} team 群
	 * @param  {flag} 不需要填充
	 * @return {Object}
	 */
	Team.reverse = function (team, flag) {
	    var obj = util.copy(team);
	    if (notundef(obj.teamId)) {
	        obj.teamId = '' + obj.teamId;
	    }
	    if (notundef(obj.type)) {
	        obj.type = typeReverseMap[obj.type];
	    }
	    if (notundef(obj.level)) {
	        obj.level = +obj.level;
	    }
	    if (notundef(obj.valid)) {
	        obj.valid = +obj.valid === 1;
	    }
	    if (notundef(obj.memberNum)) {
	        obj.memberNum = +obj.memberNum;
	    }
	    if (notundef(obj.memberUpdateTime)) {
	        obj.memberUpdateTime = +obj.memberUpdateTime;
	    }
	    if (notundef(obj.createTime)) {
	        obj.createTime = +obj.createTime;
	    }
	    if (notundef(obj.updateTime)) {
	        obj.updateTime = +obj.updateTime;
	    }
	    if (notundef(obj.validToCurrentUser)) {
	        obj.validToCurrentUser = obj.validToCurrentUser === '1';
	    }
	    if (notundef(obj.mute)) {
	        obj.mute = obj.mute === '1';
	    }
	    modeNames.forEach(reverseMode.bind(null, obj));
	    delete obj.bits;
	    if (!flag) {
	        Team.fillProperties(obj);
	    }
	    return obj;
	};

	function reverseMode(obj, name) {
	    name = name + 'Mode';
	    if (notundef(obj[name])) {
	        obj[name] = reverseMap[name][obj[name]];
	    }
	}

	/**
	 * 升级数据库后, 有些字段老的记录是没有的, 此方法用于补全这些字段
	 */
	Team.fillProperties = function (team) {
	    var fill1 = fillPropertyWithDefault(team, 'beInviteMode', 'needVerify');
	    var fill2 = fillPropertyWithDefault(team, 'inviteMode', 'manager');
	    var fill3 = fillPropertyWithDefault(team, 'updateTeamMode', 'manager');
	    var fill4 = fillPropertyWithDefault(team, 'updateCustomMode', 'manager');
	    var fill5 = fillPropertyWithDefault(team, 'avatar', '');
	    return fill1 || fill2 || fill3 || fill4 || fill5;
	};

	module.exports = Team;

/***/ },
/* 27 */,
/* 28 */
/***/ function(module, exports) {

	/*
	 * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license
	 * Author: Jim Palmer (based on chunking idea from Dave Koelle)
	 */
	/*jshint unused:false */
	module.exports = function naturalSort (a, b) {
		"use strict";
		var re = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
			sre = /(^[ ]*|[ ]*$)/g,
			dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
			hre = /^0x[0-9a-f]+$/i,
			ore = /^0/,
			i = function(s) { return naturalSort.insensitive && ('' + s).toLowerCase() || '' + s; },
			// convert all to strings strip whitespace
			x = i(a).replace(sre, '') || '',
			y = i(b).replace(sre, '') || '',
			// chunk/tokenize
			xN = x.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
			yN = y.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
			// numeric, hex or date detection
			xD = parseInt(x.match(hre), 16) || (xN.length !== 1 && x.match(dre) && Date.parse(x)),
			yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null,
			oFxNcL, oFyNcL;
		// first try and sort Hex codes or Dates
		if (yD) {
			if ( xD < yD ) { return -1; }
			else if ( xD > yD ) { return 1; }
		}
		// natural sorting through split numeric strings and default strings
		for(var cLoc=0, numS=Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
			// find floats not starting with '0', string or 0 if not defined (Clint Priest)
			oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
			oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
			// handle numeric vs string comparison - number < string - (Kyle Adams)
			if (isNaN(oFxNcL) !== isNaN(oFyNcL)) { return (isNaN(oFxNcL)) ? 1 : -1; }
			// rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
			else if (typeof oFxNcL !== typeof oFyNcL) {
				oFxNcL += '';
				oFyNcL += '';
			}
			if (oFxNcL < oFyNcL) { return -1; }
			if (oFxNcL > oFyNcL) { return 1; }
		}
		return 0;
	};


/***/ },
/* 29 */,
/* 30 */,
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Message = __webpack_require__(16);
	var util = __webpack_require__(1);

	function FileMessage(options) {
	  if (util.notundef(options.type)) {
	    util.verifyFileType(options.type);
	  } else {
	    options.type = 'file';
	  }
	  util.verifyOptions(options, 'file');
	  util.verifyOptions(options.file, 'url ext size md5', true, 'file.');
	  switch (options.type) {
	    case 'image':
	      ImageMessage.verifyFile(options.file);
	      break;
	    case 'audio':
	      AudioMessage.verifyFile(options.file);
	      break;
	    case 'video':
	      VideoMessage.verifyFile(options.file);
	      break;
	    default:
	      break;
	  }
	  Message.call(this, options);
	  this.attach = JSON.stringify(options.file);
	}

	FileMessage.prototype = Object.create(Message.prototype);

	FileMessage.reverse = function (msg) {
	  var obj = Message.reverse(msg);
	  msg.attach = msg.attach ? '' + msg.attach : '';
	  obj.file = msg.attach ? JSON.parse(msg.attach) : {};
	  // 如果是音频, 转成mp3
	  if (obj.type === 'audio') {
	    obj.file.mp3Url = obj.file.url + '?audioTrans&type=mp3';
	  }
	  if (msg.enabledHttpsForMessage) {
	    obj.file.url = obj.file.url.replace(/^http:\/\/nim\.nos\.netease\.com/, 'https://nos.netease.com');
	  }
	  return obj;
	};

	module.exports = FileMessage;
	var ImageMessage = __webpack_require__(135);
	var AudioMessage = __webpack_require__(132);
	var VideoMessage = __webpack_require__(141);

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);

	/**
	 * 性别
	 *
	 * - `'unknown'` (未知)
	 * - `'male'` (男)
	 * - `'female'` (女)
	 *
	 * @memberOf User
	 * @name gender
	 * @readOnly
	 * @enum {String}
	 */
	var genderMap = {
	  unknown: 0,
	  male: 1,
	  female: 2
	};
	var genderReverseMap = {
	  0: 'unknown',
	  1: 'male',
	  2: 'female'
	};

	/**
	 * @constructor
	 *
	 * @property {String}   account     账号
	 * @property {String}   nick        昵称
	 * @property {String}   avatar      头像
	 * @property {String}   sign        签名
	 * @property {String}   gender      {@link User.gender|性别}
	 * @property {String}   email       邮箱
	 * @property {String}   birth       生日
	 * @property {String}   tel         电话号码
	 * @property {String}   custom      扩展字段
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @property {Long}     createTime  创建时间
	 * @property {Long}     updateTime  更新时间
	 */
	function User(options) {
	  util.merge(this, options);
	  if (util.notundef(this.gender)) {
	    util.verifyParamValid('gender', this.gender, User.validGenders);
	    this.gender = genderMap[this.gender];
	  }
	  if (util.notundef(this.email) && this.email !== '') {
	    util.verifyEmail('email', this.email);
	  }
	  if (util.notundef(this.birth) && this.birth !== '') {
	    util.verifyBirth('birth', this.birth);
	  }
	  if (util.notundef(this.tel) && this.tel !== '') {
	    util.verifyTel('tel', this.tel);
	  }
	}

	User.reverse = function (user) {
	  var obj = util.filterObj(user, 'account nick avatar sign gender email birth tel custom createTime updateTime');
	  if (util.notundef(obj.gender)) {
	    obj.gender = genderReverseMap[obj.gender];
	  }
	  if (util.notundef(obj.createTime)) {
	    obj.createTime = +obj.createTime;
	  }
	  if (util.notundef(obj.updateTime)) {
	    obj.updateTime = +obj.updateTime;
	  }
	  return obj;
	};

	User.reverseUsers = function (users) {
	  return users.map(function (user) {
	    return User.reverse(user);
	  });
	};

	User.validGenders = Object.keys(genderMap);

	module.exports = User;

/***/ },
/* 33 */,
/* 34 */,
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);

	/**
	 * 操作类型
	 * @memberOf ImageOp
	 * @name type
	 * @readOnly
	 * @enum {String}
	 */
	var typeMap = {
	    // 去除图片元数据
	    stripmeta: 0,
	    // 修改图片类型
	    // type: 1,
	    // 高斯模糊
	    blur: 2,
	    // 修改图片质量
	    quality: 3,
	    // 对图片进行剪裁
	    crop: 4,
	    // 对图片进行旋转
	    rotate: 5,
	    // 基于像素对图片进行缩略
	    // pixel: 6,
	    // 基于长宽的图片缩略
	    thumbnail: 7,
	    // 图片水印
	    // watermark: 8,
	    // 图片interlace
	    interlace: 9
	    // tmp: 10
	};
	var typeReverseMap = {
	    0: 'stripmeta',
	    1: 'type',
	    2: 'blur',
	    3: 'quality',
	    4: 'crop',
	    5: 'rotate',
	    6: 'pixel',
	    7: 'thumbnail',
	    8: 'watermark',
	    9: 'interlace',
	    10: 'tmp'
	};

	function ImageOp(options) {
	    util.verifyOptions(options, 'type');
	    util.verifyParamValid('type', options.type, ImageOp.validTypes);
	    util.merge(this, options);
	    this.type = typeMap[options.type];
	}

	ImageOp.validTypes = Object.keys(typeMap);

	ImageOp.reverse = function (imageOp) {
	    var obj = util.copy(imageOp);
	    obj.type = typeReverseMap[obj.type];
	    return obj;
	};

	ImageOp.reverseImageOps = function (imageOps) {
	    return imageOps.map(function (imageOp) {
	        return ImageOp.reverse(imageOp);
	    });
	};

	module.exports = ImageOp;

/***/ },
/* 36 */
/***/ function(module, exports) {

	'use strict';

	var idMap = {
	    // 连接相关
	    link: {
	        id: 1,
	        // 心跳
	        heartbeat: 2
	    },
	    // 其它
	    misc: {
	        id: 6,
	        // 获取nos上传凭证
	        getSimpleNosToken: 1,
	        // 获取nos上传凭证
	        getNosToken: 2,
	        // 下发SDK日志上传通知
	        notifyUploadLog: 3,
	        // 上传日志的 url
	        uploadSdkLogUrl: 4,
	        // 语音转文字
	        audioToText: 5,
	        // 处理图片
	        processImage: 6
	    }
	};

	/**
	 * 命令配置
	 * params 说明: 如果类型是 Property, 如果没有 entity, entity 值就是 name
	 */
	var cmdConfig = {
	    // 心跳
	    heartbeat: { sid: idMap.link.id, cid: idMap.link.heartbeat },
	    // 获取nos上传凭证
	    getSimpleNosToken: {
	        sid: idMap.misc.id, cid: idMap.misc.getSimpleNosToken, params: [{ type: 'int', name: 'num' }]
	    },
	    // 获取nos上传凭证
	    getNosToken: { sid: idMap.misc.id, cid: idMap.misc.getNosToken, params: [{ type: 'String', name: 'responseBody' }] },
	    uploadSdkLogUrl: {
	        sid: idMap.misc.id,
	        cid: idMap.misc.uploadSdkLogUrl,
	        params: [{ type: 'string', name: 'url' }]
	    },
	    // 语音转文字
	    audioToText: { sid: idMap.misc.id, cid: idMap.misc.audioToText, params: [{ type: 'Property', name: 'audioToText' }] },
	    // 处理图片
	    processImage: { sid: idMap.misc.id, cid: idMap.misc.processImage, params: [{ type: 'String', name: 'url' }, { type: 'PropertyArray', name: 'imageOps', entity: 'imageOp' }] }

	};

	/**
	 * 回包配置
	 * response 说明: 如果没有 entity, entity 值就是 name
	 */
	var packetConfig = {
	    // 心跳
	    '1_2': { service: 'link', cmd: 'heartbeat' },
	    // 获取nos上传凭证
	    '6_1': { service: 'misc', cmd: 'getSimpleNosToken', response: [{ type: 'PropertyArray', name: 'nosTokens', entity: 'nosToken' }] },
	    // 获取nos上传凭证
	    '6_2': { service: 'misc', cmd: 'getNosToken', response: [{ type: 'Property', name: 'nosToken' }] },
	    '6_3': { service: 'misc', cmd: 'notifyUploadLog' },
	    // 语音转文字
	    '6_5': { service: 'misc', cmd: 'audioToText', response: [{ type: 'String', name: 'text' }] },
	    // 处理图片
	    '6_6': { service: 'misc', cmd: 'processImage', response: [{ type: 'String', name: 'url' }] }
	};

	module.exports = {
	    idMap: idMap,
	    cmdConfig: cmdConfig,
	    packetConfig: packetConfig
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	/**
	 * NIM Blob 工具方法, 通过 `NIM.blob` 来获取此工具的引用
	 *
	 * @namespace blob
	 */
	var blob = {};

	/**
	 * 将包含 MIME type 和 base64 数据的 data URL 转换为 Blob 对象
	 *
	 * @memberOf blob
	 * @method fromDataURL
	 *
	 * @param  {String} dataURL 包含 MIME type 和 base64 数据的 data URL
	 * @return {Blob}           Blob对象
	 *
	 * @example
	 * var dataURL = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAAyADIDASIAAhEBAxEB/8QAGgABAAMBAQEAAAAAAAAAAAAAAAIEBgUDAf/EACwQAAEEAQMCBQMFAQAAAAAAAAEAAgMRBAUSISIxBhNBUWEUMnEjkaGxstH/xAAaAQACAwEBAAAAAAAAAAAAAAAAAQIDBAUG/8QAIREAAgIBAwUBAAAAAAAAAAAAAAECERIEFCExM0FxodH/2gAMAwEAAhEDEQA/ANkiKtm5gxI203fK87Y2XVnv+w7lXNpK2ebLKhHMyUuDHbtpokdr9lksjPzM187pMowYEBIfKw7TIR3ArsL4vuquJNlYenYub9TPE2U1I272lx4cGngjtYPp8rPuoWLI3SLlaTqr8pz8XLa2PNiHW1vZw9CPhdVXxkpK0MIiKQBZzXcgxZGVJz+hh20D3cTf+QtE40LDS4+gaLJXE13FfFqNSxyRvkg8qTpI2HktPNe7gVRqe2x4tqzh5OP5PhAxMaDULXHn1sElWtQo+HJdvb6cEbvwP5VbLex3hzJxnSmSXHjDJKFciq49vlT1SYjw8xrTuknYyNu1v3E1dD8WuZza9kPwSymAaRnMNzF7GFx4LmubyCtoOyxpx/q9UwtMi3mPGAllcfgU3n3WyW/SJ4EkERFrA+EWORahkxszJnS5QEz3MEZMguwBX9eq9FFzA4EEWCk0n1HbqjN5GmQyajKxkhDiwxuO8dba+1xruOVX1DCZp2JFPNlDysZrY4uN5DjxurgE178LRnToDN5vXd9r4UpNPxZQBLE14BsB3ItZ9tF3Y4OKmnNWvPNfTx0zAxsKHdj9Zl63yu5dIT6n/ivqLWNY3a0ABSWhJJUiIRETAIiIAIiIAIiIAIiIA//Z';
	 * var blob = NIM.blob.fromDataURL(dataURL);
	 * // blob instanceof Blob === true;
	 */
	blob.fromDataURL = util.blobFromDataURL;

	module.exports = blob;

/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = isFunction

	var toString = Object.prototype.toString

	function isFunction (fn) {
	  var string = toString.call(fn)
	  return string === '[object Function]' ||
	    (typeof fn === 'function' && string !== '[object RegExp]') ||
	    (typeof window !== 'undefined' &&
	     // IE8 and below
	     (fn === window.setTimeout ||
	      fn === window.alert ||
	      fn === window.confirm ||
	      fn === window.prompt))
	};


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {(function ( window , undefined ) {
	    'use strict';

	    function getGlobal () {
	      if (typeof window !== 'undefined') {
	        return window
	      }
	      if (typeof self !== 'undefined') {
	        return self
	      }
	      if (typeof global !== 'undefined') {
	        return global
	      }
	      return {}
	    }

	    window = getGlobal()

	    var indexedDB,
	        IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange,
	        transactionModes = {
	            readonly: 'readonly',
	            readwrite: 'readwrite'
	        };

	    var hasOwn = Object.prototype.hasOwnProperty;

	    var getIndexedDB = function() {
	      if ( !indexedDB ) {
	        indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.oIndexedDB || window.msIndexedDB || ((window.indexedDB === null && window.shimIndexedDB) ? window.shimIndexedDB : undefined);

	        if ( !indexedDB ) {
	          throw 'IndexedDB required';
	        }
	      }
	      return indexedDB;
	    };

	    var defaultMapper = function (value) {
	        return value;
	    };

	    var typeOf = function(o) {
	        return Object.prototype.toString.call(o).slice(8, -1).toLowerCase();
	    };
	    var isFunc = function(o) {
	        return typeof o === 'function';
	    };
	    var isNum = function(o) {
	        return typeOf(o) === 'number';
	    };
	    var isArray = function(o) {
	        return typeOf(o) === 'array';
	    };
	    var undef = function(o) {
	        return o === undefined;
	    };

	    var CallbackList = function () {
	        var state,
	            list = [];

	        var exec = function ( context , args ) {
	            if ( list ) {
	                args = args || [];
	                state = state || [ context , args ];

	                for ( var i = 0 , il = list.length ; i < il ; i++ ) {
	                    list[ i ].apply( state[ 0 ] , state[ 1 ] );
	                }

	                list = [];
	            }
	        };

	        this.add = function () {
	            for ( var i = 0 , il = arguments.length ; i < il ; i ++ ) {
	                list.push( arguments[ i ] );
	            }

	            if ( state ) {
	                exec();
	            }

	            return this;
	        };

	        this.execute = function () {
	            exec( this , arguments );
	            return this;
	        };
	    };

	    var Server = function ( db , name ) {
	        var that = this,
	            closed = false;

	        this.name = name;

	    		this.getIndexedDB = function () {
	    			return db;
	    		};

	        this.add = function( table ) {
	            if ( closed ) {
	                throw 'Database has been closed';
	            }

	            var records = [];
	            var counter = 0;

	            for (var i = 0; i < arguments.length - 1; i++) {
	                if (Array.isArray(arguments[i + 1])) {
	                    for (var j = 0; j < (arguments[i + 1]).length; j++) {
	                        records[counter] = (arguments[i + 1])[j];
	                        counter++;
	                    }
	                } else {
	                    records[counter] = arguments[i + 1];
	                    counter++;
	                }
	            }

	            var transaction = db.transaction( table , transactionModes.readwrite ),
	                store = transaction.objectStore( table );

	            return new Promise(function(resolve, reject){
	              records.forEach( function ( record ) {
	                  var req;
	                  if ( record.item && record.key ) {
	                      var key = record.key;
	                      record = record.item;
	                      req = store.add( record , key );
	                  } else {
	                      req = store.add( record );
	                  }

	                  req.onsuccess = function ( e ) {
	                      var target = e.target;
	                      var keyPath = target.source.keyPath;
	                      if ( keyPath === null ) {
	                          keyPath = '__id__';
	                      }
	                      Object.defineProperty( record , keyPath , {
	                          value: target.result,
	                          enumerable: true
	                      });
	                  };
	              } );

	              transaction.oncomplete = function () {
	                  resolve( records , that );
	              };
	              transaction.onerror = function ( e ) {
	                  // prevent Firefox from throwing a ConstraintError and aborting (hard)
	                  // https://bugzilla.mozilla.org/show_bug.cgi?id=872873
	                  e.preventDefault();
	                  reject( e );
	              };
	              transaction.onabort = function ( e ) {
	                  reject( e );
	              };

	            });
	        };

	        this.updateAndDelete = function( table, updates, deletes ) {
	            if ( closed ) {
	                throw 'Database has been closed';
	            }
	            var transaction = db.transaction( table, transactionModes.readwrite ),
	                store = transaction.objectStore( table ),
	                keyPath = store.keyPath;
	            return new Promise(function(resolve, reject) {
	                updates.forEach(function(record) {
	                  if ( record.item && record.key ) {
	                      var key = record.key;
	                      record = record.item;
	                      store.put( record , key );
	                  } else {
	                      store.put( record );
	                  }
	                });
	                deletes.forEach(function(record) {
	                  store['delete']( record[keyPath] );
	                });
	                transaction.oncomplete = function() {
	                  resolve([updates, deletes]);
	                };
	                transaction.onerror = function(e) {
	                  reject(e);
	                };
	            });
	        };

	        this.update = function( table ) {
	            if ( closed ) {
	                throw 'Database has been closed';
	            }

	            var records = [],
	                arg;
	            for ( var i = 1 ; i < arguments.length ; i++ ) {
	                arg = arguments[i];
	                if (Array.isArray(arg)) {
	                  records = records.concat(arg);
	                } else {
	                  records.push(arg);
	                }
	            }

	            var transaction = db.transaction( table , transactionModes.readwrite ),
	                store = transaction.objectStore( table ),
	                keyPath = store.keyPath;

	            return new Promise(function(resolve, reject){
	              records.forEach( function ( record ) {
	                  var req;
	                  var count;
	                  if ( record.item && record.key ) {
	                      var key = record.key;
	                      record = record.item;
	                      req = store.put( record , key );
	                  } else {
	                      req = store.put( record );
	                  }

	                  req.onsuccess = function ( e ) {
	                      // deferred.notify(); es6 promise can't notify
	                  };
	                  req.onerror = function ( e ) {

	                  };
	              } );

	              transaction.oncomplete = function () {
	                  resolve( records , that );
	              };
	              transaction.onerror = function ( e ) {
	                  reject( e );
	              };
	              transaction.onabort = function ( e ) {
	                  reject( e );
	              };
	            });

	        };

	        this.remove = function ( table , keys ) {
	            if ( closed ) {
	                throw 'Database has been closed';
	            }
	            var transaction = db.transaction( table , transactionModes.readwrite ),
	                store = transaction.objectStore( table );

	            return new Promise(function(resolve, reject){
	              if (!Array.isArray(keys)) {
	                keys = [keys];
	              }
	              keys.forEach(function(key) {
	                store['delete']( key );
	              });
	              transaction.oncomplete = function ( ) {
	                  resolve( keys );
	              };
	              transaction.onerror = function ( e ) {
	                  reject( e );
	              };
	              transaction.onabort = function ( e ) {
	                  reject( e );
	              }
	            });
	        };

	        this.clear = function ( table ) {
	            if ( closed ) {
	                throw 'Database has been closed';
	            }
	            var transaction = db.transaction( table , transactionModes.readwrite ),
	                store = transaction.objectStore( table );

	            var req = store.clear();
	            return new Promise(function(resolve, reject){
	              transaction.oncomplete = function ( ) {
	                  resolve( );
	              };
	              transaction.onerror = function ( e ) {
	                  reject( e );
	              };
	            });
	        };

	        this.close = function ( ) {
	            // if closed, just do nothing
	            if ( !closed ) {
	              db.close();
	              closed = true;
	              delete dbCache[ name ];
	            }
	        };

	        this.get = function ( table , id ) {
	            if ( closed ) {
	                throw 'Database has been closed';
	            }
	            var transaction = db.transaction( table ),
	                store = transaction.objectStore( table );

	            var req = store.get( id );
	            return new Promise(function(resolve, reject){
	              req.onsuccess = function ( e ) {
	                  resolve( e.target.result );
	              };
	              transaction.onerror = function ( e ) {
	                  reject( e );
	              };
	            });
	        };

	        this.query = function ( table , index ) {
	            if ( closed ) {
	                throw 'Database has been closed';
	            }
	            return new IndexQuery( table , db , index );
	        };

	        this.count = function (table , key) {
	            if ( closed ) {
	                throw 'Database has been closed';
	            }
	            var transaction = db.transaction( table ),
	                store = transaction.objectStore( table );
	        };

	        for ( var i = 0 , il = db.objectStoreNames.length ; i < il ; i++ ) {
	            (function ( storeName ) {
	                that[ storeName ] = { };
	                for ( var i in that ) {
	                    if ( !hasOwn.call( that , i ) || i === 'close' ) {
	                        continue;
	                    }
	                    that[ storeName ][ i ] = (function ( i ) {
	                        return function () {
	                            var args = [ storeName ].concat( [].slice.call( arguments , 0 ) );
	                            return that[ i ].apply( that , args );
	                        };
	                    })( i );
	                }
	            })( db.objectStoreNames[ i ] );
	        }
	    };

	    var IndexQuery = function ( table , db , indexName ) {
	        var that = this;
	        var modifyObj = false;
	        var removeObj = false;

	        var runQuery = function ( type, args , cursorType , direction, limitRange, filters , mapper ) {
	            return new Promise(function(resolve, reject){
	              var mode = (modifyObj || removeObj) ? transactionModes.readwrite : transactionModes.readonly;
	              var transaction = db.transaction( table, mode ),
	                  store = transaction.objectStore( table ),
	                  index = indexName ? store.index( indexName ) : store,
	                  keyRange = type ? IDBKeyRange[ type ].apply( null, args ) : null,
	                  results = [],
	                  indexArgs = [ keyRange ],
	                  counter = 0;
	              limitRange = limitRange ? limitRange : null;
	              filters = filters ? filters : [];

	              if ( cursorType !== 'count' ) {
	                  indexArgs.push( direction || 'next' );
	              };

	              // create a function that will set in the modifyObj properties into
	              // the passed record.
	              var modifyKeys = modifyObj ? Object.keys(modifyObj) : false;
	              var modifyRecord = function(record) {
	                  for(var i = 0; i < modifyKeys.length; i++) {
	                      var key = modifyKeys[i];
	                      var val = modifyObj[key];
	                      if(val instanceof Function) val = val(record);
	                      record[key] = val;
	                  }
	                  return record;
	              };

	              index[cursorType].apply( index , indexArgs ).onsuccess = function ( e ) {
	                  var cursor = e.target.result;
	                  if ( typeof cursor === typeof 0 ) {
	                      results = cursor;
	                  } else if ( cursor ) {
	                  	if ( limitRange !== null && limitRange[0] > counter) {
	                      	counter = limitRange[0];
	                      	cursor.advance(limitRange[0]);
	                      } else if ( limitRange !== null && counter >= (limitRange[0] + limitRange[1]) ) {
	                          //out of limit range... skip
	                      } else {
	                          var matchFilter = true;
	                          var result = 'value' in cursor ? cursor.value : cursor.key;

	                          filters.forEach( function ( filter ) {
	                              if ( !filter || !filter.length ) {
	                                  //Invalid filter do nothing
	                              } else if ( filter.length === 2 ) {
	                                  matchFilter = matchFilter && (result[filter[0]] === filter[1])
	                              } else {
	                                  if (isFunc(filter[0])) {
	                                    matchFilter = matchFilter && filter[0].apply(undefined,[result]);
	                                  }
	                              }
	                          });

	                          if (matchFilter) {
	                              counter++;
	                              results.push( mapper(result) );
	                              // if we're doing a delete or modify, run it now
	                              if (removeObj) {
	                                cursor['delete']();
	                              } else if(modifyObj) {
	                                  result = modifyRecord(result);
	                                  cursor.update(result);
	                              }
	                          }
	                          cursor['continue']();
	                      }
	                  }
	              };
	              transaction.oncomplete = function () {
	                  resolve( results );
	              };
	              transaction.onerror = function ( e ) {
	                  reject( e );
	              };
	              transaction.onabort = function ( e ) {
	                  reject( e );
	              };
	            });
	        };

	        var Query = function ( type , args ) {
	            var direction = 'next',
	                cursorType = 'openCursor',
	                filters = [],
	                limitRange = null,
	                mapper = defaultMapper,
	                unique = false;

	            var execute = function () {
	                return runQuery( type , args , cursorType , unique ? direction + 'unique' : direction, limitRange, filters , mapper );
	            };

	            var count = function () {
	                direction = null;
	                cursorType = 'count';

	                return {
	                    execute: execute
	                };
	            };
	            var limit = function () {
	                if (isArray(arguments[0])) {
	                  limitRange = arguments[0];
	                } else {
	                  limitRange = Array.prototype.slice.call( arguments , 0 , 2 );
	                }
	                if (limitRange.length == 1) {
	                    limitRange.unshift(0);
	                }
	                if (!isNum(limitRange[1])) {
	                    limitRange = null;
	                }

	                return {
	                    execute: execute,
	                    count: count,
	                    keys: keys,
	                    filter: filter,
	                    asc: asc,
	                    desc: desc,
	                    distinct: distinct,
	                    modify: modify,
	                    limit: limit,
	                    map: map,
	                    remove: remove
	                };
	            };
	            var keys = function (flag) {
	                flag = (undef(flag) ? true : !!flag);
	                if (flag) { cursorType = 'openKeyCursor'; }

	                return {
	                    execute: execute,
	                    // count: count,
	                    keys: keys,
	                    filter: filter,
	                    asc: asc,
	                    desc: desc,
	                    distinct: distinct,
	                    modify: modify,
	                    limit: limit,
	                    map: map,
	                    remove: remove
	                };
	            };
	            var filter = function ( ) {
	                filters.push( Array.prototype.slice.call( arguments , 0 , 2 ) );

	                return {
	                    execute: execute,
	                    count: count,
	                    keys: keys,
	                    filter: filter,
	                    asc: asc,
	                    desc: desc,
	                    distinct: distinct,
	                    modify: modify,
	                    limit: limit,
	                    map: map,
	                    remove: remove
	                };
	            };
	            var asc = function(flag) {
	                flag = (undef(flag) ? true : !!flag);
	                direction = flag ? 'next' : 'prev';

	                return {
	                    execute: execute,
	                    count: count,
	                    keys: keys,
	                    filter: filter,
	                    asc: asc,
	                    desc: desc,
	                    distinct: distinct,
	                    modify: modify,
	                    limit: limit,
	                    map: map,
	                    remove: remove
	                };
	            };
	            var desc = function (flag) {
	                flag = (undef(flag) ? true : !!flag);
	                direction = flag ? 'prev' : 'next';

	                return {
	                    execute: execute,
	                    count: count,
	                    keys: keys,
	                    filter: filter,
	                    asc: asc,
	                    desc: desc,
	                    distinct: distinct,
	                    modify: modify,
	                    limit: limit,
	                    map: map,
	                    remove: remove
	                };
	            };
	            var distinct = function (flag) {
	                flag = (undef(flag) ? true : !!flag);
	                unique = flag;
	                return {
	                    execute: execute,
	                    count: count,
	                    keys: keys,
	                    filter: filter,
	                    asc: asc,
	                    desc: desc,
	                    distinct: distinct,
	                    modify: modify,
	                    limit: limit,
	                    map: map,
	                    remove: remove
	                };
	            };
	            var modify = function(update) {
	                modifyObj = update;
	                return {
	                    execute: execute,
	                    count: count,
	                    keys: keys,
	                    filter: filter,
	                    asc: asc,
	                    desc: desc,
	                    distinct: distinct,
	                    modify: modify,
	                    limit: limit,
	                    map: map,
	                    remove: remove
	                };
	            };
	            var map = function (fn) {
	                if (isFunc(fn)) {
	                  mapper = fn;
	                }

	                return {
	                    execute: execute,
	                    count: count,
	                    keys: keys,
	                    filter: filter,
	                    asc: asc,
	                    desc: desc,
	                    distinct: distinct,
	                    modify: modify,
	                    limit: limit,
	                    map: map,
	                    remove: remove
	                };
	            };
	            var remove = function(flag) {
	                flag = (undef(flag) ? true: !!flag);
	                removeObj = flag;
	                return {
	                    execute: execute,
	                    count: count,
	                    keys: keys,
	                    filter: filter,
	                    asc: asc,
	                    desc: desc,
	                    distinct: distinct,
	                    modify: modify,
	                    limit: limit,
	                    map: map,
	                    remove: remove
	                };
	            };

	            return {
	                execute: execute,
	                count: count,
	                keys: keys,
	                filter: filter,
	                asc: asc,
	                desc: desc,
	                distinct: distinct,
	                modify: modify,
	                limit: limit,
	                map: map,
	                remove: remove
	            };
	        };

	        'only bound upperBound lowerBound'.split(' ').forEach(function (name) {
	            that[name] = function () {
	                return new Query( name , arguments );
	            };
	        });

	        this.filter = function () {
	            var query = new Query( null , null );
	            return query.filter.apply( query , arguments );
	        };

	        this.all = function () {
	            return this.filter();
	        };
	    };

	    var createSchema = function ( e , schema , db ) {
	        if ( typeof schema === 'function' ) {
	            schema = schema();
	        }

	        for ( var tableName in schema ) {
	            var table = schema[ tableName ];
	            var store;
	            if (!hasOwn.call(schema, tableName) || db.objectStoreNames.contains(tableName)) {
	                store = e.currentTarget.transaction.objectStore(tableName);
	            } else {
	                store = db.createObjectStore(tableName, table.key);
	            }

	            for ( var indexKey in table.indexes ) {
	                var index = table.indexes[ indexKey ];
	                try {
	                    store.index(indexKey)
	                } catch (e) {
	                    store.createIndex( indexKey , index.key || indexKey , Object.keys(index).length ? index : { unique: false } );
	                }
	            }
	        }
	    };

	    var open = function ( e , server , version , schema ) {
	        var db = e.target.result;
	        var s = new Server( db , server );
	        var upgrade;

	        dbCache[ server ] = db;

	        return Promise.resolve(s)
	    };

	    var dbCache = {};

	    var db = {
	        version: '0.10.2',
	        open: function ( options ) {
	            var request;

	            return new Promise(function(resolve, reject){
	              if ( dbCache[ options.server ] ) {
	                  open( {
	                      target: {
	                          result: dbCache[ options.server ]
	                      }
	                  } , options.server , options.version , options.schema )
	                  .then(resolve, reject)
	              } else {
	                  // in private mode of Firefox, open will throw error.
	                  try {
	                    request = getIndexedDB().open( options.server , options.version );
	                  } catch (e) {
	                    reject(e);
	                  }
	                  request.onsuccess = function ( e ) {
	                      open( e , options.server , options.version , options.schema )
	                          .then(resolve, reject)
	                  };
	                  request.onupgradeneeded = function ( e ) {
	                      createSchema( e , options.schema , e.target.result );
	                  };
	                  request.onerror = function ( e ) {
	                      reject( e );
	                  };
	              }
	            });
	        },

	        remove: function(server) {
	            return new Promise(function(resolve, reject) {
	              if (!server) {
	                return resolve();
	              }
	              if (typeof server === Server) {
	                server = server.name;
	              }

	              var db;
	              if (typeof server === 'string') {
	                db = dbCache[server];
	              }
	              if (db && typeof db.close === 'function') {
	                db.close();
	              }

	              var request;
	              try {
	                request = getIndexedDB().deleteDatabase(server);
	              } catch ( e ) {
	                reject( e );
	              }
	              request.onsuccess = function( e ) {
	                delete dbCache[server];
	                resolve( server );
	              };
	              request.onerror = function( e ) {
	                reject( e );
	              };
	              request.onblocked = function( e ) {
	                reject( e );
	              };
	            });
	        }
	    };

	    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	        module.exports = db;
	    } else if ( true ) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return db; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        window.db = db;
	    }
	})( window );

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var platform = __webpack_require__(9);
	var xhr = __webpack_require__(82);
	var io = __webpack_require__(19);
	var naturalSort = __webpack_require__(28);
	var deepAccess = __webpack_require__(22);
	var db = __webpack_require__(39);
	var util = __webpack_require__(1);
	var support = __webpack_require__(46);
	var blob = __webpack_require__(37);
	var ajax = __webpack_require__(21);
	var Promise = __webpack_require__(2).Promise;

	module.exports = function (obj) {
	  util.merge(obj, {
	    platform: platform,
	    xhr: xhr,
	    io: io,
	    naturalSort: naturalSort,
	    deepAccess: deepAccess,
	    db: db,
	    util: util,
	    support: support,
	    blob: blob,
	    ajax: ajax,
	    Promise: Promise
	  });
	};

/***/ },
/* 41 */,
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var notundef = util.notundef;

	/**
	 * 多端推送配置项
	 * @private
	 * @property {Boolean} shouldPushNotificationWhenPCOnline 桌面端在线时是否需要发送推送给手机端
	 */
	function PushNotificationMultiportConfig(options) {
	  var self = this;
	  if (notundef(options.shouldPushNotificationWhenPCOnline)) {
	    self.open = options.shouldPushNotificationWhenPCOnline ? 2 : 1;
	  }
	}

	PushNotificationMultiportConfig.getDefaultConfig = function () {
	  return {
	    shouldPushNotificationWhenPCOnline: true
	  };
	};

	PushNotificationMultiportConfig.reverse = function (donnop) {
	  var obj = {
	    shouldPushNotificationWhenPCOnline: +donnop.open !== 1
	  };
	  return obj;
	};

	module.exports = PushNotificationMultiportConfig;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var configBase = __webpack_require__(36);

	// 外层是 service, 内层是 cmd
	var idMap = util.merge({}, configBase.idMap, {
	  // 登录协议
	  auth: {
	    id: 2,
	    // web一键登录
	    login: 3,
	    // 被踢通知
	    kicked: 5,
	    // 退出登录
	    logout: 6,
	    // 多端登陆通知
	    multiPortLogin: 7,
	    // 踢其它端
	    kick: 8
	  },
	  // 用户协议
	  user: {
	    id: 3,
	    // 加入黑名单/从黑名单移除
	    markInBlacklist: 3,
	    // 获取黑名单
	    getBlacklist: 4,
	    // 加入静音列表/从静音列表移除
	    markInMutelist: 5,
	    // 获取静音列表
	    getMutelist: 6,
	    // 获取黑名单和静音列表
	    getRelations: 8,
	    getUsers: 7,
	    updateMyInfo: 10,
	    updateDonnop: 15,
	    // syncRobot: 16,
	    syncMyInfo: 109,
	    syncUpdateMyInfo: 110
	  },
	  // 通知
	  notify: {
	    id: 4,
	    // 标记通知已读
	    markRead: 3,
	    // 离线session+team消息通知
	    syncOfflineMsgs: 4,
	    // 批量标记协议已读
	    batchMarkRead: 5,
	    // 离线system消息同步通知
	    syncOfflineSysMsgs: 6,
	    // 漫游消息同步通知
	    // 每个会话返回一个包
	    syncRoamingMsgs: 9,
	    // 消息已读同步通知
	    syncMsgReceipts: 12,
	    // 同步机器人列表
	    syncRobots: 15,
	    syncBroadcastMsgs: 16
	  },
	  // 同步
	  sync: {
	    id: 5,
	    // 同步
	    sync: 1,
	    // 同步群成员
	    syncTeamMembers: 2
	  },
	  // 消息
	  msg: {
	    id: 7,
	    // 发送消息
	    sendMsg: 1,
	    // 消息通知
	    msg: 2,
	    // 系统通知通知
	    sysMsg: 3,
	    // 获取单人历史消息
	    getHistoryMsgs: 6,
	    // 发送自定义系统通知
	    sendCustomSysMsg: 7,
	    // 获取包含关键词的单人历史消息
	    searchHistoryMsgs: 8,
	    // 删除会话
	    deleteSessions: 9,
	    // 获取会话列表
	    getSessions: 10,
	    // 发送消息后发送方的多端同步通知
	    syncSendMsg: 101,
	    // 发送消息已读回执
	    sendMsgReceipt: 11,
	    // 收到消息已读回执
	    msgReceipt: 12,
	    // 撤回消息
	    deleteMsg: 13,
	    // 撤回消息通知
	    msgDeleted: 14,
	    markSessionAck: 16,
	    // 广播通知
	    broadcastMsg: 17
	  },
	  // 群
	  team: {
	    id: 8,
	    // 创建群
	    createTeam: 1,
	    // 发送群消息
	    sendTeamMsg: 2,
	    // 群消息通知
	    teamMsg: 3,
	    // 群消息列表通知
	    teamMsgs: 4,
	    // 拉人入群
	    addTeamMembers: 5,
	    // 踢人出群
	    removeTeamMembers: 6,
	    // 修改群资料
	    updateTeam: 7,
	    // 退出群
	    leaveTeam: 8,
	    // 获取群
	    getTeam: 9,
	    // 获取群列表
	    getTeams: 10,
	    // 获取群成员
	    getTeamMembers: 11,
	    // 解散群
	    dismissTeam: 12,
	    // 申请入群
	    applyTeam: 13,
	    // 同意入群申请
	    passTeamApply: 14,
	    // 拒绝入群申请
	    rejectTeamApply: 15,
	    // 添加群管理员
	    addTeamManagers: 16,
	    // 移除群管理员
	    removeTeamManagers: 17,
	    // 转让群
	    transferTeam: 18,
	    // 修改自己的群资料
	    updateInfoInTeam: 19,
	    // 修改别人的群昵称
	    updateNickInTeam: 20,
	    // 接受入群邀请
	    acceptTeamInvite: 21,
	    // 拒绝入群邀请
	    rejectTeamInvite: 22,
	    // 获取群组历史消息
	    getTeamHistoryMsgs: 23,
	    // 获取包含关键词的群组历史消息
	    searchTeamHistoryMsgs: 24,
	    // 群成员禁言
	    updateMuteStateInTeam: 25,
	    // 获取指定群的我的群信息
	    getMyTeamMembers: 26,
	    // 获取群禁言成员列表
	    getMutedTeamMembers: 27,
	    // 同步所有群的我的群信息
	    syncMyTeamMembers: 126,
	    // 同步群列表通知
	    syncTeams: 109,
	    // 同步群成员通知
	    syncTeamMembers: 111,
	    // 多端同步创建群通知
	    syncCreateTeam: 101,
	    // 多端同步发送群消息通知
	    syncSendTeamMsg: 102,
	    // 多端同步更新群成员通知
	    syncUpdateTeamMember: 119
	  },
	  // 好友协议
	  friend: {
	    id: 12,
	    // 添加好友
	    friendRequest: 1,
	    // 添加好友多端同步
	    syncFriendRequest: 101,
	    // 删除好友
	    deleteFriend: 2,
	    // 删除好友多端同步
	    syncDeleteFriend: 102,
	    // 更新好友
	    updateFriend: 3,
	    // 更新好友多端同步
	    syncUpdateFriend: 103,
	    // 获取好友列表
	    getFriends: 4
	  },
	  chatroom: {
	    id: 13,
	    getChatroomAddress: 1
	  },
	  // 过滤协议, 此协议下的消息都会转发给第三方服务器, 由第三方服务器处理后得到最终发送的消息内容
	  filter: {
	    id: 101,
	    // 发送过滤消息
	    sendFilterMsg: 1,
	    // 过滤消息通知
	    filterMsg: 2,
	    // 过滤系统通知通知
	    filterSysMsg: 3,
	    // 发送过滤自定义系统通知
	    sendFilterCustomSysMsg: 7
	  },
	  // 事件服务协议 发布-订阅 模型
	  eventService: {
	    id: 14,
	    publishEvent: 1,
	    pushEvent: 2,
	    subscribeEvent: 3,
	    unSubscribeEventsByAccounts: 4,
	    unSubscribeEventsByType: 5,
	    querySubscribeEventsByAccounts: 6,
	    querySubscribeEventsByType: 7,
	    pushEvents: 9
	  }
	});

	/**
	 * 命令配置
	 * params 说明: 如果类型是 Property, 如果没有 entity, entity 值就是 name
	 */
	var cmdConfig = util.merge({}, configBase.cmdConfig, {
	  // 登录
	  login: { sid: idMap.auth.id, cid: idMap.auth.login, params: [{ type: 'Property', name: 'login' }] },
	  // 退出登录
	  logout: { sid: idMap.auth.id, cid: idMap.auth.logout },
	  // 踢其它端
	  kick: { sid: idMap.auth.id, cid: idMap.auth.kick, params: [{ type: 'StrArray', name: 'deviceIds' }] },

	  // 加入黑名单/从黑名单移除
	  markInBlacklist: { sid: idMap.user.id, cid: idMap.user.markInBlacklist, params: [{ type: 'String', name: 'account' }, { type: 'bool', name: 'isAdd' }] },
	  // 获取黑名单
	  getBlacklist: { sid: idMap.user.id, cid: idMap.user.getBlacklist, params: [{ type: 'long', name: 'time' }] },
	  // 加入静音列表/从静音列表移除
	  markInMutelist: { sid: idMap.user.id, cid: idMap.user.markInMutelist, params: [{ type: 'String', name: 'account' }, { type: 'bool', name: 'isAdd' }] },
	  // 获取静音列表
	  getMutelist: { sid: idMap.user.id, cid: idMap.user.getMutelist, params: [{ type: 'long', name: 'time' }] },
	  getRelations: { sid: idMap.user.id, cid: idMap.user.getRelations, params: [{ type: 'long', name: 'timetag' }] },
	  getUsers: { sid: idMap.user.id, cid: idMap.user.getUsers, params: [{ type: 'StrArray', name: 'accounts' }] },
	  updateMyInfo: { sid: idMap.user.id, cid: idMap.user.updateMyInfo, params: [{ type: 'Property', name: 'user' }] },
	  updateDonnop: { sid: idMap.user.id, cid: idMap.user.updateDonnop, params: [{ type: 'Property', name: 'donnop' }] },

	  // 标记通知已读, 实际未使用, 统一使用批量标记协议已读
	  markRead: { sid: idMap.notify.id, cid: idMap.notify.markRead, params: [{ type: 'long', name: 'id' }, { type: 'ph', name: 'ph' }] },
	  // 批量标记协议已读
	  batchMarkRead: { sid: idMap.notify.id, cid: idMap.notify.batchMarkRead, params: [{ type: 'byte', name: 'sid' }, { type: 'byte', name: 'cid' }, { type: 'LongArray', name: 'ids' }] },

	  // 同步 4_4(离线session+team消息), 4_6(离线system消息), 8_109(群资料)
	  sync: { sid: idMap.sync.id, cid: idMap.sync.sync, params: [{ type: 'Property', name: 'sync' }] },
	  // 同步群成员
	  syncTeamMembers: { sid: idMap.sync.id, cid: idMap.sync.syncTeamMembers, params: [{ type: 'LongLongMap', name: 'sync' }] },

	  // 发送消息
	  sendMsg: { sid: idMap.msg.id, cid: idMap.msg.sendMsg, params: [{ type: 'Property', name: 'msg' }] },
	  // 获取单人历史消息
	  getHistoryMsgs: { sid: idMap.msg.id, cid: idMap.msg.getHistoryMsgs, params: [{ type: 'String', name: 'to' }, { type: 'long', name: 'beginTime' }, { type: 'long', name: 'endTime' }, { type: 'long', name: 'lastMsgId' }, { type: 'int', name: 'limit' }, { type: 'bool', name: 'reverse' }] },
	  // 发送自定义系统通知
	  sendCustomSysMsg: { sid: idMap.msg.id, cid: idMap.msg.sendCustomSysMsg, params: [{ type: 'Property', name: 'sysMsg' }] },
	  // 获取包含关键词的单人历史消息
	  searchHistoryMsgs: { sid: idMap.msg.id, cid: idMap.msg.searchHistoryMsgs, params: [{ type: 'String', name: 'to' }, { type: 'long', name: 'beginTime' }, { type: 'long', name: 'endTime' }, { type: 'String', name: 'keyword' }, { type: 'int', name: 'limit' }, { type: 'bool', name: 'reverse' }] },
	  // 获取会话列表
	  getSessions: { sid: idMap.msg.id, cid: idMap.msg.getSessions, params: [{ type: 'long', name: 'time' }] },
	  // 删除会话
	  deleteSessions: { sid: idMap.msg.id, cid: idMap.msg.deleteSessions, params: [{ type: 'StrArray', name: 'sessions' }] },
	  sendMsgReceipt: { sid: idMap.msg.id, cid: idMap.msg.sendMsgReceipt, params: [{ type: 'Property', name: 'msgReceipt' }] },
	  deleteMsg: { sid: idMap.msg.id, cid: idMap.msg.deleteMsg, params: [{ type: 'Property', name: 'sysMsg' }] },
	  markSessionAck: { sid: idMap.msg.id, cid: idMap.msg.markSessionAck, params: [{ type: 'byte', name: 'scene' }, { type: 'String', name: 'to' }, { type: 'long', name: 'timetag' }] },

	  // 创建群
	  createTeam: { sid: idMap.team.id, cid: idMap.team.createTeam, params: [{ type: 'Property', name: 'team' }, { type: 'StrArray', name: 'accounts' }, { type: 'String', name: 'ps' }] },
	  // 发送群消息
	  sendTeamMsg: { sid: idMap.team.id, cid: idMap.team.sendTeamMsg, params: [{ type: 'Property', name: 'msg' }] },
	  // 拉人入群
	  addTeamMembers: { sid: idMap.team.id, cid: idMap.team.addTeamMembers, params: [{ type: 'long', name: 'teamId' }, { type: 'StrArray', name: 'accounts' }, { type: 'String', name: 'ps' }] },
	  // 踢人出群
	  removeTeamMembers: { sid: idMap.team.id, cid: idMap.team.removeTeamMembers, params: [{ type: 'long', name: 'teamId' }, { type: 'StrArray', name: 'accounts' }] },
	  // 更新群
	  updateTeam: { sid: idMap.team.id, cid: idMap.team.updateTeam, params: [{ type: 'Property', name: 'team' }] },
	  // 退出群
	  leaveTeam: { sid: idMap.team.id, cid: idMap.team.leaveTeam, params: [{ type: 'long', name: 'teamId' }] },
	  // 获取群
	  getTeam: { sid: idMap.team.id, cid: idMap.team.getTeam, params: [{ type: 'long', name: 'teamId' }] },
	  // 获取群列表
	  getTeams: { sid: idMap.team.id, cid: idMap.team.getTeams, params: [{ type: 'long', name: 'timetag' }] },
	  // 获取群成员
	  getTeamMembers: { sid: idMap.team.id, cid: idMap.team.getTeamMembers, params: [{ type: 'long', name: 'teamId' }, { type: 'long', name: 'timetag' }] },
	  // 解散群
	  dismissTeam: { sid: idMap.team.id, cid: idMap.team.dismissTeam, params: [{ type: 'long', name: 'teamId' }] },
	  // 申请入群
	  applyTeam: { sid: idMap.team.id, cid: idMap.team.applyTeam, params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'ps' }] },
	  // 同意入群申请
	  passTeamApply: { sid: idMap.team.id, cid: idMap.team.passTeamApply, params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'from' }] },
	  // 拒绝入群申请
	  rejectTeamApply: { sid: idMap.team.id, cid: idMap.team.rejectTeamApply, params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'from' }, { type: 'String', name: 'ps' }] },
	  // 添加群管理员
	  addTeamManagers: { sid: idMap.team.id, cid: idMap.team.addTeamManagers, params: [{ type: 'long', name: 'teamId' }, { type: 'StrArray', name: 'accounts' }] },
	  // 移除群管理员
	  removeTeamManagers: { sid: idMap.team.id, cid: idMap.team.removeTeamManagers, params: [{ type: 'long', name: 'teamId' }, { type: 'StrArray', name: 'accounts' }] },
	  // 转让群
	  transferTeam: { sid: idMap.team.id, cid: idMap.team.transferTeam, params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'account' }, { type: 'bool', name: 'leave' }] },
	  // 修改自己的群资料
	  updateInfoInTeam: { sid: idMap.team.id, cid: idMap.team.updateInfoInTeam, params: [{ type: 'Property', name: 'teamMember' }] },
	  // 修改别人的群昵称
	  updateNickInTeam: { sid: idMap.team.id, cid: idMap.team.updateNickInTeam, params: [{ type: 'Property', name: 'teamMember' }] },
	  // 接受入群邀请
	  acceptTeamInvite: { sid: idMap.team.id, cid: idMap.team.acceptTeamInvite, params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'from' }] },
	  // 拒绝入群邀请
	  rejectTeamInvite: { sid: idMap.team.id, cid: idMap.team.rejectTeamInvite, params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'from' }, { type: 'String', name: 'ps' }] },
	  // 获取群组历史消息
	  getTeamHistoryMsgs: { sid: idMap.team.id, cid: idMap.team.getTeamHistoryMsgs, params: [{ type: 'long', name: 'to' }, { type: 'long', name: 'beginTime' }, { type: 'long', name: 'endTime' }, { type: 'long', name: 'lastMsgId' }, { type: 'int', name: 'limit' }, { type: 'bool', name: 'reverse' }] },
	  // 获取包含关键词的群组历史消息
	  searchTeamHistoryMsgs: { sid: idMap.team.id, cid: idMap.team.searchTeamHistoryMsgs, params: [{ type: 'long', name: 'to' }, { type: 'long', name: 'beginTime' }, { type: 'long', name: 'endTime' }, { type: 'String', name: 'keyword' }, { type: 'int', name: 'limit' }, { type: 'bool', name: 'reverse' }] },
	  // 群成员禁言
	  updateMuteStateInTeam: { sid: idMap.team.id, cid: idMap.team.updateMuteStateInTeam, params: [{ type: 'long', name: 'teamId' }, { type: 'String', name: 'account' }, { type: 'int', name: 'mute' }] },
	  getMyTeamMembers: { sid: idMap.team.id, cid: idMap.team.getMyTeamMembers, params: [{ type: 'LongArray', name: 'teamIds' }] },
	  getMutedTeamMembers: { sid: idMap.team.id, cid: idMap.team.getMutedTeamMembers, params: [{ type: 'long', name: 'teamId' }] },

	  // 添加好友
	  friendRequest: { sid: idMap.friend.id, cid: idMap.friend.friendRequest, params: [{ type: 'String', name: 'account' }, { type: 'byte', name: 'type' }, { type: 'String', name: 'ps' }] },
	  // 删除好友
	  deleteFriend: { sid: idMap.friend.id, cid: idMap.friend.deleteFriend, params: [{ type: 'String', name: 'account' }] },
	  // 更新好友
	  updateFriend: { sid: idMap.friend.id, cid: idMap.friend.updateFriend, params: [{ type: 'Property', name: 'friend' }] },
	  // 获取好友列表
	  getFriends: { sid: idMap.friend.id, cid: idMap.friend.getFriends, params: [{ type: 'long', name: 'timetag' }] },
	  getChatroomAddress: { sid: idMap.chatroom.id, cid: idMap.chatroom.getChatroomAddress, params: [{ type: 'long', name: 'chatroomId' }] },
	  // 发送过滤消息
	  sendFilterMsg: { sid: idMap.filter.id, cid: idMap.filter.sendFilterMsg, params: [{ type: 'Property', name: 'msg' }] },
	  // 发送过滤自定义系统通知
	  sendFilterCustomSysMsg: { sid: idMap.filter.id, cid: idMap.filter.sendFilterCustomSysMsg, params: [{ type: 'Property', name: 'sysMsg' }] },
	  // 发布事件
	  publishEvent: {
	    sid: idMap.eventService.id,
	    cid: idMap.eventService.publishEvent,
	    params: [{ type: 'Property', name: 'msgEvent' }]
	  },
	  pushEvent: {
	    sid: idMap.eventService.id,
	    cid: idMap.eventService.pushEvent
	  },
	  subscribeEvent: {
	    sid: idMap.eventService.id,
	    cid: idMap.eventService.subscribeEvent,
	    params: [{
	      type: 'Property',
	      name: 'msgEventSubscribe'
	    }, {
	      type: 'StrArray', name: 'accounts'
	    }]
	  },
	  unSubscribeEventsByAccounts: {
	    sid: idMap.eventService.id,
	    cid: idMap.eventService.unSubscribeEventsByAccounts,
	    params: [{
	      type: 'Property',
	      name: 'msgEventSubscribe'
	    }, {
	      type: 'StrArray', name: 'accounts'
	    }]
	  },
	  unSubscribeEventsByType: {
	    sid: idMap.eventService.id,
	    cid: idMap.eventService.unSubscribeEventsByType,
	    params: [{ type: 'Property', name: 'msgEventSubscribe' }]
	  },
	  querySubscribeEventsByAccounts: {
	    sid: idMap.eventService.id,
	    cid: idMap.eventService.querySubscribeEventsByAccounts,
	    params: [{
	      type: 'Property',
	      name: 'msgEventSubscribe'
	    }, {
	      type: 'StrArray', name: 'accounts'
	    }]
	  },
	  querySubscribeEventsByType: {
	    sid: idMap.eventService.id,
	    cid: idMap.eventService.querySubscribeEventsByType,
	    params: [{ type: 'Property', name: 'msgEventSubscribe' }]
	  },
	  pushEvents: {
	    sid: idMap.eventService.id,
	    cid: idMap.eventService.pushEvents
	  }
	});

	/**
	 * 回包配置
	 * response 说明: 如果没有 entity, entity 值就是 name
	 */
	var packetConfig = util.merge({}, configBase.packetConfig, {
	  // 登录
	  '2_3': { service: 'auth', cmd: 'login', response: [{ type: 'Property', name: 'loginRes' }, { type: 'PropertyArray', name: 'loginPorts', entity: 'loginPort' }] },
	  // 被踢通知
	  '2_5': { service: 'auth', cmd: 'kicked', response: [{ type: 'Number', name: 'from' }, { type: 'Number', name: 'reason' }] },
	  // 退出登录
	  '2_6': { service: 'auth', cmd: 'logout' },
	  // 多端登陆通知
	  '2_7': { service: 'auth', cmd: 'multiPortLogin', response: [{ type: 'Number', name: 'state' }, { type: 'PropertyArray', name: 'loginPorts', entity: 'loginPort' }] },
	  // 踢其它端
	  '2_8': { service: 'auth', cmd: 'kick', response: [{ type: 'StrArray', name: 'deviceIds' }] },

	  // 加入黑名单/从黑名单移除
	  '3_3': { service: 'user', cmd: 'markInBlacklist' },
	  // 加入黑名单/从黑名单移除多端同步
	  '3_103': { service: 'user', cmd: 'syncMarkInBlacklist', response: [{ type: 'String', name: 'account' }, { type: 'Boolean', name: 'isAdd' }] },
	  // 获取黑名单
	  '3_4': { service: 'user', cmd: 'getBlacklist', response: [{ type: 'StrArray', name: 'blacklist' }] },
	  // 加入静音列表/从静音列表移除
	  '3_5': { service: 'user', cmd: 'markInMutelist' },
	  // 加入静音列表/从静音列表移除多端同步
	  '3_105': { service: 'user', cmd: 'syncMarkInMutelist', response: [{ type: 'String', name: 'account' }, { type: 'Boolean', name: 'isAdd' }] },
	  // 获取静音列表
	  '3_6': { service: 'user', cmd: 'getMutelist', response: [{ type: 'StrArray', name: 'mutelist' }] },
	  // 获取黑名单和静音列表
	  '3_8': { service: 'user', cmd: 'getRelations', response: [{ type: 'PropertyArray', name: 'specialRelations', entity: 'specialRelation' }, { type: 'Number', name: 'timetag' }] },
	  '3_7': { service: 'user', cmd: 'getUsers', response: [{ type: 'PropertyArray', name: 'users', entity: 'user' }] },
	  '3_10': { service: 'user', cmd: 'updateMyInfo', response: [{ type: 'Number', name: 'timetag' }] },
	  '3_15': { service: 'user', cmd: 'updateDonnop', response: [{ type: 'Number', name: 'timetag' }] },
	  // '3_16': {service: 'user', cmd: 'syncRobot', response: [
	  //     {type: 'PropertyArray', name: 'robots', entity: 'robot'},
	  // ]},
	  '3_115': { service: 'user', cmd: 'syncUpdateDonnop', response: [{ type: 'Property', name: 'donnop' }, { type: 'Number', name: 'timetag' }] },
	  '3_109': { service: 'user', cmd: 'syncMyInfo', response: [{ type: 'Property', name: 'user' }, { type: 'Number', name: 'timetag' }] },
	  '3_110': { service: 'user', cmd: 'syncUpdateMyInfo', response: [{ type: 'Property', name: 'user' }] },

	  // 通知包
	  '4_1': { service: 'notify' },
	  '4_2': { service: 'notify' },
	  '4_3': { service: 'notify', cmd: 'markRead' },
	  // 离线session+team消息同步通知
	  '4_4': { service: 'notify', cmd: 'syncOfflineMsgs', response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }] },
	  // 批量标记协议已读
	  '4_5': { service: 'notify', cmd: 'batchMarkRead' },
	  // 离线sysMsg通知
	  '4_6': { service: 'notify', cmd: 'syncOfflineSysMsgs', response: [{ type: 'PropertyArray', name: 'sysMsgs', entity: 'sysMsg' }] },
	  // 漫游消息同步通知
	  '4_9': { service: 'notify', cmd: 'syncRoamingMsgs', response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }] },
	  // 消息已读同步通知
	  '4_12': { service: 'notify', cmd: 'syncMsgReceipts', response: [{ type: 'PropertyArray', name: 'msgReceipts', entity: 'msgReceipt' }, { type: 'Number', name: 'timetag' }] },
	  '4_13': { service: 'notify', cmd: 'syncDonnop', response: [{ type: 'Property', name: 'donnop' }, { type: 'Number', name: 'timetag' }] },
	  '4_14': { service: 'notify', cmd: 'syncSessionAck', response: [{ type: 'StrLongMap', name: 'p2p' }, { type: 'LongLongMap', name: 'team' }, { type: 'Number', name: 'timetag' }] },
	  '4_15': { service: 'notify', cmd: 'syncRobots', response: [{ type: 'PropertyArray', name: 'robots', entity: 'robot' }] },
	  '4_16': { service: 'notify', cmd: 'syncBroadcastMsgs', response: [{ type: 'PropertyArray', name: 'broadcastMsgs', entity: 'broadcastMsg' }] },
	  // 离线过滤的消息通知
	  '4_100': { service: 'notify', cmd: 'syncOfflineFilterMsgs', response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }] },
	  // 离线过滤的sysMsg通知
	  '4_101': { service: 'notify', cmd: 'syncOfflineFilterSysMsgs', response: [{ type: 'PropertyArray', name: 'sysMsgs', entity: 'sysMsg' }] },
	  // 同步
	  '5_1': { service: 'sync', cmd: 'syncDone', response: [{ type: 'Number', name: 'timetag' }] },
	  // 同步群成员
	  '5_2': { service: 'sync', cmd: 'syncTeamMembersDone', response: [{ type: 'Number', name: 'timetag' }] },
	  // 发送消息
	  '7_1': { service: 'msg', cmd: 'sendMsg', response: [{ type: 'Property', name: 'msg' }], trivialErrorCodes: [7101] },
	  // 消息通知
	  '7_2': { service: 'msg', cmd: 'msg', response: [{ type: 'Property', name: 'msg' }] },
	  // 系统通知通知
	  '7_3': { service: 'msg', cmd: 'sysMsg', response: [{ type: 'Property', name: 'sysMsg' }] },
	  // 获取单人历史消息
	  '7_6': { service: 'msg', cmd: 'getHistoryMsgs', response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }] },
	  // 发送自定义系统通知
	  '7_7': { service: 'msg', cmd: 'sendCustomSysMsg', trivialErrorCodes: [7101] },
	  // 获取包含关键词的单人历史消息
	  '7_8': { service: 'msg', cmd: 'searchHistoryMsgs', response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }] },
	  '7_9': { service: 'msg', cmd: 'deleteSessions' },
	  '7_10': { service: 'msg', cmd: 'getSessions', response: [{ type: 'StrArray', name: 'sessions' }] },
	  // 发送消息后发送方的多端同步通知
	  '7_101': { service: 'msg', cmd: 'syncSendMsg', response: [{ type: 'Property', name: 'msg' }] },
	  '7_11': { service: 'msg', cmd: 'sendMsgReceipt', response: [{ type: 'Property', name: 'msgReceipt' }] },
	  '7_12': { service: 'msg', cmd: 'msgReceipt', response: [{ type: 'Property', name: 'msgReceipt' }] },
	  '7_13': { service: 'msg', cmd: 'onDeleteMsg' },
	  '7_14': { service: 'msg', cmd: 'onMsgDeleted', response: [{ type: 'Property', name: 'sysMsg' }] },
	  '7_15': { service: 'msg', cmd: 'onDeleteMsgOfflineRoaming', response: [{ type: 'PropertyArray', name: 'sysMsgs', entity: 'sysMsg' }, { type: 'Number', name: 'timetag' }, { type: 'Number', name: 'type' }] },
	  '7_16': { service: 'msg', cmd: 'onMarkSessionAck' },
	  '7_17': { service: 'msg', cmd: 'broadcastMsg', response: [{ type: 'Property', name: 'broadcastMsg' }] },
	  '7_116': { service: 'msg', cmd: 'syncMarkSessionAck', response: [{ type: 'Number', name: 'scene' }, { type: 'String', name: 'to' }, { type: 'Number', name: 'timetag' }] },
	  // 创建群
	  '8_1': { service: 'team', cmd: 'createTeam', response: [{ type: 'Property', name: 'team' }] },
	  // 发送群消息
	  '8_2': { service: 'team', cmd: 'sendTeamMsg', response: [{ type: 'Property', name: 'msg' }] },
	  // 群消息通知
	  '8_3': { service: 'team', cmd: 'teamMsg', response: [{ type: 'Property', name: 'msg' }] },
	  // 群消息列表通知
	  '8_4': { service: 'team', cmd: 'teamMsgs', response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }] },
	  // 拉人入群
	  '8_5': { service: 'team', cmd: 'addTeamMembers' },
	  // 踢人出群
	  '8_6': { service: 'team', cmd: 'removeTeamMembers' },
	  // 更新群
	  '8_7': { service: 'team', cmd: 'updateTeam', response: [{ type: 'Number', name: 'id' }, { type: 'Number', name: 'time' }] },
	  // 退出群
	  '8_8': { service: 'team', cmd: 'leaveTeam' },
	  // 获取群
	  '8_9': { service: 'team', cmd: 'getTeam', response: [{ type: 'Property', name: 'team' }] },
	  // 获取群列表
	  '8_10': { service: 'team', cmd: 'getTeams', response: [{ type: 'PropertyArray', name: 'teams', entity: 'team' }, { type: 'Number', name: 'timetag' }] },
	  // 获取群成员
	  '8_11': { service: 'team', cmd: 'getTeamMembers', response: [{ type: 'Number', name: 'teamId' }, { type: 'PropertyArray', name: 'members', entity: 'teamMember' }, { type: 'Number', name: 'timetag' }] },
	  // 解散群
	  '8_12': { service: 'team', cmd: 'dismissTeam' },
	  // 申请入群
	  '8_13': { service: 'team', cmd: 'applyTeam', response: [{ type: 'Property', name: 'team' }] },
	  // 同意入群申请
	  '8_14': { service: 'team', cmd: 'passTeamApply' },
	  // 拒绝入群申请
	  '8_15': { service: 'team', cmd: 'rejectTeamApply' },
	  // 添加群管理员
	  '8_16': { service: 'team', cmd: 'addTeamManagers' },
	  // 移除群管理员
	  '8_17': { service: 'team', cmd: 'removeTeamManagers' },
	  // 转让群
	  '8_18': { service: 'team', cmd: 'transferTeam' },
	  // 修改自己的群资料
	  '8_19': { service: 'team', cmd: 'updateInfoInTeam' },
	  // 修改别人的群昵称
	  '8_20': { service: 'team', cmd: 'updateNickInTeam' },
	  // 接受入群邀请
	  '8_21': { service: 'team', cmd: 'acceptTeamInvite', response: [{ type: 'Property', name: 'team' }] },
	  // 拒绝入群邀请
	  '8_22': { service: 'team', cmd: 'rejectTeamInvite' },
	  // 获取群组历史消息
	  '8_23': { service: 'team', cmd: 'getTeamHistoryMsgs', response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }] },
	  // 获取包含关键词的群组历史消息
	  '8_24': { service: 'team', cmd: 'searchTeamHistoryMsgs', response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }] },
	  '8_25': { service: 'team', cmd: 'updateMuteStateInTeam' },
	  '8_26': { service: 'team', cmd: 'getMyTeamMembers', response: [{ type: 'PropertyArray', name: 'teamMembers', entity: 'teamMember' }] },
	  '8_27': { service: 'team', cmd: 'getMutedTeamMembers', response: [{ type: 'Number', name: 'teamId' }, { type: 'PropertyArray', name: 'teamMembers', entity: 'teamMember' }] },
	  '8_126': { service: 'team', cmd: 'syncMyTeamMembers', response: [{ type: 'PropertyArray', name: 'teamMembers', entity: 'teamMember' }, { type: 'Number', name: 'timetag' }] },
	  // 同步群列表通知
	  '8_109': { service: 'team', cmd: 'syncTeams', response: [{ type: 'Number', name: 'timetag' }, { type: 'PropertyArray', name: 'teams', entity: 'team' }] },
	  // 同步群成员通知
	  '8_111': { service: 'team', cmd: 'syncTeamMembers', response: [{ type: 'Number', name: 'teamId' }, { type: 'PropertyArray', name: 'members', entity: 'teamMember' }, { type: 'Number', name: 'timetag' }] },
	  // 多端同步创建群通知
	  '8_101': { service: 'team', cmd: 'syncCreateTeam', response: [{ type: 'Property', name: 'team' }] },
	  // 多端同步发送群消息通知
	  '8_102': { service: 'team', cmd: 'syncSendTeamMsg', response: [{ type: 'Property', name: 'msg' }] },
	  // 多端同步更新群成员通知
	  '8_119': { service: 'team', cmd: 'syncUpdateTeamMember', response: [{ type: 'Property', name: 'teamMember' }] },

	  // 添加好友
	  '12_1': { service: 'friend', cmd: 'friendRequest' },
	  // 添加好友多端同步
	  '12_101': { service: 'friend', cmd: 'syncFriendRequest', response: [{ type: 'String', name: 'account' }, { type: 'Number', name: 'type' }, { type: 'String', name: 'ps' }] },
	  // 删除好友
	  '12_2': { service: 'friend', cmd: 'deleteFriend' },
	  // 删除好友多端同步
	  '12_102': { service: 'friend', cmd: 'syncDeleteFriend', response: [{ type: 'String', name: 'account' }] },
	  // 更新好友
	  '12_3': { service: 'friend', cmd: 'updateFriend' },
	  // 更新好友多端同步
	  '12_103': { service: 'friend', cmd: 'syncUpdateFriend', response: [{ type: 'Property', name: 'friend' }] },
	  // 获取好友列表
	  '12_4': { service: 'friend', cmd: 'getFriends', response: [{ type: 'PropertyArray', name: 'friends', entity: 'friend' }, { type: 'Number', name: 'timetag' }] },
	  // 同步好友列表
	  '12_5': { service: 'friend', cmd: 'syncFriends', response: [{ type: 'PropertyArray', name: 'friends', entity: 'friend' }, { type: 'Number', name: 'timetag' }] },
	  '12_6': { service: 'friend', cmd: 'syncFriendUsers', response: [{ type: 'PropertyArray', name: 'users', entity: 'user' }, { type: 'Number', name: 'timetag' }] },

	  '13_1': { service: 'chatroom', cmd: 'getChatroomAddress', response: [{ type: 'StrArray', name: 'address' }] },
	  '14_1': {
	    service: 'eventService', cmd: 'publishEvent', response: [{ type: 'Property', name: 'msgEvent' }]
	  },
	  '14_2': {
	    service: 'eventService', cmd: 'pushEvent', response: [{ type: 'Property', name: 'msgEvent' }]
	  },
	  '14_3': {
	    service: 'eventService', cmd: 'subscribeEvent', response: [{ type: 'StrArray', name: 'accounts' }]
	  },
	  '14_4': {
	    service: 'eventService', cmd: 'unSubscribeEventsByAccounts', response: [{ type: 'StrArray', name: 'accounts' }]
	  },
	  '14_5': {
	    service: 'eventService', cmd: 'unSubscribeEventsByType'
	  },
	  '14_6': {
	    service: 'eventService', cmd: 'querySubscribeEventsByAccounts', response: [{ type: 'PropertyArray', name: 'msgEventSubscribes', entity: 'msgEventSubscribe' }]
	  },
	  '14_7': {
	    service: 'eventService', cmd: 'querySubscribeEventsByType', response: [{ type: 'PropertyArray', name: 'msgEventSubscribes', entity: 'msgEventSubscribe' }]
	  },
	  '14_9': {
	    service: 'eventService', cmd: 'pushEvents', response: [{ type: 'PropertyArray', name: 'msgEvents', entity: 'msgEvent' }]
	  },
	  // 发送过滤消息
	  '101_1': { service: 'filter', cmd: 'sendFilterMsg', response: [{ type: 'Property', name: 'msg' }] },
	  // 过滤消息通知
	  '101_2': { service: 'filter', cmd: 'filterMsg', response: [{ type: 'Property', name: 'msg' }] },
	  // 过滤系统通知通知
	  '101_3': { service: 'filter', cmd: 'filterSysMsg', response: [{ type: 'Property', name: 'sysMsg' }] },
	  // 发送过滤自定义系统通知
	  '101_7': { service: 'filter', cmd: 'sendFilterCustomSysMsg' }

	});

	module.exports = {
	  idMap: idMap,
	  cmdConfig: cmdConfig,
	  packetConfig: packetConfig
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	if (typeof window !== 'undefined') {
	  // 微信里面不要 shim console
	  if (!window.console && !process.env.WEIXIN_APP) {
	    window.console = {
	      log: function log() {},
	      info: function info() {},
	      warn: function warn() {},
	      error: function error() {}
	    };
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);

	util.fillPropertyWithDefault = function (obj, name, defaultValue) {
	    if (util.undef(obj[name])) {
	        obj[name] = defaultValue;
	        return true;
	    }
	    return false;
	};

/***/ },
/* 46 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * NIM support 工具对象, 通过 `NIM.support` 来获取此工具的引用
	 * 
	 * @namespace support
	 */
	var support = {};

	support.set = function (name, flag, obj) {
	  support[name] = flag;
	  if (obj) {
	    obj.support = flag;
	  }
	};

	/**
	 * 是否支持数据库
	 * @memberOf support
	 * @name db
	 * @type {Boolean}
	 */

	module.exports = support;

/***/ },
/* 47 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var device = __webpack_require__(12);

	function Message() {}

	Message.typeMap = {
	  text: 0,
	  image: 1,
	  audio: 2,
	  video: 3,
	  geo: 4,
	  notification: 5,
	  file: 6,
	  tip: 10,
	  robot: 11, // robotIn
	  // robotOut: 12,
	  custom: 100
	};

	var typeReverseMap = Message.typeReverseMap = {
	  0: 'text',
	  1: 'image',
	  2: 'audio',
	  3: 'video',
	  4: 'geo',
	  5: 'notification',
	  6: 'file',
	  10: 'tip',
	  11: 'robot', // robotIn
	  // 12: 'robotOut',
	  100: 'custom'
	};

	Message.validTypes = Object.keys(Message.typeMap);

	Message.setFlow = function (msg, account) {
	  // 自己发的就算自己发的
	  var out = account === msg.from;
	  // 如果同时也是自己收的, 那么比较设备号, 设备号一样的话就算自己发的
	  if (out && account === msg.to) {
	    out = device.deviceId === msg.fromDeviceId;
	  }
	  msg.flow = out ? 'out' : 'in';
	  if (msg.type === 'robot') {
	    if (msg.content && msg.content.msgOut) {
	      msg.flow = 'in';
	    }
	  }
	};

	Message.getType = function (msg) {
	  var type = msg.type;
	  return typeReverseMap[type] || type;
	};

	module.exports = Message;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ApiBaseFn = __webpack_require__(11).fn;

	ApiBaseFn.isConnected = function () {
	  return this.protocol.isConnected();
	};

	ApiBaseFn.connect = function () {
	  this.protocol.connect();
	};

	ApiBaseFn.disconnect = function () {
	  this.protocol.disconnect();
	};

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var ApiBaseFn = __webpack_require__(11).fn;

	ApiBaseFn.uploadSdkLogUrl = function (options) {
	  util.verifyOptions(options, 'url');
	  return this.cbAndSendCmd('uploadSdkLogUrl', options);
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var ApiBaseFn = __webpack_require__(11).fn;
	var util = __webpack_require__(1);
	var X2JS = __webpack_require__(81);
	var NIMError = __webpack_require__(4);
	var config = __webpack_require__(3);
	var nos = __webpack_require__(69);
	var Upload = __webpack_require__(70);
	var blob = __webpack_require__(37);

	ApiBaseFn.sendText = function (options) {
	  var self = this;
	  self.processCallback(options);
	  options.msg = new self.message.TextMessage(options);
	  return self.sendMsg(options);
	};

	ApiBaseFn.previewFile = function (options) {
	  util.verifyOptions(options, 'done');
	  if (!options.type) {
	    options.type = 'file';
	  }
	  util.verifyParamPresentJustOne(options, 'dataURL blob fileInput wxFilePath');

	  // 如果传入dataURL, 那么转成blob
	  if (options.dataURL) {
	    options.blob = blob.fromDataURL(options.dataURL);
	  } else if (options.blob) {
	    // 如果是 blob, 什么都不做
	  } else if (options.fileInput) {
	    // 如果是 fileInput, 记录下名字
	    options.fileInput = util.verifyFileInput(options.fileInput);
	    if (options.fileInput.files) {
	      if (!options.fileInput.files.length) {
	        options.done(NIMError.newNoFileError('请选择' + options.type + '文件'), options);
	        return;
	      }
	    }
	    options.fileInputName = util.getFileName(options.fileInput);
	  }

	  this.processCallback(options);
	  var responseBody = nos.genResponseBody(options.type) || {};
	  this.getNosToken({
	    responseBody: JSON.stringify(responseBody).replace(/"/gi, '\\"'),
	    callback: function (error, nosToken) {
	      if (error) {
	        options.done(error, options.callback.options);
	        return;
	      } else {
	        options.nosToken = nosToken;
	        this._doPreviewFile(options);
	      }
	    }.bind(this)
	  });
	};

	ApiBaseFn._doPreviewFile = function (options) {
	  var self = this;
	  var olduploaddone = options.uploaddone;
	  var url = config.genUploadUrl(options.nosToken.bucket);
	  var params = this.assembleUploadParams(options.nosToken);
	  var fileName = 'file';
	  function uploaddone(error, json) {
	    options.uploaddone = olduploaddone;
	    if (error) {
	      error.appendMessage('上传文件失败');
	      options.done(error, options.callback.options);
	      return;
	    } else {
	      json = nos.parseResponse(json, self.options.exifOrientation);
	      json.url = config.genDownloadUrl(options.nosToken.bucket, params.Object);
	      if (util.exist(options.fileInputName)) {
	        json.name = options.fileInputName;
	      } else if (options.blob) {
	        var name = options.blob.name;
	        json.name = name || 'blob-' + json.md5;
	        if (!name) {
	          var type = options.blob.type;
	          json.ext = type.slice(type.lastIndexOf('/') + 1);
	        }
	      }
	      if (process.env.WEIXIN_APP) {
	        json.name = options.wxFilePath;
	      }
	      if (!json.ext) {
	        var lastDotIndex = json.name.lastIndexOf('.');
	        if (lastDotIndex === -1) {
	          json.ext = 'unknown';
	        } else {
	          json.ext = json.name.slice(lastDotIndex + 1);
	        }
	      }
	      options.done(null, util.copy(json));
	      return;
	    }
	  }
	  if (process.env.WEIXIN_APP) {
	    util.verifyOptions(options, 'wxFilePath');
	    // eslint-disable-next-line no-undef
	    wx.uploadFile({
	      url: url,
	      filePath: options.wxFilePath,
	      name: fileName,
	      formData: params,
	      fail: function fail(err) {
	        console.log(err);
	      },
	      success: function success(res) {
	        console.log(res);
	        if (res.statusCode === 200) {
	          try {
	            uploaddone(null, JSON.parse(res.data));
	          } catch (e) {
	            console.error('parse wx upload file res error', e);
	            uploaddone({
	              code: 'PARSE_WX_UPLOAD_FILE_RES_ERROR',
	              str: res.data,
	              msg: res.errMsg
	            });
	          }
	        } else {
	          uploaddone({
	            code: res.statusCode,
	            msg: res.errMsg
	          });
	        }
	      }
	    });
	  } else {
	    options.uploaddone = uploaddone;
	    options.url = url;
	    options.params = params;
	    options.fileName = fileName;
	    // eslint-disable-next-line no-new
	    new Upload(options);
	  }
	};

	ApiBaseFn.sendFile = function (options) {
	  var self = this;
	  if (!options.type) {
	    options.type = 'file';
	  }
	  util.verifyParamPresentJustOne(options, 'dataURL blob fileInput file wxFilePath');
	  self.processCallback(options);

	  // 如果传入dataURL, 直接预览发送
	  if (options.dataURL) {
	    self._previewAndSendFile(options);
	  } else if (options.blob) {
	    // 如果传入blob, 直接预览发送
	    self._previewAndSendFile(options);
	  } else if (options.fileInput) {
	    // 如果传入file input, 那么先处理参数后再预览发送
	    options.fileInput = util.verifyFileInput(options.fileInput);
	    if (!!options.fileInput.files && !options.fileInput.files.length) {
	      options.done(NIMError.newNoFileError('请选择' + options.type + '文件'), options.callback.options);
	      return;
	    }
	    self._previewAndSendFile(options);
	  } else if (options.wxFilePath) {
	    // 微信上传文件
	    self._previewAndSendFile(options);
	  } else if (options.file) {
	    // 如果传入文件对象, 那么直接发送
	    options.msg = new self.message.FileMessage(options);
	    return self.sendMsg(options);
	  }
	};

	ApiBaseFn._previewAndSendFile = function (options) {
	  var self = this;
	  util.verifyCallback(options, 'uploaddone beforesend');
	  // 缓存 done 回调
	  var done = options.done;
	  options.done = function (error, json) {
	    // 恢复 done 回调
	    options.done = done;
	    if (error) {
	      options.uploaddone(error, options.callback.options);
	    } else {
	      options.uploaddone(null, util.copy(json));
	      options.file = json;
	      options.msg = new self.message.FileMessage(options);
	      options.beforesend(self.sendMsg(options));
	    }
	  };
	  self.previewFile(options);
	};

	ApiBaseFn.assembleUploadParams = function (nosToken) {
	  if (nosToken) {
	    return {
	      'Object': decodeURIComponent(nosToken.objectName),
	      'x-nos-token': nosToken.token,
	      'x-nos-entity-type': 'json'
	    };
	  }
	  return null;
	};

	ApiBaseFn.sendGeo = function (options) {
	  var self = this;
	  self.processCallback(options);
	  options.msg = new self.message.GeoMessage(options);
	  return self.sendMsg(options);
	};

	ApiBaseFn.sendTipMsg = function (options) {
	  var self = this;
	  self.processCallback(options);
	  options.msg = new self.message.TipMessage(options);
	  return self.sendMsg(options);
	};

	ApiBaseFn.sendCustomMsg = function (options) {
	  var self = this;
	  self.processCallback(options);
	  options.msg = new self.message.CustomMessage(options);
	  return self.sendMsg(options);
	};

	ApiBaseFn.sendRobotMsg = function (options) {
	  var self = this;
	  self.processCallback(options);
	  options.msg = new self.message.RobotMessage(options);
	  return self.sendMsg(options);
	};

	ApiBaseFn.sendMsg = function (options) {
	  var self = this;
	  var protocol = self.protocol;
	  var msg = options.msg;
	  var content = {};
	  // 是否是本地消息, 本地消息不会被发送, 非本地消息不允许设置时间
	  var isLocal = !!options.isLocal;
	  if (isLocal && options.time) {
	    msg.time = options.time;
	  }
	  // 重发
	  if (options.resend) {
	    if (options.flow !== 'out' || options.status !== 'fail') {
	      return util.onError('只能重发发送失败的消息');
	    }
	  }
	  // 将 idClient 记录下来, 如果发送失败, 那么可以其返回给开发者
	  options.callback.options.idClient = msg.idClient;
	  // 子类处理
	  self.beforeSendMsg(options, content);

	  var rtnMsg = options.rtnMsg = self.formatReturnMsg(msg);
	  // 如果是本地消息, 那么修改状态
	  if (isLocal) {
	    rtnMsg.status = 'success';
	    rtnMsg.isLocal = true;
	  }
	  // 记录 Promise
	  if (protocol.storeSendMsg) {
	    content.promise = protocol.storeSendMsg(rtnMsg);
	  }
	  // 处理错误
	  options.cbaop = function (error) {
	    // 错误包括
	    // - 服务器返回的错误
	    //   - 被加入黑名单
	    // - 客户端检测到的错误
	    //   - 断网
	    //   - 超时
	    // 如果是客户端检测到的错误，需要将错误写入数据库
	    if (error && error.from !== 'server') {
	      rtnMsg.status = 'fail';
	      if (protocol.updateSendMsgError) {
	        protocol.updateSendMsgError(rtnMsg);
	      }
	      return rtnMsg;
	    }
	  };

	  // 发消息, 不发本地消息
	  if (!isLocal) {
	    content.msg = msg;
	    self.sendCmd(options.cmd, content, options.callback);
	  }
	  self.afterSendMsg(options);
	  // 如果是本地消息, 那么模拟异步发送成功
	  if (isLocal) {
	    setTimeout(function () {
	      rtnMsg = util.simpleClone(rtnMsg);
	      options.done(null, rtnMsg);
	    }, 0);
	  }
	  return util.copy(rtnMsg);
	};

	ApiBaseFn.beforeSendMsg = function () {};

	ApiBaseFn.afterSendMsg = function () {};

	ApiBaseFn.formatReturnMsg = function (msg) {
	  var self = this;
	  msg = util.copy(msg);
	  self.protocol.completeMsg(msg);
	  msg.status = 'sending';
	  msg = self.message.reverse(msg);
	  return msg;
	};

	ApiBaseFn.resendMsg = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'msg');
	  self.trimMsgFlag(options);
	  options.resend = true;
	  return self._sendMsgByType(options);
	};

	ApiBaseFn.forwardMsg = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'msg');
	  self.beforeForwardMsg(options);
	  self.trimMsgFlag(options);
	  options.forward = true;
	  options.msg.idClient = util.guid();
	  return self._sendMsgByType(options);
	};

	ApiBaseFn.trimMsgFlag = function (options) {
	  if (options && options.msg) {
	    options.msg = util.copy(options.msg);
	    delete options.msg.resend;
	    delete options.msg.forward;
	  }
	};

	ApiBaseFn.beforeForwardMsg = function () {};

	ApiBaseFn._sendMsgByType = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'msg');
	  util.verifyParamValid('msg.type', options.msg.type, self.message.validTypes);
	  util.merge(options, options.msg);
	  switch (options.type) {
	    case 'text':
	      return self.sendText(options);
	    case 'image':
	    case 'audio':
	    case 'video':
	    case 'file':
	      return self.sendFile(options);
	    case 'geo':
	      return self.sendGeo(options);
	    case 'custom':
	      return self.sendCustomMsg(options);
	    case 'tip':
	      return self.sendTipMsg(options);
	    default:
	      throw new NIMError('不能发送类型为 ' + options.type + ' 的消息');
	  }
	};

	ApiBaseFn.parseRobotTemplate = function (content) {
	  if (/<template[^>\/]+\/>/.test(content)) {
	    return {
	      raw: content,
	      json: [{
	        type: 'text',
	        name: '',
	        text: ''
	      }]
	    };
	  }
	  if (!/<template[^>\/]+>/.test(content)) {
	    return {
	      raw: content,
	      json: [{
	        type: 'text',
	        name: '',
	        text: content
	      }]
	    };
	  }
	  var x2js = new X2JS({
	    escapeMode: false
	    // arrayAccessForm: 'property'
	  });
	  content = content.replace(/<template [^>]+>/, '<template>');
	  var jsonObj = x2js.xml2js(content);
	  jsonObj = jsonObj.template.LinearLayout;
	  if (!Array.isArray(jsonObj)) {
	    jsonObj = [jsonObj];
	  }

	  var tplArray = [];
	  jsonObj = jsonObj.forEach(function (item) {
	    if (item.image) {
	      tplArray = tplArray.concat(parseImageJson(item));
	    }
	    if (item.text) {
	      tplArray = tplArray.concat(parseTextJson(item));
	    }
	    if (item.link) {
	      tplArray = tplArray.concat(parseLinkJson(item));
	    }
	  });

	  return {
	    raw: content,
	    json: tplArray
	    // html: htmlStr
	  };

	  function parseLinkJson(item) {
	    if (item.link) {
	      var link = item.link;
	      // item.type = 'link'
	      if (!Array.isArray(link)) {
	        link = [link];
	      }
	      link = link.map(function (linkItem) {
	        if (linkItem.image) {
	          linkItem.image = parseImageJson(linkItem);
	        }
	        if (linkItem.text) {
	          linkItem.text = parseTextJson(linkItem);
	        }
	        if (linkItem._type === 'url') {
	          linkItem.type = 'url';
	          linkItem.style = linkItem._style || '';
	          linkItem.target = linkItem._target;
	          delete linkItem._target;
	          delete linkItem._style;
	        } else if (linkItem._type === 'block') {
	          linkItem.type = 'block';
	          linkItem.style = linkItem._style || '';
	          linkItem.params = linkItem._params || '';
	          linkItem.target = linkItem._target;
	          delete linkItem._params;
	          delete linkItem._target;
	          delete linkItem._style;
	        }
	        delete linkItem._type;
	        return linkItem;
	      });
	      item.link = link;
	    }
	    return item.link;
	  }

	  function parseTextJson(obj) {
	    // if (obj.text) {
	    //   obj.type = 'text'
	    // }
	    if (!Array.isArray(obj.text)) {
	      obj.text = [obj.text];
	    }
	    obj.text = obj.text.map(function (item) {
	      return {
	        type: 'text',
	        name: item._name,
	        text: item.__text
	      };
	    });
	    return obj.text;
	  }

	  function parseImageJson(obj) {
	    // if (obj.image) {
	    //   obj.type = 'image'
	    // }
	    if (!Array.isArray(obj.image)) {
	      obj.image = [obj.image];
	    }
	    obj.image = obj.image.map(function (item) {
	      return {
	        type: 'image',
	        name: item._name,
	        url: item._url
	      };
	    });
	    return obj.image;
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var ApiBaseFn = __webpack_require__(11).fn;
	var ImageOp = __webpack_require__(35);

	ApiBaseFn.getSimpleNosToken = function () {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  options.num = 1;
	  util.verifyOptions(options);
	  return this.cbAndSendCmd('getSimpleNosToken', options);
	};

	ApiBaseFn.getNosToken = function (options) {
	  this.sendCmd('getNosToken', {
	    responseBody: options.responseBody
	  }, options.callback);
	};

	ApiBaseFn.packFileDownloadName = function (options) {
	  util.verifyOptions(options, 'url name');
	  var url = options.url;
	  return url + util.genUrlSep(url) + 'download=' + encodeURIComponent(options.name);
	};

	ApiBaseFn.audioToMp3 = function (options) {
	  util.verifyOptions(options, 'url');
	  var url = options.url;
	  return url + util.genUrlSep(url) + 'audioTrans&type=mp3';
	};

	/*
	 * 图片处理相关的操作
	 */

	ApiBaseFn.stripImageMeta = function (options) {
	  return this.beforeProcessImage(options, 'stripmeta');
	};

	ApiBaseFn.qualityImage = function (options) {
	  return this.beforeProcessImage(options, 'quality');
	};

	ApiBaseFn.interlaceImage = function (options) {
	  return this.beforeProcessImage(options, 'interlace');
	};

	ApiBaseFn.rotateImage = function (options) {
	  return this.beforeProcessImage(options, 'rotate');
	};

	ApiBaseFn.blurImage = function (options) {
	  return this.beforeProcessImage(options, 'blur');
	};

	ApiBaseFn.cropImage = function (options) {
	  return this.beforeProcessImage(options, 'crop');
	};

	ApiBaseFn.thumbnailImage = function (options) {
	  return this.beforeProcessImage(options, 'thumbnail');
	};

	ApiBaseFn.beforeProcessImage = function (options, type) {
	  var op = util.copy(options);
	  op.type = type;
	  options.ops = [op];
	  return this.processImage(options);
	};

	ApiBaseFn.processImage = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'url ops');
	  util.verifyParamType('ops', options.ops, 'array');
	  var imageOps = options.ops.map(function (op) {
	    util.verifyOptions(op, 'type');
	    util.verifyParamValid('type', op.type, ImageOp.validTypes);
	    return self['gen' + op.type.slice(0, 1).toUpperCase() + op.type.slice(1) + 'Op'](op);
	  });
	  self.processCallback(options);
	  self.sendCmd('processImage', {
	    url: options.url,
	    imageOps: imageOps
	  }, options.callback);
	};

	ApiBaseFn.genStripmetaOp = function (options) {
	  return new ImageOp({
	    type: options.type,
	    stripmeta: options.strip ? 1 : 0
	  });
	};

	ApiBaseFn.genQualityOp = function (options) {
	  util.verifyOptions(options, 'quality');
	  util.verifyParamType('quality', options.quality, 'number');
	  util.verifyParamMin('quality', options.quality, 0);
	  util.verifyParamMax('quality', options.quality, 100);
	  var quality = Math.round(options.quality);
	  return new ImageOp({
	    type: options.type,
	    qualityQuality: quality
	  });
	};

	ApiBaseFn.genInterlaceOp = function (options) {
	  return new ImageOp({
	    type: options.type
	  });
	};

	ApiBaseFn.genRotateOp = function (options) {
	  util.verifyOptions(options, 'angle');
	  util.verifyParamType('angle', options.angle, 'number');
	  while (options.angle < 0) {
	    options.angle = options.angle + 360;
	  }
	  options.angle = options.angle % 360;
	  var angle = Math.round(options.angle);
	  return new ImageOp({
	    type: options.type,
	    rotateAngle: angle
	  });
	};

	ApiBaseFn.genBlurOp = function (options) {
	  util.verifyOptions(options, 'radius sigma');
	  util.verifyParamType('radius', options.radius, 'number');
	  util.verifyParamMin('radius', options.radius, 1);
	  util.verifyParamMax('radius', options.radius, 50);
	  util.verifyParamType('sigma', options.sigma, 'number');
	  util.verifyParamMin('sigma', options.sigma, 0);
	  var radius = Math.round(options.radius);
	  var sigma = Math.round(options.sigma);
	  return new ImageOp({
	    type: options.type,
	    blurRadius: radius,
	    blurSigma: sigma
	  });
	};

	ApiBaseFn.genCropOp = function (options) {
	  util.verifyOptions(options, 'x y width height');
	  util.verifyParamType('x', options.x, 'number');
	  util.verifyParamMin('x', options.x, 0);
	  util.verifyParamType('y', options.y, 'number');
	  util.verifyParamMin('y', options.y, 0);
	  util.verifyParamType('width', options.width, 'number');
	  util.verifyParamMin('width', options.width, 0);
	  util.verifyParamType('height', options.height, 'number');
	  util.verifyParamMin('height', options.height, 0);
	  var x = Math.round(options.x);
	  var y = Math.round(options.y);
	  var width = Math.round(options.width);
	  var height = Math.round(options.height);
	  return new ImageOp({
	    type: options.type,
	    cropX: x,
	    cropY: y,
	    cropWidth: width,
	    cropHeight: height
	  });
	};

	ApiBaseFn.genThumbnailOp = function () {
	  var modes = {
	    cover: 'z',
	    contain: 'x',
	    crop: 'y'
	  };
	  return function (options) {
	    util.verifyOptions(options, 'mode');
	    util.verifyParamValid('mode', options.mode, Object.keys(modes));
	    if (options.mode === 'contain') {
	      util.verifyParamAtLeastPresentOne(options, 'width height');
	    } else {
	      util.verifyOptions(options, 'width height');
	    }
	    if (util.undef(options.width)) {
	      options.width = 0;
	    }
	    if (util.undef(options.height)) {
	      options.height = 0;
	    }
	    util.verifyParamType('width', options.width, 'number');
	    util.verifyParamMin('width', options.width, 0);
	    util.verifyParamType('height', options.height, 'number');
	    util.verifyParamMin('height', options.height, 0);
	    var width = Math.round(options.width);
	    var height = Math.round(options.height);
	    var imageOp = new ImageOp({
	      type: options.type,
	      thumbnailMode: modes[options.mode],
	      thumbnailWidth: width,
	      thumbnailHeight: height
	    });
	    if (options.mode === 'crop') {
	      if (util.notundef(options.axis)) {
	        if (util.undef(options.axis.x)) {
	          options.axis.x = 5;
	        }
	        if (util.undef(options.axis.y)) {
	          options.axis.y = 5;
	        }
	        util.verifyParamMin('axis.x', options.axis.x, 0);
	        util.verifyParamMax('axis.x', options.axis.x, 10);
	        util.verifyParamMin('axis.y', options.axis.y, 0);
	        util.verifyParamMax('axis.y', options.axis.y, 10);
	        var x = Math.round(options.axis.x);
	        var y = Math.round(options.axis.y);
	        imageOp.thumbnailAxisX = x;
	        imageOp.thumbnailAxisY = y;
	      }
	    }
	    if (util.notundef(options.enlarge)) {
	      util.verifyParamType('enlarge', options.enlarge, 'boolean');
	      if (options.enlarge) {
	        imageOp.thumbnailEnlarge = 1;
	      }
	    }
	    return imageOp;
	  };
	}();

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var util = __webpack_require__(1);
	var ApiBaseFn = __webpack_require__(11).fn;

	function genUrlSep(url) {
	  url = '' + url;
	  var sep = url.indexOf('?') === -1 ? '?imageView&' : '&';
	  return sep;
	}

	function url2object(url) {
	  url = url || '';
	  var protocol = url.indexOf('https') >= 0 ? 'https://' : 'http://';
	  var hostname = url.replace(protocol, '');
	  if (hostname.indexOf('?') >= 0) {
	    hostname = hostname.substring(0, hostname.indexOf('?'));
	  }
	  var hostItems = hostname.split('/');
	  hostname = hostItems[0];
	  var path = '';
	  if (hostItems.length > 0) {
	    path = hostItems.slice(1).join('/');
	  }
	  if (url.indexOf('?') === -1) {
	    return {
	      protocol: protocol,
	      hostname: hostname,
	      path: path,
	      query: {}
	    };
	  } else {
	    var _ret = function () {
	      var query = url.substr(url.indexOf('?') + 1);
	      var queryItems = query.split('&');
	      var result = {};
	      queryItems.forEach(function (item) {
	        if (item.indexOf('=') > 0) {
	          var temp = item.split('=');
	          result[temp[0]] = decodeURIComponent(temp[1]);
	        } else {
	          result[item] = '';
	        }
	      });
	      return {
	        v: {
	          protocol: protocol,
	          hostname: hostname,
	          path: path,
	          query: result
	        }
	      };
	    }();

	    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	  }
	}

	function object2url(obj) {
	  var protocol = obj.protocol,
	      hostname = obj.hostname,
	      path = obj.path,
	      query = obj.query;

	  protocol = protocol || 'http://';
	  hostname = hostname || '';
	  if (path) {
	    hostname = hostname + '/' + path;
	  }
	  query = query || {};
	  var queryItems = [];
	  for (var key in query) {
	    if (key === 'imageView') {
	      continue;
	    } else {
	      queryItems.push(key + '=' + encodeURIComponent(query[key]));
	    }
	  }
	  if (queryItems.length > 0) {
	    return '' + protocol + hostname + '?imageView&' + queryItems.join('&');
	  } else {
	    return '' + protocol + hostname;
	  }
	}

	// 参数 strip boolean
	//
	ApiBaseFn.viewImageSync = function (options) {
	  var linkOptions = this.options;
	  util.verifyOptions(options, 'url');
	  var url = options.url; // + '?imageView&quality=20'

	  var _url2object = url2object(url),
	      protocol = _url2object.protocol,
	      hostname = _url2object.hostname,
	      path = _url2object.path,
	      query = _url2object.query;

	  if (typeof options.strip === 'boolean') {
	    query['stripmeta'] = options.strip ? 1 : 0;
	  }
	  if (typeof options.quality === 'number') {
	    util.verifyParamMin('quality', options.quality, 0);
	    util.verifyParamMax('quality', options.quality, 100);
	    query['quality'] = Math.round(options.quality);
	  }
	  if (typeof options.interlace === 'boolean') {
	    query['interlace'] = options.interlace ? 1 : 0;
	  }
	  if (typeof options.rotate === 'number') {
	    query['rotate'] = Math.round(options.rotate);
	  }
	  // 缩略图模式
	  if (_typeof(options.thumbnail) === 'object') {
	    var mode = options.thumbnail.mode || 'crop';
	    var width = options.thumbnail.width;
	    var height = options.thumbnail.height;
	    if (width >= 0 && height >= 0 && width < 4096 && height < 4096) {
	      if (width > 0 || height > 0) {
	        switch (mode) {
	          case 'crop':
	            mode = 'y';
	            break;
	          case 'contain':
	            mode = 'x';
	            break;
	          case 'cover':
	            mode = 'z';
	            break;
	          default:
	            mode = 'x';
	        }
	        query['thumbnail'] = '' + width + mode + height;
	      }
	    }
	  }
	  if (linkOptions.downloadUrl) {
	    // 拿原来地址的object，bucket
	    var objUrl = url2object(options.url);
	    var downloadUrl = linkOptions.downloadUrl;
	    var _url = objUrl.path;
	    var index = _url.indexOf('/');
	    if (index !== -1) {
	      var nosBucket = _url.substring(0, index);
	      var nosObj = _url.substring(index + 1);
	      downloadUrl = downloadUrl.replace('{bucket}', nosBucket).replace('{object}', nosObj);
	    }
	    var obj = url2object(downloadUrl);
	    return object2url({
	      protocol: obj.protocol,
	      hostname: obj.hostname,
	      path: obj.path,
	      query: util.merge(obj.query, query)
	    });
	  } else {
	    return object2url({ protocol: protocol, hostname: hostname, path: path, query: query });
	  }
	};

	ApiBaseFn.viewImageStripMeta = function (options) {
	  util.verifyOptions(options, 'url strip');
	  util.verifyParamType('strip', options.strip, 'boolean');
	  var ps = 'stripmeta=' + (options.strip ? 1 : 0);
	  var sep = genUrlSep(options.url);
	  return options.url + sep + ps;
	};

	ApiBaseFn.viewImageQuality = function (options) {
	  util.verifyOptions(options, 'url quality');
	  util.verifyParamType('quality', options.quality, 'number');
	  util.verifyParamMin('quality', options.quality, 0);
	  util.verifyParamMax('quality', options.quality, 100);
	  var quality = Math.round(options.quality);
	  var ps = 'quality=' + quality;
	  var sep = genUrlSep(options.url);
	  return options.url + sep + ps;
	};

	ApiBaseFn.viewImageInterlace = function (options) {
	  util.verifyOptions(options, 'url');
	  var ps = 'interlace=1';
	  var sep = genUrlSep(options.url);
	  return options.url + sep + ps;
	};

	ApiBaseFn.viewImageRotate = function (options) {
	  util.verifyOptions(options, 'url angle');
	  util.verifyParamType('angle', options.angle, 'number');
	  while (options.angle < 0) {
	    options.angle = options.angle + 360;
	  }
	  options.angle = options.angle % 360;
	  var angle = Math.round(options.angle);
	  var ps = 'rotate=' + angle;
	  var sep = genUrlSep(options.url);
	  return options.url + sep + ps;
	};

	ApiBaseFn.viewImageBlur = function (options) {
	  util.verifyOptions(options, 'url radius sigma');
	  util.verifyParamType('radius', options.radius, 'number');
	  util.verifyParamMin('radius', options.radius, 1);
	  util.verifyParamMax('radius', options.radius, 50);
	  util.verifyParamType('sigma', options.sigma, 'number');
	  util.verifyParamMin('sigma', options.sigma, 0);
	  var radius = Math.round(options.radius);
	  var sigma = Math.round(options.sigma);
	  var ps = 'blur=' + radius + 'x' + sigma;
	  var sep = genUrlSep(options.url);
	  return options.url + sep + ps;
	};

	ApiBaseFn.viewImageCrop = function (options) {
	  util.verifyOptions(options, 'url x y width height');
	  util.verifyParamType('x', options.x, 'number');
	  util.verifyParamMin('x', options.x, 0);
	  util.verifyParamType('y', options.y, 'number');
	  util.verifyParamMin('y', options.y, 0);
	  util.verifyParamType('width', options.width, 'number');
	  util.verifyParamMin('width', options.width, 0);
	  util.verifyParamType('height', options.height, 'number');
	  util.verifyParamMin('height', options.height, 0);
	  var x = Math.round(options.x);
	  var y = Math.round(options.y);
	  var width = Math.round(options.width);
	  var height = Math.round(options.height);
	  var ps = 'crop=' + x + '_' + y + '_' + width + '_' + height;
	  var sep = genUrlSep(options.url);
	  return options.url + sep + ps;
	};

	ApiBaseFn.viewImageThumbnail = function () {
	  var modes = {
	    cover: 'z',
	    contain: 'x',
	    crop: 'y'
	  };
	  return function (options) {
	    util.verifyOptions(options, 'url mode');
	    util.verifyParamValid('mode', options.mode, Object.keys(modes));
	    if (options.mode === 'contain') {
	      util.verifyParamAtLeastPresentOne(options, 'width height');
	    } else {
	      util.verifyOptions(options, 'width height');
	    }
	    if (util.undef(options.width)) {
	      options.width = 0;
	    }
	    if (util.undef(options.height)) {
	      options.height = 0;
	    }
	    util.verifyParamType('width', options.width, 'number');
	    util.verifyParamMin('width', options.width, 0);
	    util.verifyParamType('height', options.height, 'number');
	    util.verifyParamMin('height', options.height, 0);
	    var width = Math.round(options.width);
	    var height = Math.round(options.height);
	    var ps = 'thumbnail=' + width + modes[options.mode] + height;
	    if (options.mode === 'crop') {
	      if (util.notundef(options.axis)) {
	        if (util.undef(options.axis.x)) {
	          options.axis.x = 5;
	        }
	        if (util.undef(options.axis.y)) {
	          options.axis.y = 5;
	        }
	        util.verifyParamMin('axis.x', options.axis.x, 0);
	        util.verifyParamMax('axis.x', options.axis.x, 10);
	        util.verifyParamMin('axis.y', options.axis.y, 0);
	        util.verifyParamMax('axis.y', options.axis.y, 10);
	        var x = Math.round(options.axis.x);
	        var y = Math.round(options.axis.y);
	        ps = ps + '&axis=' + x + '_' + y;
	      }
	    }
	    if (util.notundef(options.enlarge)) {
	      util.verifyParamType('enlarge', options.enlarge, 'boolean');
	      if (options.enlarge) {
	        ps = ps + '&enlarge=1';
	      }
	    }
	    var sep = genUrlSep(options.url);
	    return options.url + sep + ps;
	  };
	}();

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// ployfill
	// require('/util/shim');
	__webpack_require__(75);
	__webpack_require__(74);
	__webpack_require__(78);
	// polyfill the global environment
	__webpack_require__(2).polyfill();
	// require('es6-symbol/implement')
	// require('babel-polyfill')

/***/ },
/* 55 */,
/* 56 */,
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var notundef = util.notundef;

	/**
	 * 好友请求类型
	 * 
	 * - `'addFriend'` (直接加为好友)
	 * - `'applyFriend'` (申请加为好友)
	 * - `'passFriendApply'` (通过好友申请)
	 * - `'rejectFriendApply'` (拒绝好友申请)
	 * 
	 * @memberOf Friend
	 * @name requestType
	 * @readOnly
	 * @enum {String}
	 */
	var requestTypeMap = {
	    addFriend: 1,
	    applyFriend: 2,
	    passFriendApply: 3,
	    rejectFriendApply: 4
	};
	var requestTypeReverseMap = {
	    1: 'addFriend',
	    2: 'applyFriend',
	    3: 'passFriendApply',
	    4: 'rejectFriendApply'
	};

	/**
	 * @constructor
	 *
	 * @property {String}   account     账号
	 * @property {String}   alias       昵称
	 * @property {String}   custom      扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
	 * @property {Number}   createTime  成为好友的时间
	 * @property {Number}   updateTime  更新时间
	 */
	function Friend(options) {
	    util.verifyOptions(options, 'account');
	    util.verifyParamAtLeastPresentOne(options, 'alias custom');
	    this.account = options.account;
	    if (notundef(options.alias)) {
	        this.alias = options.alias;
	    }
	    if (notundef(options.custom)) {
	        this.custom = options.custom;
	    }
	}

	Friend.reverse = function (friend) {
	    var obj = util.filterObj(friend, 'account alias custom createTime updateTime');
	    if (notundef(friend.flag)) {
	        obj.valid = friend.flag === '1';
	    }
	    if (notundef(obj.createTime)) {
	        obj.createTime = +obj.createTime;
	    }
	    if (notundef(obj.updateTime)) {
	        obj.updateTime = +obj.updateTime;
	    }
	    return obj;
	};

	Friend.validTypes = function () {
	    return Object.keys(requestTypeMap);
	};

	Friend.getByteFromType = function (type) {
	    return requestTypeMap[type];
	};

	Friend.getTypeFromByte = function (typeInByte) {
	    return requestTypeReverseMap[typeInByte];
	};

	Friend.assembleFriend = function (account) {
	    var timetag = +new Date();
	    return {
	        account: account,
	        alias: "",
	        createTime: timetag,
	        custom: "",
	        updateTime: timetag,
	        valid: true
	    };
	};

	module.exports = Friend;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ProtocolFn = __webpack_require__(13).fn;
	var NIMError = __webpack_require__(4);
	var platform = __webpack_require__(9);
	var LoginPort = __webpack_require__(23);
	var device = __webpack_require__(12);
	var config = __webpack_require__(3);
	var util = __webpack_require__(1);
	var notundef = util.notundef;

	ProtocolFn.login = function () {
	  var self = this;
	  self.sendCmd('login', self.assembleLogin(), self.onLogin.bind(self));
	  // 发送完登录包之后重置状态, 如果是重连, 那么在发包过程中会用到此状态位
	  self.autoconnect = false;
	};

	ProtocolFn.genSessionKey = function () {
	  var sessions = {};
	  return function () {
	    var self = this;
	    var key = self.name;
	    var session = sessions[key] = sessions[key] || util.guid();
	    return session;
	  };
	}();

	ProtocolFn.assembleIMLogin = function () {
	  var self = this;
	  var options = self.options;
	  var account = options.account;
	  // 是否是 app 发起的登录, 如果是 SDK 发起的登录, 那么属于自动登录, 优先级低
	  // 如果此时是PC+WEB互踢模式，且PC在线状态，WEB端调用自动登录会失败并返回417错误码
	  var appLogin = self.autoconnect ? 0 : 1;
	  return {
	    appLogin: appLogin,
	    appKey: options.appKey,
	    account: account,
	    token: options.token,
	    sdkVersion: config.info.sdkVersion,
	    protocolVersion: config.info.protocolVersion,
	    os: platform.os.toString(),
	    browser: platform.name + ' ' + platform.version,
	    session: self.genSessionKey(),
	    deviceId: device.deviceId
	  };
	};

	// 处理登陆返回
	ProtocolFn.onLogin = function (error, obj) {
	  var self = this;
	  self.loginResult = obj;
	  if (!error) {
	    self.startHeartbeat();
	    self.afterLogin(obj);
	  } else {
	    self.onAuthError(error);
	  }
	};

	ProtocolFn.afterLogin = util.emptyFunc;

	// 通知开发者登录成功
	// IM 要在打开数据库之后再通知开发者, 那么在 afterLogin 里面就会有三个地方要通知, 所以统一放在 syncData 之前进行通知
	// 聊天室在 afterLogin 之后直接通知即可
	ProtocolFn.notifyLogin = function () {
	  var self = this;
	  var obj = self.loginResult;
	  self.logger.info('onConnect', obj);
	  self.options.onconnect(obj);
	};

	ProtocolFn.logout = function () {
	  var self = this;
	  if (!self.isConnected()) {
	    return;
	  }
	  var error = new NIMError('主动退出', 'logout');
	  self.onAuthError(error);
	  // 主动调用 disconnect, 不用发送 logout 指令
	  // self.sendCmd('logout');
	};

	ProtocolFn.onKicked = function (packet) {
	  // debugger;
	  var self = this;

	  var content = packet.content;
	  var from = content.from;
	  var reason = content.reason;
	  var custom = content.custom;

	  var kicked = {
	    reason: self.kickedReasons[reason] || 'unknown',
	    message: self.kickedMessages[reason] || '未知原因'
	  };
	  // IM 被踢有 from 字段
	  if (notundef(from)) {
	    kicked.from = LoginPort.reverseType(from);
	  }
	  // 聊天室被踢有 custom 字段
	  if (notundef(custom)) {
	    kicked.custom = custom;
	  }

	  if (self.shouldNotifyKicked(kicked)) {
	    var error = new NIMError('被踢了', 'kicked');
	    util.merge(error, kicked);
	    self.onAuthError(error);
	  } else {
	    self.logger.warn('silentlyKick');
	    // 如果不应该通知被踢(IM悄悄被踢), 那么就不应该重连, 同时也不应该通知连接断开
	    self.shouldReconnect = false;
	    // 假装已经通知过连接断开
	    self.hasNotifyDisconnected = true;
	    self.disconnectSocket();
	  }
	};

	ProtocolFn.shouldNotifyKicked = function (kicked) {
	  return true;
	  // return kicked.reason !== 'silentlyKick'
	};

	/*
	 * 认证错误, 不需要重连
	 * - 主动登出
	 * - 登录错误
	 * - 被踢
	 */
	ProtocolFn.onAuthError = function (error) {
	  // debugger;
	  var self = this;
	  self.shouldReconnect = false;
	  self.markAllCallbackInvalid(error || NIMError.newConnectionError());
	  self.notifyDisconnect(error);
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var ProtocolFn = __webpack_require__(13).fn;
	var NIMError = __webpack_require__(4);
	var Backoff = __webpack_require__(73);
	var io = __webpack_require__(19);
	var config = __webpack_require__(3);
	var util = __webpack_require__(1);

	ProtocolFn.initConnect = function () {
	  var self = this;

	  self.socket = null;

	  // 重试连接的次数
	  self.retryCount = 0;
	  // 是否正在建立连接, 防止重复调用 connect 方法
	  self.connecting = false;
	  // 是否应该重新建立连接, onAuthError 时不应该重连
	  self.shouldReconnect = true;
	  // 是否已经通知过连接断开, 确保只通知一次连接断开
	  self.hasNotifyDisconnected = false;
	};

	ProtocolFn.resetConnect = function () {
	  var self = this;
	  var options = self.options;

	  // 是否需要重连, 默认 true
	  if (util.notundef(options.needReconnect)) {
	    util.verifyParamType('needReconnect', options.needReconnect, 'boolean');
	    self.needReconnect = options.needReconnect;
	  } else {
	    self.needReconnect = true;
	  }
	  // 重连的最大次数, 默认 Infinity
	  if (util.notundef(options.reconnectionAttempts)) {
	    util.verifyParamType('reconnectionAttempts', options.reconnectionAttempts, 'number');
	  }
	  self.reconnectionAttempts = options.reconnectionAttempts || Infinity;
	  // 时间退化
	  self.backoff = new Backoff({
	    // 重连间隔和最大间隔
	    min: config.reconnectionDelay,
	    max: config.reconnectionDelayMax,
	    jitter: config.reconnectionJitter
	  });
	};

	ProtocolFn.connect = function () {
	  // debugger;
	  var self = this;

	  // 防止重复建立连接
	  if (self.isConnected() || self.connecting) {
	    return;
	  }
	  self.connecting = true;
	  self.hasNotifyDisconnected = false;

	  if (!self.socket) {
	    // 如果有 url, 那么连此 url, 否则刷新 url
	    var url = self.getNextSocketUrl();
	    if (url) {
	      self.connectToUrl(url);
	    } else {
	      self.refreshSocketUrl();
	    }
	  } else {
	    self.logger.info('connecting');
	    self.socket.socket.connect();
	  }
	};

	ProtocolFn.getNextSocketUrl = function () {
	  return this.socketUrls.shift();
	};

	ProtocolFn.isConnected = function () {
	  var self = this;
	  return !!self.socket && !!self.socket.socket && self.socket.socket.connected;
	};

	ProtocolFn.connectToUrl = function (url) {
	  var self = this;
	  self.logger.log('try connect to ', url);
	  // shim code for weixin app, location 对象可能没有
	  if (process.env.WEIXIN_APP) {
	    if (!window.location) {
	      var arr = url.split(':');
	      window.location = {
	        protocol: arr[0],
	        hostname: arr[1].slice(2),
	        port: arr[2]
	      };
	    }
	    this.options.transports = ['websocket'];
	  }
	  var transports = this.options.transports || ['websocket', 'xhr-polling'];
	  // !!! 为了支持手动断开连接, 没有自动重连
	  // 不要自动重连, 否则主动退出会引起自动重连
	  // 在非人为退出时（网络自己断了）, 调用 connect 来模拟自动重连
	  self.socket = io.connect(url, {
	    // secure: true,                            // secure 会自动设置
	    // transports: ["websocket", "xhr-polling", "flashsocket"],
	    transports: transports,
	    reconnect: false, // 不自动重连, 手动重连
	    'force new connection': true, // 当url不变时, 强制重新建立连接
	    'connect timeout': config.connectTimeout // 连接超时时间
	  });
	  self.logger.info('socket url: ' + url + ', transports: ' + JSON.stringify(transports));
	  self.socket.on('connect', self.onConnect.bind(self));
	  self.socket.on('handshake_failed', self.onHandshakeFailed.bind(self));
	  self.socket.on('connect_failed', self.onConnectFailed.bind(self));
	  self.socket.on('error', self.onError.bind(self));
	  self.socket.on('message', self.onMessage.bind(self));
	  self.socket.on('disconnect', function () {
	    self.logger.info('socket disconnect');
	    self.onDisconnect(true);
	  });
	};

	ProtocolFn.disconnect = function () {
	  // debugger;
	  var self = this;
	  if (self.isConnected()) {
	    self.logger.info('disconnecting');
	    self.logout();
	  }
	};

	// 连接上
	ProtocolFn.onConnect = function () {
	  var self = this;
	  if (self.backoff) {
	    self.backoff.reset();
	  }
	  self.retryCount = 0;
	  self.connecting = false;
	  self.shouldReconnect = true;
	  self.hasNotifyDisconnected = false;
	  self.login();
	};

	// 握手失败, 改造了一下 socketio, 在握手失败的时候触发此回调
	// self.publish('handshake_failed');
	ProtocolFn.onHandshakeFailed = function () {
	  this.logger.info('shandshake_failed');
	  this.onDisconnect();
	};

	ProtocolFn.onConnectFailed = function () {
	  this.onDisconnect();
	};

	// 错误
	ProtocolFn.onError = function () {
	  // debugger;
	  var reason = arguments[0];
	  if (reason) {
	    this.notifyError(new NIMError(reason));
	  }
	};

	// 参数 connected 表示是否是连上之后再断开连接的
	// 如果是 connected, 那么接下来的自动重连算自动登录, 优先级低
	// 而如果不是, 说明一开始就没有连接上, 那么接下来的自动重连不算自动登录, 优先级高
	ProtocolFn.onDisconnect = function () {
	  var connected = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	  var self = this;
	  self.connected = connected;
	  self.connecting = false;
	  self.markAllCallbackInvalid(NIMError.newNetworkError());
	  self.stopHeartbeat();
	  self.reconnect();
	};

	ProtocolFn.willReconnect = function () {
	  // debugger;
	  var self = this;
	  return self.shouldReconnect && self.needReconnect && self.retryCount < self.reconnectionAttempts;
	};

	/*
	 * 重新建立连接
	 * - 如果不会再重新建立连接, 那么不再重新连接。
	 *     - 主动退出
	 *     - 登录错误
	 *     - 被踢
	 * - 否则
	 *     - 如果还有可用地址, 那么尝试下一个地址；
	 *     - 如果没有可用地址, 但是lbs重试次数还没达到上限, 那么重试lbs；
	 * - 如果既没有可用地址, 重试次数也达到上限, 那么不再重新连接。
	 * IE 9/8 只会重连一次, 请参考 https://github.com/Automattic/socket.io/issues/1020#issuecomment-9684494
	 */
	ProtocolFn.reconnect = function () {
	  // debugger;
	  var self = this;
	  if (self.willReconnect()) {
	    // 重置 socket, 这样才能换地址
	    self.socket = null;
	    if (self.connected) {
	      self.autoconnect = true;
	    }
	    self.retryCount++;
	    var duration = self.backoff.duration();
	    self.logger.log('will retry after', duration + 'ms', ', retryCount', self.retryCount);
	    self.options.onwillreconnect({
	      retryCount: self.retryCount,
	      duration: duration
	    });
	    setTimeout(function () {
	      self.connect();
	    }, duration);
	  } else {
	    self.notifyDisconnect();
	  }
	};

	ProtocolFn.notifyConnectError = function (message) {
	  var self = this;
	  var error = NIMError.newConnectError(message);
	  self.logger.error(error);
	  self.options.onerror(error);
	};

	// 通知开发者连接断开
	ProtocolFn.notifyDisconnect = function (error) {
	  // debugger;
	  var self = this;
	  if (!self.hasNotifyDisconnected) {
	    self.hasNotifyDisconnected = true;
	    // 保证断开连接
	    self.disconnectSocket();
	    // 外传对象
	    error = error || new NIMError();
	    error.retryCount = self.retryCount;
	    error.willReconnect = self.willReconnect();
	    // 重置
	    if (self.backoff) {
	      self.backoff.reset();
	    }
	    self.retryCount = 0;
	    self.connecting = false;
	    // 通知
	    self.logger.info('onDisconnect', error);
	    self.options.ondisconnect(error);
	  }
	};

	// 断开 socket 链接
	ProtocolFn.disconnectSocket = function () {
	  var self = this;
	  if (self.isConnected()) {
	    try {
	      self.socket.disconnect();
	      // 这里将 socket 置空, 否则下次 connect 的时候会切换下一次 transport
	      self.socket = null;
	    } catch (e) {
	      // ignore error
	      console.log(e);
	    }
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ProtocolFn = __webpack_require__(13).fn;
	var config = __webpack_require__(3);

	ProtocolFn.processLink = function (packet) {
	  switch (packet.cmd) {
	    case 'heartbeat':
	      break;
	    default:
	      break;
	  }
	};

	// // 登录成功之后开始心跳
	// ProtocolFn.startHeartbeat = function() {
	//     this.shouldHeartbeat = true
	// };
	//
	// // 断开链接后停止心跳
	// ProtocolFn.stopHeartbeat = function() {
	//     this.shouldHeartbeat = false
	// };
	//
	// // 在收到消息之后和发出指令之后, 调用此方法来在 heartbeatInterval 之后发送心跳包发送心跳包
	// ProtocolFn.heartbeat = function () {
	//     var self = this;
	//     // 清除上一次的计时器
	//     if (!!self.heartbeatTimer) {
	//         clearTimeout(self.heartbeatTimer);
	//     }
	//     // 设置新的计时器
	//     self.heartbeatTimer = setTimeout(function() {
	//         if (self.shouldHeartbeat) {
	//             self.sendCmd('heartbeat', null, self.onHeartbeat.bind(self));
	//         }
	//     }, config.heartbeatInterval);
	// }
	//
	// ProtocolFn.onHeartbeat = function(error, obj) {
	//     this.onMiscError(error, obj, 'heartbeat');
	// };

	// WTF: 服务器只认心跳包, 所以必须一直发, 那么还是改成每隔一段时间发一个心跳包
	ProtocolFn.startHeartbeat = function () {
	  var self = this;
	  self.stopHeartbeat();
	  self.heartbeatTimer = setTimeout(function () {
	    self.sendCmd('heartbeat', null, self.onHeartbeat.bind(self));
	  }, config.heartbeatInterval);
	};

	ProtocolFn.stopHeartbeat = function () {
	  var self = this;
	  if (self.heartbeatTimer) {
	    clearTimeout(self.heartbeatTimer);
	    self.heartbeatTimer = null;
	  }
	};

	ProtocolFn.onHeartbeat = function (error, obj) {
	  var self = this;
	  if (!error) {
	    self.startHeartbeat();
	  }
	  self.onMiscError(error, obj, 'heartbeat');
	};

	ProtocolFn.heartbeat = function () {};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ProtocolFn = __webpack_require__(13).fn;
	var ImageOp = __webpack_require__(35);

	ProtocolFn.processMisc = function (packet) {
	  switch (packet.cmd) {
	    // 获取nos上传凭证
	    case 'getSimpleNosToken':
	      if (!packet.error) {
	        packet.obj = packet.content.nosTokens[0];
	      }
	      break;
	    case 'getNosToken':
	      if (!packet.error) {
	        packet.obj = packet.content.nosToken;
	      }
	      break;
	    case 'notifyUploadLog':
	      if (!packet.error) {
	        this.emitAPI({
	          type: 'notifyUploadLog'
	        });
	      }
	      break;
	    case 'audioToText':
	      if (!packet.error) {
	        packet.obj.text = packet.content.text;
	      }
	      break;
	    case 'processImage':
	      packet.obj.imageOps = ImageOp.reverseImageOps(packet.obj.imageOps);
	      if (!packet.error) {
	        packet.obj = {
	          url: packet.content.url
	        };
	      }
	      break;
	    default:
	      break;
	  }
	};

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var configBase = __webpack_require__(36);

	// 外层是 service, 内层是 cmd
	var idMap = util.merge({}, configBase.idMap, {
	    chatroom: {
	        id: 13,
	        // 进入聊天室
	        login: 2,
	        // 被踢
	        kicked: 3,
	        // 退出聊天室
	        logout: 4,
	        // 发消息
	        sendMsg: 6,
	        // 收到消息
	        msg: 7,
	        // 分页获取成员列表
	        getChatroomMembers: 8,
	        // 获取历史消息
	        getHistoryMsgs: 9,
	        // 设定聊天室成员标记身份
	        markChatroomMember: 11,
	        // 关闭聊天室
	        closeChatroom: 12,
	        // 获取当前聊天室信息
	        getChatroom: 13,
	        // 更新聊天室信息
	        updateChatroom: 14,
	        // 更新自己在聊天室内的信息
	        updateMyChatroomMemberInfo: 15,
	        // 获取指定成员在聊天室中的信息
	        getChatroomMembersInfo: 16,
	        // 踢掉特定成员
	        kickChatroomMember: 17,
	        // 设置聊天室临时禁言
	        updateChatroomMemberTempMute: 19,
	        queueOffer: 20,
	        queuePoll: 21,
	        queueList: 22,
	        peak: 23, // 查看头上第一个元素，但不删除
	        queueDrop: 24,
	        queueInit: 25
	    },
	    user: {
	        id: 3,
	        syncRobot: 16
	    }
	});

	/**
	 * 命令配置
	 * params 说明: 如果类型是 Property, 如果没有 entity, entity 值就是 name
	 */
	var cmdConfig = util.merge({}, configBase.cmdConfig, {
	    login: { sid: idMap.chatroom.id, cid: idMap.chatroom.login, params: [{ type: 'byte', name: 'type' }, { type: 'Property', name: 'login' }, { type: 'Property', name: 'imLogin' }] },
	    logout: { sid: idMap.chatroom.id, cid: idMap.chatroom.logout },
	    sendMsg: { sid: idMap.chatroom.id, cid: idMap.chatroom.sendMsg, params: [{ type: 'Property', name: 'msg' }] },
	    getChatroomMembers: { sid: idMap.chatroom.id, cid: idMap.chatroom.getChatroomMembers, params: [{ type: 'byte', name: 'type' }, { type: 'long', name: 'time' }, { type: 'int', name: 'limit' }] },
	    getHistoryMsgs: { sid: idMap.chatroom.id, cid: idMap.chatroom.getHistoryMsgs, params: [{ type: 'long', name: 'timetag' }, { type: 'int', name: 'limit' }, { type: 'bool', name: 'reverse' }] },
	    markChatroomMember: { sid: idMap.chatroom.id, cid: idMap.chatroom.markChatroomMember, params: [{ type: 'string', name: 'account' }, { type: 'int', name: 'type' }, { type: 'bool', name: 'isAdd' }, { type: 'int', name: 'level' }, { type: 'string', name: 'custom' }] },
	    closeChatroom: { sid: idMap.chatroom.id, cid: idMap.chatroom.closeChatroom, params: [{ type: 'string', name: 'custom' }] },
	    getChatroom: { sid: idMap.chatroom.id, cid: idMap.chatroom.getChatroom },
	    updateChatroom: { sid: idMap.chatroom.id, cid: idMap.chatroom.updateChatroom, params: [{ type: 'Property', name: 'chatroom' }, { type: 'bool', name: 'needNotify' }, { type: 'String', name: 'custom' }] },
	    updateMyChatroomMemberInfo: { sid: idMap.chatroom.id, cid: idMap.chatroom.updateMyChatroomMemberInfo, params: [{ type: 'Property', name: 'chatroomMember' }, { type: 'bool', name: 'needNotify' }, { type: 'String', name: 'custom' }, { type: 'bool', name: 'needSave' }] },
	    getChatroomMembersInfo: { sid: idMap.chatroom.id, cid: idMap.chatroom.getChatroomMembersInfo, params: [{ type: 'StrArray', name: 'accounts' }] },
	    kickChatroomMember: { sid: idMap.chatroom.id, cid: idMap.chatroom.kickChatroomMember, params: [{ type: 'string', name: 'account' }, { type: 'string', name: 'custom' }] },
	    updateChatroomMemberTempMute: { sid: idMap.chatroom.id, cid: idMap.chatroom.updateChatroomMemberTempMute, params: [{ type: 'String', name: 'account' }, { type: 'long', name: 'duration' }, { type: 'bool', name: 'needNotify' }, { type: 'String', name: 'custom' }] },
	    queueOffer: { sid: idMap.chatroom.id, cid: idMap.chatroom.queueOffer, params: [{ type: 'string', name: 'elementKey' }, { type: 'string', name: 'elementValue' }, { type: 'bool', name: 'transient' }] },
	    queuePoll: { sid: idMap.chatroom.id, cid: idMap.chatroom.queuePoll, params: [{ type: 'string', name: 'elementKey' }] },
	    queueList: { sid: idMap.chatroom.id, cid: idMap.chatroom.queueList },
	    peak: { sid: idMap.chatroom.id, cid: idMap.chatroom.peak },
	    queueDrop: { sid: idMap.chatroom.id, cid: idMap.chatroom.queueDrop },
	    queueInit: { sid: idMap.chatroom.id, cid: idMap.chatroom.queueInit, params: [{ type: 'int', name: 'limit' }] },
	    syncRobot: {
	        sid: idMap.user.id,
	        cid: idMap.user.syncRobot,
	        params: [{ type: 'long', name: 'timetag' }]
	    }
	});

	/**
	 * 回包配置
	 * response 说明: 如果没有 entity, entity 值就是 name
	 */
	var serviceChatroom = 'chatroom';
	var packetConfig = util.merge({}, configBase.packetConfig, {
	    // 通知包
	    '4_10': { service: 'notify' },
	    '4_11': { service: 'notify' },
	    '3_16': { service: serviceChatroom, cmd: 'syncRobot', response: [{ type: 'PropertyArray', name: 'robots', entity: 'robot' }] },
	    '13_2': { service: serviceChatroom, cmd: 'login', response: [{ type: 'Property', name: 'chatroom' }, { type: 'Property', name: 'chatroomMember' }] },
	    '13_3': { service: serviceChatroom, cmd: 'kicked', response: [{ type: 'Number', name: 'reason' }, { type: 'String', name: 'custom' }] },
	    '13_4': { service: serviceChatroom, cmd: 'logout' },
	    '13_6': { service: serviceChatroom, cmd: 'sendMsg', response: [{ type: 'Property', name: 'msg' }] },
	    '13_7': { service: serviceChatroom, cmd: 'msg', response: [{ type: 'Property', name: 'msg' }] },
	    '13_8': { service: serviceChatroom, cmd: 'getChatroomMembers', response: [{ type: 'PropertyArray', name: 'members', entity: 'chatroomMember' }] },
	    '13_9': { service: serviceChatroom, cmd: 'getHistoryMsgs', response: [{ type: 'PropertyArray', name: 'msgs', entity: 'msg' }] },
	    '13_11': { service: serviceChatroom, cmd: 'markChatroomMember', response: [{ type: 'Property', name: 'chatroomMember' }] },
	    '13_12': { service: serviceChatroom, cmd: 'closeChatroom' },
	    '13_13': { service: serviceChatroom, cmd: 'getChatroom', response: [{ type: 'Property', name: 'chatroom' }] },
	    '13_14': { service: serviceChatroom, cmd: 'updateChatroom' },
	    '13_15': { service: serviceChatroom, cmd: 'updateMyChatroomMemberInfo' },
	    '13_16': { service: serviceChatroom, cmd: 'getChatroomMembersInfo', response: [{ type: 'PropertyArray', name: 'members', entity: 'chatroomMember' }] },
	    '13_17': { service: serviceChatroom, cmd: 'kickChatroomMember' },
	    '13_19': { service: serviceChatroom, cmd: 'updateChatroomMemberTempMute' },
	    '13_20': { service: serviceChatroom, cmd: 'queueOffer' },
	    '13_21': { service: serviceChatroom, cmd: 'queuePoll', response: [{ type: 'String', name: 'elementKey' }, { type: 'String', name: 'elementValue' }] },
	    '13_22': { service: serviceChatroom, cmd: 'queueList', response: [{ type: 'KVArray', name: 'queueList' }] },
	    '13_23': { service: serviceChatroom, cmd: 'peak', response: [{ type: 'String', name: 'elementKey' }, { type: 'String', name: 'elementValue' }] },
	    '13_24': { service: serviceChatroom, cmd: 'queueDrop' },
	    '13_25': { service: serviceChatroom, cmd: 'queueInit' }
	});

	module.exports = {
	    idMap: idMap,
	    cmdConfig: cmdConfig,
	    packetConfig: packetConfig
	};

/***/ },
/* 63 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  "imLogin": {
	    "os": 4,
	    "sdkVersion": 6,
	    "appLogin": 8,
	    "protocolVersion": 9,
	    "deviceId": 13,
	    "appKey": 18,
	    "account": 19,
	    "browser": 24,
	    "session": 26,
	    "token": 1000
	  },
	  "nosToken": {
	    "objectName": 1,
	    "token": 2,
	    "bucket": 3,
	    "expireTime": 4
	  },
	  "audioToText": {
	    "url": 2
	  },
	  "imageOp": {
	    "type": 0,
	    "stripmeta": 1,
	    "typeType": 2,
	    "blurRadius": 3,
	    "blurSigma": 4,
	    "qualityQuality": 5,
	    "cropX": 6,
	    "cropY": 7,
	    "cropWidth": 8,
	    "cropHeight": 9,
	    "rotateAngle": 10,
	    "pixelPixel": 11,
	    "thumbnailMode": 12,
	    "thumbnailWidth": 13,
	    "thumbnailHeight": 14,
	    "thumbnailAxisX": 15,
	    "thumbnailAxisY": 16,
	    "thumbnailCenterX": 17,
	    "thumbnailCenterY": 18,
	    "thumbnailEnlarge": 19,
	    "thumbnailToStatic": 20,
	    "watermarkType": 21,
	    "watermarkGravity": 22,
	    "watermarkDissolve": 23,
	    "watermarkDx": 24,
	    "watermarkDy": 25,
	    "watermarkImage": 26,
	    "watermarkText": 27,
	    "watermarkFont": 28,
	    "watermarkFontSize": 29,
	    "watermarkFontColor": 30,
	    "interlace": 31
	  },
	  "robot": {
	    "account": 4,
	    "nick": 5,
	    "avatar": 6,
	    "intro": 7,
	    "config": 8,
	    "valid": 9,
	    "createTime": 10,
	    "updateTime": 11,
	    "custid": 12,
	    "botid": 13,
	    "bindTime": 14
	  },
	  "login": {
	    "appKey": 1,
	    "account": 2,
	    "deviceId": 3,
	    "chatroomId": 5,
	    "chatroomNick": 20,
	    "chatroomAvatar": 21,
	    "chatroomCustom": 22,
	    "chatroomEnterCustom": 23,
	    "session": 26,
	    "isAnonymous": 38
	  },
	  "chatroom": {
	    "id": 1,
	    "name": 3,
	    "announcement": 4,
	    "broadcastUrl": 5,
	    "custom": 12,
	    "createTime": 14,
	    "updateTime": 15,
	    "creator": 100,
	    "onlineMemberNum": 101,
	    "mute": 102
	  },
	  "msg": {
	    "idClient": 1,
	    "type": 2,
	    "attach": 3,
	    "custom": 4,
	    "resend": 5,
	    "userUpdateTime": 6,
	    "fromNick": 7,
	    "fromAvatar": 8,
	    "fromCustom": 9,
	    "yidunEnable": 10,
	    "antiSpamContent": 11,
	    "skipHistory": 12,
	    "body": 13,
	    "time": 20,
	    "from": 21,
	    "chatroomId": 22,
	    "fromClientType": 23
	  },
	  "chatroomMember": {
	    "chatroomId": 1,
	    "account": 2,
	    "type": 3,
	    "level": 4,
	    "nick": 5,
	    "avatar": 6,
	    "custom": 7,
	    "online": 8,
	    "guest": 9,
	    "enterTime": 10,
	    "blacked": 12,
	    "gaged": 13,
	    "valid": 14,
	    "updateTime": 15,
	    "tempMuted": 16,
	    "tempMuteDuration": 17
	  }
	};

/***/ },
/* 64 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  "nosToken": {
	    "objectName": 1,
	    "token": 2,
	    "bucket": 3,
	    "expireTime": 4
	  },
	  "audioToText": {
	    "url": 2
	  },
	  "imageOp": {
	    "type": 0,
	    "stripmeta": 1,
	    "typeType": 2,
	    "blurRadius": 3,
	    "blurSigma": 4,
	    "qualityQuality": 5,
	    "cropX": 6,
	    "cropY": 7,
	    "cropWidth": 8,
	    "cropHeight": 9,
	    "rotateAngle": 10,
	    "pixelPixel": 11,
	    "thumbnailMode": 12,
	    "thumbnailWidth": 13,
	    "thumbnailHeight": 14,
	    "thumbnailAxisX": 15,
	    "thumbnailAxisY": 16,
	    "thumbnailCenterX": 17,
	    "thumbnailCenterY": 18,
	    "thumbnailEnlarge": 19,
	    "thumbnailToStatic": 20,
	    "watermarkType": 21,
	    "watermarkGravity": 22,
	    "watermarkDissolve": 23,
	    "watermarkDx": 24,
	    "watermarkDy": 25,
	    "watermarkImage": 26,
	    "watermarkText": 27,
	    "watermarkFont": 28,
	    "watermarkFontSize": 29,
	    "watermarkFontColor": 30,
	    "interlace": 31
	  },
	  "robot": {
	    "account": 4,
	    "nick": 5,
	    "avatar": 6,
	    "intro": 7,
	    "config": 8,
	    "valid": 9,
	    "createTime": 10,
	    "updateTime": 11,
	    "custid": 12,
	    "botid": 13,
	    "bindTime": 14
	  },
	  "login": {
	    "os": 4,
	    "sdkVersion": 6,
	    "appLogin": 8,
	    "protocolVersion": 9,
	    "deviceId": 13,
	    "appKey": 18,
	    "account": 19,
	    "browser": 24,
	    "session": 26,
	    "token": 1000
	  },
	  "loginRes": {
	    "lastLoginDeviceId": 17,
	    "connectionId": 102,
	    "ip": 103,
	    "port": 104,
	    "country": 106
	  },
	  "loginPort": {
	    "type": 3,
	    "os": 4,
	    "mac": 5,
	    "deviceId": 13,
	    "account": 19,
	    "connectionId": 102,
	    "ip": 103,
	    "time": 109
	  },
	  "sync": {
	    "myInfo": 1,
	    "offlineMsgs": 2,
	    "teams": 3,
	    "netcallMsgs": 6,
	    "roamingMsgs": 7,
	    "relations": 9,
	    "friends": 11,
	    "sessions": 12,
	    "friendUsers": 13,
	    "msgReceipts": 14,
	    "myTeamMembers": 15,
	    "donnop": 16,
	    "deleteMsg": 17,
	    "sessionAck": 18,
	    "robots": 19,
	    "broadcastMsgs": 20,
	    "filterMsgs": 100
	  },
	  "donnop": {
	    "open": 1
	  },
	  "team": {
	    "teamId": 1,
	    "name": 3,
	    "type": 4,
	    "owner": 5,
	    "level": 6,
	    "selfCustom": 7,
	    "valid": 8,
	    "memberNum": 9,
	    "memberUpdateTime": 10,
	    "createTime": 11,
	    "updateTime": 12,
	    "validToCurrentUser": 13,
	    "intro": 14,
	    "announcement": 15,
	    "joinMode": 16,
	    "bits": 17,
	    "custom": 18,
	    "serverCustom": 19,
	    "avatar": 20,
	    "beInviteMode": 21,
	    "inviteMode": 22,
	    "updateTeamMode": 23,
	    "updateCustomMode": 24,
	    "mute": 100
	  },
	  "teamMember": {
	    "teamId": 1,
	    "account": 3,
	    "type": 4,
	    "nickInTeam": 5,
	    "bits": 7,
	    "active": 8,
	    "valid": 9,
	    "joinTime": 10,
	    "updateTime": 11,
	    "custom": 12,
	    "mute": 13
	  },
	  "msg": {
	    "scene": 0,
	    "to": 1,
	    "from": 2,
	    "fromClientType": 4,
	    "fromDeviceId": 5,
	    "fromNick": 6,
	    "time": 7,
	    "type": 8,
	    "body": 9,
	    "attach": 10,
	    "idClient": 11,
	    "idServer": 12,
	    "resend": 13,
	    "userUpdateTime": 14,
	    "custom": 15,
	    "pushPayload": 16,
	    "pushContent": 17,
	    "apnsAccounts": 18,
	    "apnsContent": 19,
	    "apnsForcePush": 20,
	    "yidunEnable": 21,
	    "antiSpamContent": 22,
	    "isHistoryable": 100,
	    "isRoamingable": 101,
	    "isSyncable": 102,
	    "isMuted": 104,
	    "cc": 105,
	    "isPushable": 107,
	    "isOfflinable": 108,
	    "isUnreadable": 109,
	    "needPushNick": 110
	  },
	  "msgReceipt": {
	    "to": 1,
	    "from": 2,
	    "time": 7,
	    "idClient": 11
	  },
	  "sysMsg": {
	    "time": 0,
	    "type": 1,
	    "to": 2,
	    "from": 3,
	    "ps": 4,
	    "attach": 5,
	    "idServer": 6,
	    "sendToOnlineUsersOnly": 7,
	    "apnsText": 8,
	    "pushPayload": 9,
	    "deletedIdClient": 10,
	    "deletedIdServer": 11,
	    "yidunEnable": 12,
	    "antiSpamContent": 13,
	    "deletedMsgTime": 14,
	    "deletedMsgFromNick": 15,
	    "cc": 105,
	    "isPushable": 107,
	    "isUnreadable": 109,
	    "needPushNick": 110
	  },
	  "broadcastMsg": {
	    "broadcastId": 1,
	    "fromAccid": 2,
	    "fromUid": 3,
	    "timestamp": 4,
	    "body": 5
	  },
	  "friend": {
	    "account": 4,
	    "flag": 5,
	    "beflag": 6,
	    "source": 7,
	    "alias": 8,
	    "bits": 9,
	    "custom": 10,
	    "createTime": 11,
	    "updateTime": 12
	  },
	  "user": {
	    "account": 1,
	    "nick": 3,
	    "avatar": 4,
	    "sign": 5,
	    "gender": 6,
	    "email": 7,
	    "birth": 8,
	    "tel": 9,
	    "custom": 10,
	    "createTime": 12,
	    "updateTime": 13
	  },
	  "specialRelation": {
	    "account": 0,
	    "isMuted": 1,
	    "isBlacked": 2,
	    "createTime": 3,
	    "updateTime": 4
	  },
	  "msgType": {
	    "text": 0,
	    "picture": 1,
	    "audio": 2,
	    "video": 3,
	    "location": 4,
	    "notification": 5,
	    "file": 6,
	    "netcall_audio": 7,
	    "netcall_vedio": 8,
	    "datatunnel_new": 9,
	    "tips": 10,
	    "robot": 11,
	    "custom": 100
	  },
	  "msgEvent": {
	    "type": 1,
	    "value": 2,
	    "idClient": 3,
	    "custom": 4,
	    "validTime": 5,
	    "broadcastType": 6,
	    "sync": 7,
	    "validTimeType": 8,
	    "durable": 9,
	    "time": 10,
	    "idServer": 11,
	    "clientType": 12,
	    "serverConfig": 13,
	    "serverCustom": 14,
	    "appid": 101,
	    "account": 103,
	    "enableMultiClient": 104,
	    "consid": 106
	  },
	  "msgEventSubscribe": {
	    "type": 1,
	    "subscribeTime": 2,
	    "sync": 3,
	    "to": 102,
	    "from": 104,
	    "time": 105
	  }
	};

/***/ },
/* 65 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  "imLogin": {
	    "4": "os",
	    "6": "sdkVersion",
	    "8": "appLogin",
	    "9": "protocolVersion",
	    "13": "deviceId",
	    "18": "appKey",
	    "19": "account",
	    "24": "browser",
	    "26": "session",
	    "1000": "token"
	  },
	  "nosToken": {
	    "1": "objectName",
	    "2": "token",
	    "3": "bucket",
	    "4": "expireTime"
	  },
	  "audioToText": {
	    "2": "url"
	  },
	  "imageOp": {
	    "0": "type",
	    "1": "stripmeta",
	    "2": "typeType",
	    "3": "blurRadius",
	    "4": "blurSigma",
	    "5": "qualityQuality",
	    "6": "cropX",
	    "7": "cropY",
	    "8": "cropWidth",
	    "9": "cropHeight",
	    "10": "rotateAngle",
	    "11": "pixelPixel",
	    "12": "thumbnailMode",
	    "13": "thumbnailWidth",
	    "14": "thumbnailHeight",
	    "15": "thumbnailAxisX",
	    "16": "thumbnailAxisY",
	    "17": "thumbnailCenterX",
	    "18": "thumbnailCenterY",
	    "19": "thumbnailEnlarge",
	    "20": "thumbnailToStatic",
	    "21": "watermarkType",
	    "22": "watermarkGravity",
	    "23": "watermarkDissolve",
	    "24": "watermarkDx",
	    "25": "watermarkDy",
	    "26": "watermarkImage",
	    "27": "watermarkText",
	    "28": "watermarkFont",
	    "29": "watermarkFontSize",
	    "30": "watermarkFontColor",
	    "31": "interlace"
	  },
	  "robot": {
	    "4": "account",
	    "5": "nick",
	    "6": "avatar",
	    "7": "intro",
	    "8": "config",
	    "9": "valid",
	    "10": "createTime",
	    "11": "updateTime",
	    "12": "custid",
	    "13": "botid",
	    "14": "bindTime"
	  },
	  "login": {
	    "1": "appKey",
	    "2": "account",
	    "3": "deviceId",
	    "5": "chatroomId",
	    "20": "chatroomNick",
	    "21": "chatroomAvatar",
	    "22": "chatroomCustom",
	    "23": "chatroomEnterCustom",
	    "26": "session",
	    "38": "isAnonymous"
	  },
	  "chatroom": {
	    "1": "id",
	    "3": "name",
	    "4": "announcement",
	    "5": "broadcastUrl",
	    "12": "custom",
	    "14": "createTime",
	    "15": "updateTime",
	    "100": "creator",
	    "101": "onlineMemberNum",
	    "102": "mute"
	  },
	  "msg": {
	    "1": "idClient",
	    "2": "type",
	    "3": "attach",
	    "4": "custom",
	    "5": "resend",
	    "6": "userUpdateTime",
	    "7": "fromNick",
	    "8": "fromAvatar",
	    "9": "fromCustom",
	    "10": "yidunEnable",
	    "11": "antiSpamContent",
	    "12": "skipHistory",
	    "13": "body",
	    "20": "time",
	    "21": "from",
	    "22": "chatroomId",
	    "23": "fromClientType"
	  },
	  "chatroomMember": {
	    "1": "chatroomId",
	    "2": "account",
	    "3": "type",
	    "4": "level",
	    "5": "nick",
	    "6": "avatar",
	    "7": "custom",
	    "8": "online",
	    "9": "guest",
	    "10": "enterTime",
	    "12": "blacked",
	    "13": "gaged",
	    "14": "valid",
	    "15": "updateTime",
	    "16": "tempMuted",
	    "17": "tempMuteDuration"
	  }
	};

/***/ },
/* 66 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  "nosToken": {
	    "1": "objectName",
	    "2": "token",
	    "3": "bucket",
	    "4": "expireTime"
	  },
	  "audioToText": {
	    "2": "url"
	  },
	  "imageOp": {
	    "0": "type",
	    "1": "stripmeta",
	    "2": "typeType",
	    "3": "blurRadius",
	    "4": "blurSigma",
	    "5": "qualityQuality",
	    "6": "cropX",
	    "7": "cropY",
	    "8": "cropWidth",
	    "9": "cropHeight",
	    "10": "rotateAngle",
	    "11": "pixelPixel",
	    "12": "thumbnailMode",
	    "13": "thumbnailWidth",
	    "14": "thumbnailHeight",
	    "15": "thumbnailAxisX",
	    "16": "thumbnailAxisY",
	    "17": "thumbnailCenterX",
	    "18": "thumbnailCenterY",
	    "19": "thumbnailEnlarge",
	    "20": "thumbnailToStatic",
	    "21": "watermarkType",
	    "22": "watermarkGravity",
	    "23": "watermarkDissolve",
	    "24": "watermarkDx",
	    "25": "watermarkDy",
	    "26": "watermarkImage",
	    "27": "watermarkText",
	    "28": "watermarkFont",
	    "29": "watermarkFontSize",
	    "30": "watermarkFontColor",
	    "31": "interlace"
	  },
	  "robot": {
	    "4": "account",
	    "5": "nick",
	    "6": "avatar",
	    "7": "intro",
	    "8": "config",
	    "9": "valid",
	    "10": "createTime",
	    "11": "updateTime",
	    "12": "custid",
	    "13": "botid",
	    "14": "bindTime"
	  },
	  "login": {
	    "4": "os",
	    "6": "sdkVersion",
	    "8": "appLogin",
	    "9": "protocolVersion",
	    "13": "deviceId",
	    "18": "appKey",
	    "19": "account",
	    "24": "browser",
	    "26": "session",
	    "1000": "token"
	  },
	  "loginRes": {
	    "17": "lastLoginDeviceId",
	    "102": "connectionId",
	    "103": "ip",
	    "104": "port",
	    "106": "country"
	  },
	  "loginPort": {
	    "3": "type",
	    "4": "os",
	    "5": "mac",
	    "13": "deviceId",
	    "19": "account",
	    "102": "connectionId",
	    "103": "ip",
	    "109": "time"
	  },
	  "sync": {
	    "1": "myInfo",
	    "2": "offlineMsgs",
	    "3": "teams",
	    "6": "netcallMsgs",
	    "7": "roamingMsgs",
	    "9": "relations",
	    "11": "friends",
	    "12": "sessions",
	    "13": "friendUsers",
	    "14": "msgReceipts",
	    "15": "myTeamMembers",
	    "16": "donnop",
	    "17": "deleteMsg",
	    "18": "sessionAck",
	    "19": "robots",
	    "20": "broadcastMsgs",
	    "100": "filterMsgs"
	  },
	  "donnop": {
	    "1": "open"
	  },
	  "team": {
	    "1": "teamId",
	    "3": "name",
	    "4": "type",
	    "5": "owner",
	    "6": "level",
	    "7": "selfCustom",
	    "8": "valid",
	    "9": "memberNum",
	    "10": "memberUpdateTime",
	    "11": "createTime",
	    "12": "updateTime",
	    "13": "validToCurrentUser",
	    "14": "intro",
	    "15": "announcement",
	    "16": "joinMode",
	    "17": "bits",
	    "18": "custom",
	    "19": "serverCustom",
	    "20": "avatar",
	    "21": "beInviteMode",
	    "22": "inviteMode",
	    "23": "updateTeamMode",
	    "24": "updateCustomMode",
	    "100": "mute"
	  },
	  "teamMember": {
	    "1": "teamId",
	    "3": "account",
	    "4": "type",
	    "5": "nickInTeam",
	    "7": "bits",
	    "8": "active",
	    "9": "valid",
	    "10": "joinTime",
	    "11": "updateTime",
	    "12": "custom",
	    "13": "mute"
	  },
	  "msg": {
	    "0": "scene",
	    "1": "to",
	    "2": "from",
	    "4": "fromClientType",
	    "5": "fromDeviceId",
	    "6": "fromNick",
	    "7": "time",
	    "8": "type",
	    "9": "body",
	    "10": "attach",
	    "11": "idClient",
	    "12": "idServer",
	    "13": "resend",
	    "14": "userUpdateTime",
	    "15": "custom",
	    "16": "pushPayload",
	    "17": "pushContent",
	    "18": "apnsAccounts",
	    "19": "apnsContent",
	    "20": "apnsForcePush",
	    "21": "yidunEnable",
	    "22": "antiSpamContent",
	    "100": "isHistoryable",
	    "101": "isRoamingable",
	    "102": "isSyncable",
	    "104": "isMuted",
	    "105": "cc",
	    "107": "isPushable",
	    "108": "isOfflinable",
	    "109": "isUnreadable",
	    "110": "needPushNick"
	  },
	  "msgReceipt": {
	    "1": "to",
	    "2": "from",
	    "7": "time",
	    "11": "idClient"
	  },
	  "sysMsg": {
	    "0": "time",
	    "1": "type",
	    "2": "to",
	    "3": "from",
	    "4": "ps",
	    "5": "attach",
	    "6": "idServer",
	    "7": "sendToOnlineUsersOnly",
	    "8": "apnsText",
	    "9": "pushPayload",
	    "10": "deletedIdClient",
	    "11": "deletedIdServer",
	    "12": "yidunEnable",
	    "13": "antiSpamContent",
	    "14": "deletedMsgTime",
	    "15": "deletedMsgFromNick",
	    "105": "cc",
	    "107": "isPushable",
	    "109": "isUnreadable",
	    "110": "needPushNick"
	  },
	  "broadcastMsg": {
	    "1": "broadcastId",
	    "2": "fromAccid",
	    "3": "fromUid",
	    "4": "timestamp",
	    "5": "body"
	  },
	  "friend": {
	    "4": "account",
	    "5": "flag",
	    "6": "beflag",
	    "7": "source",
	    "8": "alias",
	    "9": "bits",
	    "10": "custom",
	    "11": "createTime",
	    "12": "updateTime"
	  },
	  "user": {
	    "1": "account",
	    "3": "nick",
	    "4": "avatar",
	    "5": "sign",
	    "6": "gender",
	    "7": "email",
	    "8": "birth",
	    "9": "tel",
	    "10": "custom",
	    "12": "createTime",
	    "13": "updateTime"
	  },
	  "specialRelation": {
	    "0": "account",
	    "1": "isMuted",
	    "2": "isBlacked",
	    "3": "createTime",
	    "4": "updateTime"
	  },
	  "msgType": {
	    "0": "text",
	    "1": "picture",
	    "2": "audio",
	    "3": "video",
	    "4": "location",
	    "5": "notification",
	    "6": "file",
	    "7": "netcall_audio",
	    "8": "netcall_vedio",
	    "9": "datatunnel_new",
	    "10": "tips",
	    "11": "robot",
	    "100": "custom"
	  },
	  "msgEvent": {
	    "1": "type",
	    "2": "value",
	    "3": "idClient",
	    "4": "custom",
	    "5": "validTime",
	    "6": "broadcastType",
	    "7": "sync",
	    "8": "validTimeType",
	    "9": "durable",
	    "10": "time",
	    "11": "idServer",
	    "12": "clientType",
	    "13": "serverConfig",
	    "14": "serverCustom",
	    "101": "appid",
	    "103": "account",
	    "104": "enableMultiClient",
	    "106": "consid"
	  },
	  "msgEventSubscribe": {
	    "1": "type",
	    "2": "subscribeTime",
	    "3": "sync",
	    "102": "to",
	    "104": "from",
	    "105": "time"
	  }
	};

/***/ },
/* 67 */,
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var platform = __webpack_require__(9);
	var util = __webpack_require__(1);

	/**
	 * 日志, SDK内部使用
	 *
	 * @constructor
	 * @alias Logger
	 * @private
	 */

	function Logger() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  util.merge(this, {
	    options: options,
	    debug: false,
	    api: 'log',
	    style: 'color:blue;',
	    log: util.emptyFunc,
	    info: util.emptyFunc,
	    warn: util.emptyFunc,
	    error: util.emptyFunc
	  });
	  this.prefix = options.prefix || '';
	  this.setDebug(options.debug);
	}

	var pro = Logger.prototype;

	var supportedBrowsers = ['Chrome', 'Safari', 'Firefox'];

	pro.setDebug = function () {
	  var debug = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	  var logger = this;
	  logger.debug = debug;
	  if (debug.style) {
	    logger.style = debug.style;
	  }
	  if (logger.debug && util.exist(console)) {
	    var cs = console;
	    logger.log = function () {
	      var args = logger.formatArgs(arguments);
	      if (supportedBrowsers.indexOf(platform.name) !== -1 && util.isString(args[0])) {
	        args[0] = '%c' + args[0];
	        args.splice(1, 0, logger.style);
	      }
	      logger._log('log', args);
	    };
	    logger.info = function () {
	      var args = logger.formatArgs(arguments);
	      logger._log('info', args);
	    };
	    logger.warn = function () {
	      var args = logger.formatArgs(arguments);
	      logger._log('warn', args);
	    };
	    logger.error = function () {
	      var args = logger.formatArgs(arguments);
	      logger._log('error', args);
	    };
	    logger._log = function (name, args) {
	      // 使用开发者传入的方法来记录日志
	      var logFunc = logger.options.logFunc;
	      if (logFunc) {
	        if (logFunc[name]) {
	          logFunc = logFunc[name];
	        }
	        if (util.isFunction(logFunc)) {
	          logFunc.apply(null, args);
	          return;
	        }
	      }
	      // 使用 console 来记录日志
	      if (cs[name]) {
	        try {
	          if (cs[name].apply) {
	            logger.chrome(name, args);
	          } else {
	            logger.ie(name, args);
	          }
	        } catch (e) {
	          // ignore error
	        }
	      }
	    };
	    // use this form to skip drop_console of uglify
	    logger.chrome = function (func, args) {
	      if (supportedBrowsers.indexOf(platform.name) !== -1) {
	        cs[func].apply(cs, args);
	      } else {
	        logger.ie(func, args);
	      }
	    };
	    logger.ie = function (func, args) {
	      args.forEach(function (arg) {
	        cs[func](JSON.stringify(arg, null, 4));
	      });
	    };
	  }
	};

	pro.formatArgs = function (args) {
	  var logger = this;
	  args = [].slice.call(args, 0);
	  var date = new Date();
	  var dateStr = date.getFullYear() + '-' + formatTimeUnit(date.getMonth() + 1) + '-' + formatTimeUnit(date.getDate()) + ' ' + formatTimeUnit(date.getHours()) + ':' + formatTimeUnit(date.getMinutes()) + ':' + formatTimeUnit(date.getSeconds()) + ':' + formatTimeUnit(date.getMilliseconds(), 3);
	  var prefix = '[NIM SDK LOG ' + dateStr + ' ' + +date + ' ' + logger.prefix + ']\t';
	  if (util.isString(args[0])) {
	    args[0] = prefix + args[0];
	  } else {
	    args.splice(0, 0, prefix);
	  }
	  args.forEach(function (arg, index) {
	    if (util.isArray(arg) || util.isObject(arg)) {
	      args[index] = util.simpleClone(arg);
	    }
	  });
	  return args;
	};

	var formatTimeUnit = function formatTimeUnit(num, count) {
	  count = count || 2;
	  var str = '' + num;
	  while (str.length < count) {
	    str = '0' + str;
	  }
	  return str;
	};

	module.exports = Logger;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);

	var responseBodyMap = {
	    file: {
	        // url: '',                 // url 根据Bucket和ObjectName拼装
	        // ext: '',                 // 文件后缀, 根据name来截取
	        // name: '$(FileName)',     // 文件名由程序自己获取
	        md5: '$(Etag)',
	        size: '$(ObjectSize)' // long 单位byte
	    },
	    image: {
	        // url: '',
	        // ext: '',
	        // name: '$(FileName)',
	        md5: '$(Etag)',
	        size: '$(ObjectSize)',
	        w: '$(ImageInfo.Width)', // 图片宽度 int 单位: 像素
	        h: '$(ImageInfo.Height)', // 图片高度 int 单位: 像素
	        orientation: '$(ImageInfo.Orientation)'
	    },
	    audio: {
	        // url: '',
	        // ext: '',
	        // name: '$(FileName)',
	        md5: '$(Etag)',
	        size: '$(ObjectSize)',
	        dur: '$(AVinfo.Audio.Duration)' // 持续时间, 单位ms
	    },
	    video: {
	        // url: '',
	        // ext: '',
	        // name: '$(FileName)',
	        md5: '$(Etag)',
	        size: '$(ObjectSize)',
	        dur: '$(AVinfo.Video.Duration)', // 持续时间, 单位ms
	        w: '$(AVinfo.Video.Width)', // 分辨率
	        h: '$(AVinfo.Video.Height)' // 分辨率
	    }
	};

	var nos = {};

	nos.genResponseBody = function (type) {
	    type = type || 'file';
	    return responseBodyMap[type];
	};

	// https://en.wikipedia.org/wiki/Exchangeable_image_file_format
	// http://www.impulseadventure.com/photo/exif-orientation.html
	// top, left      Orientation: Horizontal (normal)
	// right, top     Orientation: Rotate 90 CW
	// bottom, right  Orientation: Rotate 180
	// left, bottom   Orientation: Rotate 270 CW
	/**
	 * 解析 nos 返回的数据
	 * @param  {Object} obj             nos 返回的数据
	 * @param  {Boolean} exifOrientation 是否需要根据 exif orientation 信息来交换宽高
	 * @return {Object}                 解析后的数据
	 */
	nos.parseResponse = function (obj, exifOrientation) {
	    if (util.notundef(obj.size)) {
	        obj.size = +obj.size;
	    }
	    if (util.notundef(obj.w)) {
	        obj.w = +obj.w;
	    }
	    if (util.notundef(obj.h)) {
	        obj.h = +obj.h;
	    }
	    if (util.notundef(obj.dur)) {
	        obj.dur = +obj.dur;
	    }
	    var orientation = obj.orientation;
	    if (util.notundef(orientation)) {
	        delete obj.orientation;
	        if (exifOrientation) {
	            if (orientation === 'right, top' || orientation === 'left, bottom') {
	                var temp = obj.w;
	                obj.w = obj.h;
	                obj.h = temp;
	            }
	        }
	    }
	    return obj;
	};

	module.exports = nos;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var NIMError = __webpack_require__(4);
	var upload = __webpack_require__(21).upload;
	var abort = __webpack_require__(21).abort;

	// 是否支持FormData
	var supportFormData = util.supportFormData;
	// var supportFormData = false; // test code for mock IE 8/9
	// 文件最大100M
	var fileMaxSize = 100 * 1024 * 1024;

	/**
	 * 文件上传控件, 使用FormData或者Iframe上传文件
	 *
	 * @param {options} options 配置参数
	 * @param {String}          options.url             服务器url
	 * @param {String|Node}     options.fileInput       文件选择input的id或者节点对象
	 * @param {String}          options.type            文件类型过滤
	 * @param {Object}          options.params          其它参数
	 * @param {Function}        options.beginupload     开始上传图片的回调, 如果开发者传入 fileInput, 在此回调之前不能修改 fileInput, 否则上传的文件会错乱
	 * @param {Function}        options.uploadprogress  上传进度, ie9以下不支持上传进度
	 * @param {Function}        options.uploaddone      上传完成, 成功或者失败
	 * @param {[Object]}        headers                 请求头
	 */
	function Upload(options) {
	  var self = this;
	  self.options = util.copy(options);
	  util.verifyOptions(options, 'url fileName');
	  util.verifyParamPresentJustOne(options, 'blob fileInput');
	  util.verifyCallback(options, 'beginupload uploadprogress uploaddone');
	  if (options.fileInput) {
	    options.fileInput = util.verifyFileInput(options.fileInput);
	  }
	  if (options.type) {
	    util.verifyFileType(options.type);
	  }
	  if (options.timeout) {
	    util.verifyParamType('timeout', options.timeout, 'number');
	  } else {
	    // 0 means no timeout
	    options.timeout = 1000 * 60 * 10;
	  }
	  util.verifyFileUploadCallback(options);

	  options.data = {};
	  // 名字
	  var fileName = options.fileName;
	  var fileInput = options.fileInput;
	  if (supportFormData) {
	    // 如果是fileInput
	    if (fileInput) {
	      // 过滤
	      var fileList = options.type ? util.filterFiles(fileInput.files, options.type) : [].slice.call(fileInput.files, 0);
	      if (!fileList || !fileList.length) {
	        options.uploaddone(NIMError.newWrongFileTypeError('未读取到' + options.type + '类型的文件, 请确保文件选择节点的文件不为空, 并且请确保选择了' + options.type + '类型的文件'));
	        return;
	      }
	      // 验证大小
	      var size = fileInput.files[0].size;
	      if (size > fileMaxSize) {
	        options.uploaddone(NIMError.newFileTooLargeError('文件大小超过100M'));
	        return;
	      }
	      options.data[fileName] = fileList[0];
	    } else if (options.blob) {
	      options.data[fileName] = options.blob;
	    }
	  } else {
	    util.dataset(fileInput, 'name', fileName);
	    options.data.input = fileInput;
	  }

	  // 添加其它参数
	  if (options.params) {
	    util.merge(options.data, options.params);
	  }

	  var uploadOptions = {
	    data: options.data,
	    onaftersend: function onaftersend() {
	      options.beginupload(self);
	    },
	    onuploading: function onuploading(event) {
	      var percentage = Math.floor(event.loaded * 10000 / event.total) / 100.0;
	      var obj = {
	        total: event.total,
	        loaded: event.loaded,
	        percentage: percentage,
	        percentageText: percentage + '%'
	      };
	      if (options.fileInput) {
	        obj.fileInput = options.fileInput;
	      }
	      if (options.blob) {
	        obj.blob = options.blob;
	      }
	      options.uploadprogress(obj);
	    },
	    onload: function onload(obj) {
	      // IE 8/9 报错走这里, see onerror
	      if (obj.Error) {
	        self.onError(obj);
	      } else {
	        options.uploaddone(null, obj);
	      }
	    },
	    onerror: function onerror(obj) {
	      // 高级浏览器报错走这里, see onload
	      try {
	        // 能解析 obj.result 的时候, 它包含 nos 错误的详情, 其它情况 see catch
	        if (obj.result) {
	          var result = JSON.parse(obj.result);
	        } else {
	          result = obj;
	        }
	        self.onError(result);
	      } catch (error) {
	        console.error('ignore error if could not parse obj.result', error);
	        options.uploaddone(new NIMError(obj.message, obj.code), self.options);
	      }
	    }
	  };

	  // 其实并不需要指定 mode, 会自动识别, 这里是为了在 chrome 上测试 mode 才加了这段代码
	  if (!supportFormData) {
	    uploadOptions.mode = 'iframe';
	  }

	  uploadOptions.putFileAtEnd = true;

	  self.sn = upload(options.url, uploadOptions);
	}

	Upload.prototype.onError = function (obj) {
	  var self = this;
	  var options = self.options;
	  var error, reason, message;
	  obj = obj || {};
	  error = obj.Error || obj || {};
	  reason = error.Code || error.code || 'unknown';
	  message = error.Message || error.message || '未知错误';
	  options.uploaddone(new NIMError(reason + '(' + message + ')', reason));
	};

	Upload.prototype.abort = function () {
	  abort(this.sn);
	};

	module.exports = Upload;

/***/ },
/* 71 */,
/* 72 */,
/* 73 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Backoff`.
	 */

	module.exports = Backoff;

	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */

	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}

	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */

	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};

	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */

	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};

	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};

	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};

	/**
	 * Set the jitter
	 *
	 * @api public
	 */

	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};



/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * https://github.com/es-shims/es5-shim
	 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
	 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
	 */

	// vim: ts=4 sts=4 sw=4 expandtab

	// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
	;

	// UMD (Universal Module Definition)
	// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
	(function (root, factory) {
	    'use strict';

	    /* global define, exports, module */
	    if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        // Node. Does not work with strict CommonJS, but
	        // only CommonJS-like enviroments that support module.exports,
	        // like Node.
	        module.exports = factory();
	    } else {
	        // Browser globals (root is window)
	        root.returnExports = factory();
	    }
	}(this, function () {

	    var call = Function.call;
	    var prototypeOfObject = Object.prototype;
	    var owns = call.bind(prototypeOfObject.hasOwnProperty);
	    var isEnumerable = call.bind(prototypeOfObject.propertyIsEnumerable);
	    var toStr = call.bind(prototypeOfObject.toString);

	    // If JS engine supports accessors creating shortcuts.
	    var defineGetter;
	    var defineSetter;
	    var lookupGetter;
	    var lookupSetter;
	    var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
	    if (supportsAccessors) {
	        /* eslint-disable no-underscore-dangle */
	        defineGetter = call.bind(prototypeOfObject.__defineGetter__);
	        defineSetter = call.bind(prototypeOfObject.__defineSetter__);
	        lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
	        lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
	        /* eslint-enable no-underscore-dangle */
	    }

	    var isPrimitive = function isPrimitive(o) {
	        return o == null || (typeof o !== 'object' && typeof o !== 'function');
	    };

	    // ES5 15.2.3.2
	    // http://es5.github.com/#x15.2.3.2
	    if (!Object.getPrototypeOf) {
	        // https://github.com/es-shims/es5-shim/issues#issue/2
	        // http://ejohn.org/blog/objectgetprototypeof/
	        // recommended by fschaefer on github
	        //
	        // sure, and webreflection says ^_^
	        // ... this will nerever possibly return null
	        // ... Opera Mini breaks here with infinite loops
	        Object.getPrototypeOf = function getPrototypeOf(object) {
	            /* eslint-disable no-proto */
	            var proto = object.__proto__;
	            /* eslint-enable no-proto */
	            if (proto || proto === null) {
	                return proto;
	            } else if (toStr(object.constructor) === '[object Function]') {
	                return object.constructor.prototype;
	            } else if (object instanceof Object) {
	                return prototypeOfObject;
	            } else {
	                // Correctly return null for Objects created with `Object.create(null)`
	                // (shammed or native) or `{ __proto__: null}`.  Also returns null for
	                // cross-realm objects on browsers that lack `__proto__` support (like
	                // IE <11), but that's the best we can do.
	                return null;
	            }
	        };
	    }

	    // ES5 15.2.3.3
	    // http://es5.github.com/#x15.2.3.3

	    var doesGetOwnPropertyDescriptorWork = function doesGetOwnPropertyDescriptorWork(object) {
	        try {
	            object.sentinel = 0;
	            return Object.getOwnPropertyDescriptor(object, 'sentinel').value === 0;
	        } catch (exception) {
	            return false;
	        }
	    };

	    // check whether getOwnPropertyDescriptor works if it's given. Otherwise, shim partially.
	    if (Object.defineProperty) {
	        var getOwnPropertyDescriptorWorksOnObject = doesGetOwnPropertyDescriptorWork({});
	        var getOwnPropertyDescriptorWorksOnDom = typeof document === 'undefined' ||
	        doesGetOwnPropertyDescriptorWork(document.createElement('div'));
	        if (!getOwnPropertyDescriptorWorksOnDom || !getOwnPropertyDescriptorWorksOnObject) {
	            var getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;
	        }
	    }

	    if (!Object.getOwnPropertyDescriptor || getOwnPropertyDescriptorFallback) {
	        var ERR_NON_OBJECT = 'Object.getOwnPropertyDescriptor called on a non-object: ';

	        /* eslint-disable no-proto */
	        Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
	            if (isPrimitive(object)) {
	                throw new TypeError(ERR_NON_OBJECT + object);
	            }

	            // make a valiant attempt to use the real getOwnPropertyDescriptor
	            // for I8's DOM elements.
	            if (getOwnPropertyDescriptorFallback) {
	                try {
	                    return getOwnPropertyDescriptorFallback.call(Object, object, property);
	                } catch (exception) {
	                    // try the shim if the real one doesn't work
	                }
	            }

	            var descriptor;

	            // If object does not owns property return undefined immediately.
	            if (!owns(object, property)) {
	                return descriptor;
	            }

	            // If object has a property then it's for sure `configurable`, and
	            // probably `enumerable`. Detect enumerability though.
	            descriptor = {
	                enumerable: isEnumerable(object, property),
	                configurable: true
	            };

	            // If JS engine supports accessor properties then property may be a
	            // getter or setter.
	            if (supportsAccessors) {
	                // Unfortunately `__lookupGetter__` will return a getter even
	                // if object has own non getter property along with a same named
	                // inherited getter. To avoid misbehavior we temporary remove
	                // `__proto__` so that `__lookupGetter__` will return getter only
	                // if it's owned by an object.
	                var prototype = object.__proto__;
	                var notPrototypeOfObject = object !== prototypeOfObject;
	                // avoid recursion problem, breaking in Opera Mini when
	                // Object.getOwnPropertyDescriptor(Object.prototype, 'toString')
	                // or any other Object.prototype accessor
	                if (notPrototypeOfObject) {
	                    object.__proto__ = prototypeOfObject;
	                }

	                var getter = lookupGetter(object, property);
	                var setter = lookupSetter(object, property);

	                if (notPrototypeOfObject) {
	                    // Once we have getter and setter we can put values back.
	                    object.__proto__ = prototype;
	                }

	                if (getter || setter) {
	                    if (getter) {
	                        descriptor.get = getter;
	                    }
	                    if (setter) {
	                        descriptor.set = setter;
	                    }
	                    // If it was accessor property we're done and return here
	                    // in order to avoid adding `value` to the descriptor.
	                    return descriptor;
	                }
	            }

	            // If we got this far we know that object has an own property that is
	            // not an accessor so we set it as a value and return descriptor.
	            descriptor.value = object[property];
	            descriptor.writable = true;
	            return descriptor;
	        };
	        /* eslint-enable no-proto */
	    }

	    // ES5 15.2.3.4
	    // http://es5.github.com/#x15.2.3.4
	    if (!Object.getOwnPropertyNames) {
	        Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
	            return Object.keys(object);
	        };
	    }

	    // ES5 15.2.3.5
	    // http://es5.github.com/#x15.2.3.5
	    if (!Object.create) {

	        // Contributed by Brandon Benvie, October, 2012
	        var createEmpty;
	        var supportsProto = !({ __proto__: null } instanceof Object);
	                            // the following produces false positives
	                            // in Opera Mini => not a reliable check
	                            // Object.prototype.__proto__ === null

	        // Check for document.domain and active x support
	        // No need to use active x approach when document.domain is not set
	        // see https://github.com/es-shims/es5-shim/issues/150
	        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	        /* global ActiveXObject */
	        var shouldUseActiveX = function shouldUseActiveX() {
	            // return early if document.domain not set
	            if (!document.domain) {
	                return false;
	            }

	            try {
	                return !!new ActiveXObject('htmlfile');
	            } catch (exception) {
	                return false;
	            }
	        };

	        // This supports IE8 when document.domain is used
	        // see https://github.com/es-shims/es5-shim/issues/150
	        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	        var getEmptyViaActiveX = function getEmptyViaActiveX() {
	            var empty;
	            var xDoc;

	            xDoc = new ActiveXObject('htmlfile');

	            var script = 'script';
	            xDoc.write('<' + script + '></' + script + '>');
	            xDoc.close();

	            empty = xDoc.parentWindow.Object.prototype;
	            xDoc = null;

	            return empty;
	        };

	        // The original implementation using an iframe
	        // before the activex approach was added
	        // see https://github.com/es-shims/es5-shim/issues/150
	        var getEmptyViaIFrame = function getEmptyViaIFrame() {
	            var iframe = document.createElement('iframe');
	            var parent = document.body || document.documentElement;
	            var empty;

	            iframe.style.display = 'none';
	            parent.appendChild(iframe);
	            /* eslint-disable no-script-url */
	            iframe.src = 'javascript:';
	            /* eslint-enable no-script-url */

	            empty = iframe.contentWindow.Object.prototype;
	            parent.removeChild(iframe);
	            iframe = null;

	            return empty;
	        };

	        /* global document */
	        if (supportsProto || typeof document === 'undefined') {
	            createEmpty = function () {
	                return { __proto__: null };
	            };
	        } else {
	            // In old IE __proto__ can't be used to manually set `null`, nor does
	            // any other method exist to make an object that inherits from nothing,
	            // aside from Object.prototype itself. Instead, create a new global
	            // object and *steal* its Object.prototype and strip it bare. This is
	            // used as the prototype to create nullary objects.
	            createEmpty = function () {
	                // Determine which approach to use
	                // see https://github.com/es-shims/es5-shim/issues/150
	                var empty = shouldUseActiveX() ? getEmptyViaActiveX() : getEmptyViaIFrame();

	                delete empty.constructor;
	                delete empty.hasOwnProperty;
	                delete empty.propertyIsEnumerable;
	                delete empty.isPrototypeOf;
	                delete empty.toLocaleString;
	                delete empty.toString;
	                delete empty.valueOf;

	                var Empty = function Empty() {};
	                Empty.prototype = empty;
	                // short-circuit future calls
	                createEmpty = function () {
	                    return new Empty();
	                };
	                return new Empty();
	            };
	        }

	        Object.create = function create(prototype, properties) {

	            var object;
	            var Type = function Type() {}; // An empty constructor.

	            if (prototype === null) {
	                object = createEmpty();
	            } else {
	                if (prototype !== null && isPrimitive(prototype)) {
	                    // In the native implementation `parent` can be `null`
	                    // OR *any* `instanceof Object`  (Object|Function|Array|RegExp|etc)
	                    // Use `typeof` tho, b/c in old IE, DOM elements are not `instanceof Object`
	                    // like they are in modern browsers. Using `Object.create` on DOM elements
	                    // is...err...probably inappropriate, but the native version allows for it.
	                    throw new TypeError('Object prototype may only be an Object or null'); // same msg as Chrome
	                }
	                Type.prototype = prototype;
	                object = new Type();
	                // IE has no built-in implementation of `Object.getPrototypeOf`
	                // neither `__proto__`, but this manually setting `__proto__` will
	                // guarantee that `Object.getPrototypeOf` will work as expected with
	                // objects created using `Object.create`
	                /* eslint-disable no-proto */
	                object.__proto__ = prototype;
	                /* eslint-enable no-proto */
	            }

	            if (properties !== void 0) {
	                Object.defineProperties(object, properties);
	            }

	            return object;
	        };
	    }

	    // ES5 15.2.3.6
	    // http://es5.github.com/#x15.2.3.6

	    // Patch for WebKit and IE8 standard mode
	    // Designed by hax <hax.github.com>
	    // related issue: https://github.com/es-shims/es5-shim/issues#issue/5
	    // IE8 Reference:
	    //     http://msdn.microsoft.com/en-us/library/dd282900.aspx
	    //     http://msdn.microsoft.com/en-us/library/dd229916.aspx
	    // WebKit Bugs:
	    //     https://bugs.webkit.org/show_bug.cgi?id=36423

	    var doesDefinePropertyWork = function doesDefinePropertyWork(object) {
	        try {
	            Object.defineProperty(object, 'sentinel', {});
	            return 'sentinel' in object;
	        } catch (exception) {
	            return false;
	        }
	    };

	    // check whether defineProperty works if it's given. Otherwise,
	    // shim partially.
	    if (Object.defineProperty) {
	        var definePropertyWorksOnObject = doesDefinePropertyWork({});
	        var definePropertyWorksOnDom = typeof document === 'undefined' ||
	            doesDefinePropertyWork(document.createElement('div'));
	        if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
	            var definePropertyFallback = Object.defineProperty,
	                definePropertiesFallback = Object.defineProperties;
	        }
	    }

	    if (!Object.defineProperty || definePropertyFallback) {
	        var ERR_NON_OBJECT_DESCRIPTOR = 'Property description must be an object: ';
	        var ERR_NON_OBJECT_TARGET = 'Object.defineProperty called on non-object: ';
	        var ERR_ACCESSORS_NOT_SUPPORTED = 'getters & setters can not be defined on this javascript engine';

	        Object.defineProperty = function defineProperty(object, property, descriptor) {
	            if (isPrimitive(object)) {
	                throw new TypeError(ERR_NON_OBJECT_TARGET + object);
	            }
	            if (isPrimitive(descriptor)) {
	                throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
	            }
	            // make a valiant attempt to use the real defineProperty
	            // for I8's DOM elements.
	            if (definePropertyFallback) {
	                try {
	                    return definePropertyFallback.call(Object, object, property, descriptor);
	                } catch (exception) {
	                    // try the shim if the real one doesn't work
	                }
	            }

	            // If it's a data property.
	            if ('value' in descriptor) {
	                // fail silently if 'writable', 'enumerable', or 'configurable'
	                // are requested but not supported
	                /*
	                // alternate approach:
	                if ( // can't implement these features; allow false but not true
	                    ('writable' in descriptor && !descriptor.writable) ||
	                    ('enumerable' in descriptor && !descriptor.enumerable) ||
	                    ('configurable' in descriptor && !descriptor.configurable)
	                ))
	                    throw new RangeError(
	                        'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
	                    );
	                */

	                if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
	                    // As accessors are supported only on engines implementing
	                    // `__proto__` we can safely override `__proto__` while defining
	                    // a property to make sure that we don't hit an inherited
	                    // accessor.
	                    /* eslint-disable no-proto */
	                    var prototype = object.__proto__;
	                    object.__proto__ = prototypeOfObject;
	                    // Deleting a property anyway since getter / setter may be
	                    // defined on object itself.
	                    delete object[property];
	                    object[property] = descriptor.value;
	                    // Setting original `__proto__` back now.
	                    object.__proto__ = prototype;
	                    /* eslint-enable no-proto */
	                } else {
	                    object[property] = descriptor.value;
	                }
	            } else {
	                var hasGetter = 'get' in descriptor;
	                var hasSetter = 'set' in descriptor;
	                if (!supportsAccessors && (hasGetter || hasSetter)) {
	                    throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
	                }
	                // If we got that far then getters and setters can be defined !!
	                if (hasGetter) {
	                    defineGetter(object, property, descriptor.get);
	                }
	                if (hasSetter) {
	                    defineSetter(object, property, descriptor.set);
	                }
	            }
	            return object;
	        };
	    }

	    // ES5 15.2.3.7
	    // http://es5.github.com/#x15.2.3.7
	    if (!Object.defineProperties || definePropertiesFallback) {
	        Object.defineProperties = function defineProperties(object, properties) {
	            // make a valiant attempt to use the real defineProperties
	            if (definePropertiesFallback) {
	                try {
	                    return definePropertiesFallback.call(Object, object, properties);
	                } catch (exception) {
	                    // try the shim if the real one doesn't work
	                }
	            }

	            Object.keys(properties).forEach(function (property) {
	                if (property !== '__proto__') {
	                    Object.defineProperty(object, property, properties[property]);
	                }
	            });
	            return object;
	        };
	    }

	    // ES5 15.2.3.8
	    // http://es5.github.com/#x15.2.3.8
	    if (!Object.seal) {
	        Object.seal = function seal(object) {
	            if (Object(object) !== object) {
	                throw new TypeError('Object.seal can only be called on Objects.');
	            }
	            // this is misleading and breaks feature-detection, but
	            // allows "securable" code to "gracefully" degrade to working
	            // but insecure code.
	            return object;
	        };
	    }

	    // ES5 15.2.3.9
	    // http://es5.github.com/#x15.2.3.9
	    if (!Object.freeze) {
	        Object.freeze = function freeze(object) {
	            if (Object(object) !== object) {
	                throw new TypeError('Object.freeze can only be called on Objects.');
	            }
	            // this is misleading and breaks feature-detection, but
	            // allows "securable" code to "gracefully" degrade to working
	            // but insecure code.
	            return object;
	        };
	    }

	    // detect a Rhino bug and patch it
	    try {
	        Object.freeze(function () {});
	    } catch (exception) {
	        Object.freeze = (function (freezeObject) {
	            return function freeze(object) {
	                if (typeof object === 'function') {
	                    return object;
	                } else {
	                    return freezeObject(object);
	                }
	            };
	        }(Object.freeze));
	    }

	    // ES5 15.2.3.10
	    // http://es5.github.com/#x15.2.3.10
	    if (!Object.preventExtensions) {
	        Object.preventExtensions = function preventExtensions(object) {
	            if (Object(object) !== object) {
	                throw new TypeError('Object.preventExtensions can only be called on Objects.');
	            }
	            // this is misleading and breaks feature-detection, but
	            // allows "securable" code to "gracefully" degrade to working
	            // but insecure code.
	            return object;
	        };
	    }

	    // ES5 15.2.3.11
	    // http://es5.github.com/#x15.2.3.11
	    if (!Object.isSealed) {
	        Object.isSealed = function isSealed(object) {
	            if (Object(object) !== object) {
	                throw new TypeError('Object.isSealed can only be called on Objects.');
	            }
	            return false;
	        };
	    }

	    // ES5 15.2.3.12
	    // http://es5.github.com/#x15.2.3.12
	    if (!Object.isFrozen) {
	        Object.isFrozen = function isFrozen(object) {
	            if (Object(object) !== object) {
	                throw new TypeError('Object.isFrozen can only be called on Objects.');
	            }
	            return false;
	        };
	    }

	    // ES5 15.2.3.13
	    // http://es5.github.com/#x15.2.3.13
	    if (!Object.isExtensible) {
	        Object.isExtensible = function isExtensible(object) {
	            // 1. If Type(O) is not Object throw a TypeError exception.
	            if (Object(object) !== object) {
	                throw new TypeError('Object.isExtensible can only be called on Objects.');
	            }
	            // 2. Return the Boolean value of the [[Extensible]] internal property of O.
	            var name = '';
	            while (owns(object, name)) {
	                name += '?';
	            }
	            object[name] = true;
	            var returnValue = owns(object, name);
	            delete object[name];
	            return returnValue;
	        };
	    }

	}));


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * https://github.com/es-shims/es5-shim
	 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
	 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
	 */

	// vim: ts=4 sts=4 sw=4 expandtab

	// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
	;

	// UMD (Universal Module Definition)
	// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
	(function (root, factory) {
	    'use strict';

	    /* global define, exports, module */
	    if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        // Node. Does not work with strict CommonJS, but
	        // only CommonJS-like enviroments that support module.exports,
	        // like Node.
	        module.exports = factory();
	    } else {
	        // Browser globals (root is window)
	        root.returnExports = factory();
	    }
	}(this, function () {
	    /**
	     * Brings an environment as close to ECMAScript 5 compliance
	     * as is possible with the facilities of erstwhile engines.
	     *
	     * Annotated ES5: http://es5.github.com/ (specific links below)
	     * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
	     * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
	     */

	    // Shortcut to an often accessed properties, in order to avoid multiple
	    // dereference that costs universally. This also holds a reference to known-good
	    // functions.
	    var $Array = Array;
	    var ArrayPrototype = $Array.prototype;
	    var $Object = Object;
	    var ObjectPrototype = $Object.prototype;
	    var $Function = Function;
	    var FunctionPrototype = $Function.prototype;
	    var $String = String;
	    var StringPrototype = $String.prototype;
	    var $Number = Number;
	    var NumberPrototype = $Number.prototype;
	    var array_slice = ArrayPrototype.slice;
	    var array_splice = ArrayPrototype.splice;
	    var array_push = ArrayPrototype.push;
	    var array_unshift = ArrayPrototype.unshift;
	    var array_concat = ArrayPrototype.concat;
	    var array_join = ArrayPrototype.join;
	    var call = FunctionPrototype.call;
	    var apply = FunctionPrototype.apply;
	    var max = Math.max;
	    var min = Math.min;

	    // Having a toString local variable name breaks in Opera so use to_string.
	    var to_string = ObjectPrototype.toString;

	    /* global Symbol */
	    /* eslint-disable one-var-declaration-per-line, no-redeclare, max-statements-per-line */
	    var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
	    var isCallable; /* inlined from https://npmjs.com/is-callable */ var fnToStr = Function.prototype.toString, constructorRegex = /^\s*class /, isES6ClassFn = function isES6ClassFn(value) { try { var fnStr = fnToStr.call(value); var singleStripped = fnStr.replace(/\/\/.*\n/g, ''); var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, ''); var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' '); return constructorRegex.test(spaceStripped); } catch (e) { return false; /* not a function */ } }, tryFunctionObject = function tryFunctionObject(value) { try { if (isES6ClassFn(value)) { return false; } fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]', isCallable = function isCallable(value) { if (!value) { return false; } if (typeof value !== 'function' && typeof value !== 'object') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } if (isES6ClassFn(value)) { return false; } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };

	    var isRegex; /* inlined from https://npmjs.com/is-regex */ var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
	    var isString; /* inlined from https://npmjs.com/is-string */ var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };
	    /* eslint-enable one-var-declaration-per-line, no-redeclare, max-statements-per-line */

	    /* inlined from http://npmjs.com/define-properties */
	    var supportsDescriptors = $Object.defineProperty && (function () {
	        try {
	            var obj = {};
	            $Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
	            for (var _ in obj) { // jscs:ignore disallowUnusedVariables
	                return false;
	            }
	            return obj.x === obj;
	        } catch (e) { /* this is ES3 */
	            return false;
	        }
	    }());
	    var defineProperties = (function (has) {
	        // Define configurable, writable, and non-enumerable props
	        // if they don't exist.
	        var defineProperty;
	        if (supportsDescriptors) {
	            defineProperty = function (object, name, method, forceAssign) {
	                if (!forceAssign && (name in object)) {
	                    return;
	                }
	                $Object.defineProperty(object, name, {
	                    configurable: true,
	                    enumerable: false,
	                    writable: true,
	                    value: method
	                });
	            };
	        } else {
	            defineProperty = function (object, name, method, forceAssign) {
	                if (!forceAssign && (name in object)) {
	                    return;
	                }
	                object[name] = method;
	            };
	        }
	        return function defineProperties(object, map, forceAssign) {
	            for (var name in map) {
	                if (has.call(map, name)) {
	                    defineProperty(object, name, map[name], forceAssign);
	                }
	            }
	        };
	    }(ObjectPrototype.hasOwnProperty));

	    //
	    // Util
	    // ======
	    //

	    /* replaceable with https://npmjs.com/package/es-abstract /helpers/isPrimitive */
	    var isPrimitive = function isPrimitive(input) {
	        var type = typeof input;
	        return input === null || (type !== 'object' && type !== 'function');
	    };

	    var isActualNaN = $Number.isNaN || function isActualNaN(x) {
	        return x !== x;
	    };

	    var ES = {
	        // ES5 9.4
	        // http://es5.github.com/#x9.4
	        // http://jsperf.com/to-integer
	        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToInteger */
	        ToInteger: function ToInteger(num) {
	            var n = +num;
	            if (isActualNaN(n)) {
	                n = 0;
	            } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
	                n = (n > 0 || -1) * Math.floor(Math.abs(n));
	            }
	            return n;
	        },

	        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToPrimitive */
	        ToPrimitive: function ToPrimitive(input) {
	            var val, valueOf, toStr;
	            if (isPrimitive(input)) {
	                return input;
	            }
	            valueOf = input.valueOf;
	            if (isCallable(valueOf)) {
	                val = valueOf.call(input);
	                if (isPrimitive(val)) {
	                    return val;
	                }
	            }
	            toStr = input.toString;
	            if (isCallable(toStr)) {
	                val = toStr.call(input);
	                if (isPrimitive(val)) {
	                    return val;
	                }
	            }
	            throw new TypeError();
	        },

	        // ES5 9.9
	        // http://es5.github.com/#x9.9
	        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToObject */
	        ToObject: function (o) {
	            if (o == null) { // this matches both null and undefined
	                throw new TypeError("can't convert " + o + ' to object');
	            }
	            return $Object(o);
	        },

	        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToUint32 */
	        ToUint32: function ToUint32(x) {
	            return x >>> 0;
	        }
	    };

	    //
	    // Function
	    // ========
	    //

	    // ES-5 15.3.4.5
	    // http://es5.github.com/#x15.3.4.5

	    var Empty = function Empty() {};

	    defineProperties(FunctionPrototype, {
	        bind: function bind(that) { // .length is 1
	            // 1. Let Target be the this value.
	            var target = this;
	            // 2. If IsCallable(Target) is false, throw a TypeError exception.
	            if (!isCallable(target)) {
	                throw new TypeError('Function.prototype.bind called on incompatible ' + target);
	            }
	            // 3. Let A be a new (possibly empty) internal list of all of the
	            //   argument values provided after thisArg (arg1, arg2 etc), in order.
	            // XXX slicedArgs will stand in for "A" if used
	            var args = array_slice.call(arguments, 1); // for normal call
	            // 4. Let F be a new native ECMAScript object.
	            // 11. Set the [[Prototype]] internal property of F to the standard
	            //   built-in Function prototype object as specified in 15.3.3.1.
	            // 12. Set the [[Call]] internal property of F as described in
	            //   15.3.4.5.1.
	            // 13. Set the [[Construct]] internal property of F as described in
	            //   15.3.4.5.2.
	            // 14. Set the [[HasInstance]] internal property of F as described in
	            //   15.3.4.5.3.
	            var bound;
	            var binder = function () {

	                if (this instanceof bound) {
	                    // 15.3.4.5.2 [[Construct]]
	                    // When the [[Construct]] internal method of a function object,
	                    // F that was created using the bind function is called with a
	                    // list of arguments ExtraArgs, the following steps are taken:
	                    // 1. Let target be the value of F's [[TargetFunction]]
	                    //   internal property.
	                    // 2. If target has no [[Construct]] internal method, a
	                    //   TypeError exception is thrown.
	                    // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
	                    //   property.
	                    // 4. Let args be a new list containing the same values as the
	                    //   list boundArgs in the same order followed by the same
	                    //   values as the list ExtraArgs in the same order.
	                    // 5. Return the result of calling the [[Construct]] internal
	                    //   method of target providing args as the arguments.

	                    var result = apply.call(
	                        target,
	                        this,
	                        array_concat.call(args, array_slice.call(arguments))
	                    );
	                    if ($Object(result) === result) {
	                        return result;
	                    }
	                    return this;

	                } else {
	                    // 15.3.4.5.1 [[Call]]
	                    // When the [[Call]] internal method of a function object, F,
	                    // which was created using the bind function is called with a
	                    // this value and a list of arguments ExtraArgs, the following
	                    // steps are taken:
	                    // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
	                    //   property.
	                    // 2. Let boundThis be the value of F's [[BoundThis]] internal
	                    //   property.
	                    // 3. Let target be the value of F's [[TargetFunction]] internal
	                    //   property.
	                    // 4. Let args be a new list containing the same values as the
	                    //   list boundArgs in the same order followed by the same
	                    //   values as the list ExtraArgs in the same order.
	                    // 5. Return the result of calling the [[Call]] internal method
	                    //   of target providing boundThis as the this value and
	                    //   providing args as the arguments.

	                    // equiv: target.call(this, ...boundArgs, ...args)
	                    return apply.call(
	                        target,
	                        that,
	                        array_concat.call(args, array_slice.call(arguments))
	                    );

	                }

	            };

	            // 15. If the [[Class]] internal property of Target is "Function", then
	            //     a. Let L be the length property of Target minus the length of A.
	            //     b. Set the length own property of F to either 0 or L, whichever is
	            //       larger.
	            // 16. Else set the length own property of F to 0.

	            var boundLength = max(0, target.length - args.length);

	            // 17. Set the attributes of the length own property of F to the values
	            //   specified in 15.3.5.1.
	            var boundArgs = [];
	            for (var i = 0; i < boundLength; i++) {
	                array_push.call(boundArgs, '$' + i);
	            }

	            // XXX Build a dynamic function with desired amount of arguments is the only
	            // way to set the length property of a function.
	            // In environments where Content Security Policies enabled (Chrome extensions,
	            // for ex.) all use of eval or Function costructor throws an exception.
	            // However in all of these environments Function.prototype.bind exists
	            // and so this code will never be executed.
	            bound = $Function('binder', 'return function (' + array_join.call(boundArgs, ',') + '){ return binder.apply(this, arguments); }')(binder);

	            if (target.prototype) {
	                Empty.prototype = target.prototype;
	                bound.prototype = new Empty();
	                // Clean up dangling references.
	                Empty.prototype = null;
	            }

	            // TODO
	            // 18. Set the [[Extensible]] internal property of F to true.

	            // TODO
	            // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
	            // 20. Call the [[DefineOwnProperty]] internal method of F with
	            //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
	            //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
	            //   false.
	            // 21. Call the [[DefineOwnProperty]] internal method of F with
	            //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
	            //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
	            //   and false.

	            // TODO
	            // NOTE Function objects created using Function.prototype.bind do not
	            // have a prototype property or the [[Code]], [[FormalParameters]], and
	            // [[Scope]] internal properties.
	            // XXX can't delete prototype in pure-js.

	            // 22. Return F.
	            return bound;
	        }
	    });

	    // _Please note: Shortcuts are defined after `Function.prototype.bind` as we
	    // use it in defining shortcuts.
	    var owns = call.bind(ObjectPrototype.hasOwnProperty);
	    var toStr = call.bind(ObjectPrototype.toString);
	    var arraySlice = call.bind(array_slice);
	    var arraySliceApply = apply.bind(array_slice);
	    var strSlice = call.bind(StringPrototype.slice);
	    var strSplit = call.bind(StringPrototype.split);
	    var strIndexOf = call.bind(StringPrototype.indexOf);
	    var pushCall = call.bind(array_push);
	    var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
	    var arraySort = call.bind(ArrayPrototype.sort);

	    //
	    // Array
	    // =====
	    //

	    var isArray = $Array.isArray || function isArray(obj) {
	        return toStr(obj) === '[object Array]';
	    };

	    // ES5 15.4.4.12
	    // http://es5.github.com/#x15.4.4.13
	    // Return len+argCount.
	    // [bugfix, ielt8]
	    // IE < 8 bug: [].unshift(0) === undefined but should be "1"
	    var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
	    defineProperties(ArrayPrototype, {
	        unshift: function () {
	            array_unshift.apply(this, arguments);
	            return this.length;
	        }
	    }, hasUnshiftReturnValueBug);

	    // ES5 15.4.3.2
	    // http://es5.github.com/#x15.4.3.2
	    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
	    defineProperties($Array, { isArray: isArray });

	    // The IsCallable() check in the Array functions
	    // has been replaced with a strict check on the
	    // internal class of the object to trap cases where
	    // the provided function was actually a regular
	    // expression literal, which in V8 and
	    // JavaScriptCore is a typeof "function".  Only in
	    // V8 are regular expression literals permitted as
	    // reduce parameters, so it is desirable in the
	    // general case for the shim to match the more
	    // strict and common behavior of rejecting regular
	    // expressions.

	    // ES5 15.4.4.18
	    // http://es5.github.com/#x15.4.4.18
	    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach

	    // Check failure of by-index access of string characters (IE < 9)
	    // and failure of `0 in boxedString` (Rhino)
	    var boxedString = $Object('a');
	    var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

	    var properlyBoxesContext = function properlyBoxed(method) {
	        // Check node 0.6.21 bug where third parameter is not boxed
	        var properlyBoxesNonStrict = true;
	        var properlyBoxesStrict = true;
	        var threwException = false;
	        if (method) {
	            try {
	                method.call('foo', function (_, __, context) {
	                    if (typeof context !== 'object') {
	                        properlyBoxesNonStrict = false;
	                    }
	                });

	                method.call([1], function () {
	                    'use strict';

	                    properlyBoxesStrict = typeof this === 'string';
	                }, 'x');
	            } catch (e) {
	                threwException = true;
	            }
	        }
	        return !!method && !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
	    };

	    defineProperties(ArrayPrototype, {
	        forEach: function forEach(callbackfn/*, thisArg*/) {
	            var object = ES.ToObject(this);
	            var self = splitString && isString(this) ? strSplit(this, '') : object;
	            var i = -1;
	            var length = ES.ToUint32(self.length);
	            var T;
	            if (arguments.length > 1) {
	                T = arguments[1];
	            }

	            // If no callback function or if callback is not a callable function
	            if (!isCallable(callbackfn)) {
	                throw new TypeError('Array.prototype.forEach callback must be a function');
	            }

	            while (++i < length) {
	                if (i in self) {
	                    // Invoke the callback function with call, passing arguments:
	                    // context, property value, property key, thisArg object
	                    if (typeof T === 'undefined') {
	                        callbackfn(self[i], i, object);
	                    } else {
	                        callbackfn.call(T, self[i], i, object);
	                    }
	                }
	            }
	        }
	    }, !properlyBoxesContext(ArrayPrototype.forEach));

	    // ES5 15.4.4.19
	    // http://es5.github.com/#x15.4.4.19
	    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
	    defineProperties(ArrayPrototype, {
	        map: function map(callbackfn/*, thisArg*/) {
	            var object = ES.ToObject(this);
	            var self = splitString && isString(this) ? strSplit(this, '') : object;
	            var length = ES.ToUint32(self.length);
	            var result = $Array(length);
	            var T;
	            if (arguments.length > 1) {
	                T = arguments[1];
	            }

	            // If no callback function or if callback is not a callable function
	            if (!isCallable(callbackfn)) {
	                throw new TypeError('Array.prototype.map callback must be a function');
	            }

	            for (var i = 0; i < length; i++) {
	                if (i in self) {
	                    if (typeof T === 'undefined') {
	                        result[i] = callbackfn(self[i], i, object);
	                    } else {
	                        result[i] = callbackfn.call(T, self[i], i, object);
	                    }
	                }
	            }
	            return result;
	        }
	    }, !properlyBoxesContext(ArrayPrototype.map));

	    // ES5 15.4.4.20
	    // http://es5.github.com/#x15.4.4.20
	    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
	    defineProperties(ArrayPrototype, {
	        filter: function filter(callbackfn/*, thisArg*/) {
	            var object = ES.ToObject(this);
	            var self = splitString && isString(this) ? strSplit(this, '') : object;
	            var length = ES.ToUint32(self.length);
	            var result = [];
	            var value;
	            var T;
	            if (arguments.length > 1) {
	                T = arguments[1];
	            }

	            // If no callback function or if callback is not a callable function
	            if (!isCallable(callbackfn)) {
	                throw new TypeError('Array.prototype.filter callback must be a function');
	            }

	            for (var i = 0; i < length; i++) {
	                if (i in self) {
	                    value = self[i];
	                    if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
	                        pushCall(result, value);
	                    }
	                }
	            }
	            return result;
	        }
	    }, !properlyBoxesContext(ArrayPrototype.filter));

	    // ES5 15.4.4.16
	    // http://es5.github.com/#x15.4.4.16
	    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
	    defineProperties(ArrayPrototype, {
	        every: function every(callbackfn/*, thisArg*/) {
	            var object = ES.ToObject(this);
	            var self = splitString && isString(this) ? strSplit(this, '') : object;
	            var length = ES.ToUint32(self.length);
	            var T;
	            if (arguments.length > 1) {
	                T = arguments[1];
	            }

	            // If no callback function or if callback is not a callable function
	            if (!isCallable(callbackfn)) {
	                throw new TypeError('Array.prototype.every callback must be a function');
	            }

	            for (var i = 0; i < length; i++) {
	                if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }, !properlyBoxesContext(ArrayPrototype.every));

	    // ES5 15.4.4.17
	    // http://es5.github.com/#x15.4.4.17
	    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
	    defineProperties(ArrayPrototype, {
	        some: function some(callbackfn/*, thisArg */) {
	            var object = ES.ToObject(this);
	            var self = splitString && isString(this) ? strSplit(this, '') : object;
	            var length = ES.ToUint32(self.length);
	            var T;
	            if (arguments.length > 1) {
	                T = arguments[1];
	            }

	            // If no callback function or if callback is not a callable function
	            if (!isCallable(callbackfn)) {
	                throw new TypeError('Array.prototype.some callback must be a function');
	            }

	            for (var i = 0; i < length; i++) {
	                if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
	                    return true;
	                }
	            }
	            return false;
	        }
	    }, !properlyBoxesContext(ArrayPrototype.some));

	    // ES5 15.4.4.21
	    // http://es5.github.com/#x15.4.4.21
	    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
	    var reduceCoercesToObject = false;
	    if (ArrayPrototype.reduce) {
	        reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) {
	            return list;
	        }) === 'object';
	    }
	    defineProperties(ArrayPrototype, {
	        reduce: function reduce(callbackfn/*, initialValue*/) {
	            var object = ES.ToObject(this);
	            var self = splitString && isString(this) ? strSplit(this, '') : object;
	            var length = ES.ToUint32(self.length);

	            // If no callback function or if callback is not a callable function
	            if (!isCallable(callbackfn)) {
	                throw new TypeError('Array.prototype.reduce callback must be a function');
	            }

	            // no value to return if no initial value and an empty array
	            if (length === 0 && arguments.length === 1) {
	                throw new TypeError('reduce of empty array with no initial value');
	            }

	            var i = 0;
	            var result;
	            if (arguments.length >= 2) {
	                result = arguments[1];
	            } else {
	                do {
	                    if (i in self) {
	                        result = self[i++];
	                        break;
	                    }

	                    // if array contains no values, no initial value to return
	                    if (++i >= length) {
	                        throw new TypeError('reduce of empty array with no initial value');
	                    }
	                } while (true);
	            }

	            for (; i < length; i++) {
	                if (i in self) {
	                    result = callbackfn(result, self[i], i, object);
	                }
	            }

	            return result;
	        }
	    }, !reduceCoercesToObject);

	    // ES5 15.4.4.22
	    // http://es5.github.com/#x15.4.4.22
	    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
	    var reduceRightCoercesToObject = false;
	    if (ArrayPrototype.reduceRight) {
	        reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) {
	            return list;
	        }) === 'object';
	    }
	    defineProperties(ArrayPrototype, {
	        reduceRight: function reduceRight(callbackfn/*, initial*/) {
	            var object = ES.ToObject(this);
	            var self = splitString && isString(this) ? strSplit(this, '') : object;
	            var length = ES.ToUint32(self.length);

	            // If no callback function or if callback is not a callable function
	            if (!isCallable(callbackfn)) {
	                throw new TypeError('Array.prototype.reduceRight callback must be a function');
	            }

	            // no value to return if no initial value, empty array
	            if (length === 0 && arguments.length === 1) {
	                throw new TypeError('reduceRight of empty array with no initial value');
	            }

	            var result;
	            var i = length - 1;
	            if (arguments.length >= 2) {
	                result = arguments[1];
	            } else {
	                do {
	                    if (i in self) {
	                        result = self[i--];
	                        break;
	                    }

	                    // if array contains no values, no initial value to return
	                    if (--i < 0) {
	                        throw new TypeError('reduceRight of empty array with no initial value');
	                    }
	                } while (true);
	            }

	            if (i < 0) {
	                return result;
	            }

	            do {
	                if (i in self) {
	                    result = callbackfn(result, self[i], i, object);
	                }
	            } while (i--);

	            return result;
	        }
	    }, !reduceRightCoercesToObject);

	    // ES5 15.4.4.14
	    // http://es5.github.com/#x15.4.4.14
	    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
	    var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
	    defineProperties(ArrayPrototype, {
	        indexOf: function indexOf(searchElement/*, fromIndex */) {
	            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
	            var length = ES.ToUint32(self.length);

	            if (length === 0) {
	                return -1;
	            }

	            var i = 0;
	            if (arguments.length > 1) {
	                i = ES.ToInteger(arguments[1]);
	            }

	            // handle negative indices
	            i = i >= 0 ? i : max(0, length + i);
	            for (; i < length; i++) {
	                if (i in self && self[i] === searchElement) {
	                    return i;
	                }
	            }
	            return -1;
	        }
	    }, hasFirefox2IndexOfBug);

	    // ES5 15.4.4.15
	    // http://es5.github.com/#x15.4.4.15
	    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
	    var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
	    defineProperties(ArrayPrototype, {
	        lastIndexOf: function lastIndexOf(searchElement/*, fromIndex */) {
	            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
	            var length = ES.ToUint32(self.length);

	            if (length === 0) {
	                return -1;
	            }
	            var i = length - 1;
	            if (arguments.length > 1) {
	                i = min(i, ES.ToInteger(arguments[1]));
	            }
	            // handle negative indices
	            i = i >= 0 ? i : length - Math.abs(i);
	            for (; i >= 0; i--) {
	                if (i in self && searchElement === self[i]) {
	                    return i;
	                }
	            }
	            return -1;
	        }
	    }, hasFirefox2LastIndexOfBug);

	    // ES5 15.4.4.12
	    // http://es5.github.com/#x15.4.4.12
	    var spliceNoopReturnsEmptyArray = (function () {
	        var a = [1, 2];
	        var result = a.splice();
	        return a.length === 2 && isArray(result) && result.length === 0;
	    }());
	    defineProperties(ArrayPrototype, {
	        // Safari 5.0 bug where .splice() returns undefined
	        splice: function splice(start, deleteCount) {
	            if (arguments.length === 0) {
	                return [];
	            } else {
	                return array_splice.apply(this, arguments);
	            }
	        }
	    }, !spliceNoopReturnsEmptyArray);

	    var spliceWorksWithEmptyObject = (function () {
	        var obj = {};
	        ArrayPrototype.splice.call(obj, 0, 0, 1);
	        return obj.length === 1;
	    }());
	    defineProperties(ArrayPrototype, {
	        splice: function splice(start, deleteCount) {
	            if (arguments.length === 0) {
	                return [];
	            }
	            var args = arguments;
	            this.length = max(ES.ToInteger(this.length), 0);
	            if (arguments.length > 0 && typeof deleteCount !== 'number') {
	                args = arraySlice(arguments);
	                if (args.length < 2) {
	                    pushCall(args, this.length - start);
	                } else {
	                    args[1] = ES.ToInteger(deleteCount);
	                }
	            }
	            return array_splice.apply(this, args);
	        }
	    }, !spliceWorksWithEmptyObject);
	    var spliceWorksWithLargeSparseArrays = (function () {
	        // Per https://github.com/es-shims/es5-shim/issues/295
	        // Safari 7/8 breaks with sparse arrays of size 1e5 or greater
	        var arr = new $Array(1e5);
	        // note: the index MUST be 8 or larger or the test will false pass
	        arr[8] = 'x';
	        arr.splice(1, 1);
	        // note: this test must be defined *after* the indexOf shim
	        // per https://github.com/es-shims/es5-shim/issues/313
	        return arr.indexOf('x') === 7;
	    }());
	    var spliceWorksWithSmallSparseArrays = (function () {
	        // Per https://github.com/es-shims/es5-shim/issues/295
	        // Opera 12.15 breaks on this, no idea why.
	        var n = 256;
	        var arr = [];
	        arr[n] = 'a';
	        arr.splice(n + 1, 0, 'b');
	        return arr[n] === 'a';
	    }());
	    defineProperties(ArrayPrototype, {
	        splice: function splice(start, deleteCount) {
	            var O = ES.ToObject(this);
	            var A = [];
	            var len = ES.ToUint32(O.length);
	            var relativeStart = ES.ToInteger(start);
	            var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
	            var actualDeleteCount = min(max(ES.ToInteger(deleteCount), 0), len - actualStart);

	            var k = 0;
	            var from;
	            while (k < actualDeleteCount) {
	                from = $String(actualStart + k);
	                if (owns(O, from)) {
	                    A[k] = O[from];
	                }
	                k += 1;
	            }

	            var items = arraySlice(arguments, 2);
	            var itemCount = items.length;
	            var to;
	            if (itemCount < actualDeleteCount) {
	                k = actualStart;
	                var maxK = len - actualDeleteCount;
	                while (k < maxK) {
	                    from = $String(k + actualDeleteCount);
	                    to = $String(k + itemCount);
	                    if (owns(O, from)) {
	                        O[to] = O[from];
	                    } else {
	                        delete O[to];
	                    }
	                    k += 1;
	                }
	                k = len;
	                var minK = len - actualDeleteCount + itemCount;
	                while (k > minK) {
	                    delete O[k - 1];
	                    k -= 1;
	                }
	            } else if (itemCount > actualDeleteCount) {
	                k = len - actualDeleteCount;
	                while (k > actualStart) {
	                    from = $String(k + actualDeleteCount - 1);
	                    to = $String(k + itemCount - 1);
	                    if (owns(O, from)) {
	                        O[to] = O[from];
	                    } else {
	                        delete O[to];
	                    }
	                    k -= 1;
	                }
	            }
	            k = actualStart;
	            for (var i = 0; i < items.length; ++i) {
	                O[k] = items[i];
	                k += 1;
	            }
	            O.length = len - actualDeleteCount + itemCount;

	            return A;
	        }
	    }, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);

	    var originalJoin = ArrayPrototype.join;
	    var hasStringJoinBug;
	    try {
	        hasStringJoinBug = Array.prototype.join.call('123', ',') !== '1,2,3';
	    } catch (e) {
	        hasStringJoinBug = true;
	    }
	    if (hasStringJoinBug) {
	        defineProperties(ArrayPrototype, {
	            join: function join(separator) {
	                var sep = typeof separator === 'undefined' ? ',' : separator;
	                return originalJoin.call(isString(this) ? strSplit(this, '') : this, sep);
	            }
	        }, hasStringJoinBug);
	    }

	    var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
	    if (hasJoinUndefinedBug) {
	        defineProperties(ArrayPrototype, {
	            join: function join(separator) {
	                var sep = typeof separator === 'undefined' ? ',' : separator;
	                return originalJoin.call(this, sep);
	            }
	        }, hasJoinUndefinedBug);
	    }

	    var pushShim = function push(item) {
	        var O = ES.ToObject(this);
	        var n = ES.ToUint32(O.length);
	        var i = 0;
	        while (i < arguments.length) {
	            O[n + i] = arguments[i];
	            i += 1;
	        }
	        O.length = n + i;
	        return n + i;
	    };

	    var pushIsNotGeneric = (function () {
	        var obj = {};
	        var result = Array.prototype.push.call(obj, undefined);
	        return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
	    }());
	    defineProperties(ArrayPrototype, {
	        push: function push(item) {
	            if (isArray(this)) {
	                return array_push.apply(this, arguments);
	            }
	            return pushShim.apply(this, arguments);
	        }
	    }, pushIsNotGeneric);

	    // This fixes a very weird bug in Opera 10.6 when pushing `undefined
	    var pushUndefinedIsWeird = (function () {
	        var arr = [];
	        var result = arr.push(undefined);
	        return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
	    }());
	    defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);

	    // ES5 15.2.3.14
	    // http://es5.github.io/#x15.4.4.10
	    // Fix boxed string bug
	    defineProperties(ArrayPrototype, {
	        slice: function (start, end) {
	            var arr = isString(this) ? strSplit(this, '') : this;
	            return arraySliceApply(arr, arguments);
	        }
	    }, splitString);

	    var sortIgnoresNonFunctions = (function () {
	        try {
	            [1, 2].sort(null);
	            [1, 2].sort({});
	            return true;
	        } catch (e) {}
	        return false;
	    }());
	    var sortThrowsOnRegex = (function () {
	        // this is a problem in Firefox 4, in which `typeof /a/ === 'function'`
	        try {
	            [1, 2].sort(/a/);
	            return false;
	        } catch (e) {}
	        return true;
	    }());
	    var sortIgnoresUndefined = (function () {
	        // applies in IE 8, for one.
	        try {
	            [1, 2].sort(undefined);
	            return true;
	        } catch (e) {}
	        return false;
	    }());
	    defineProperties(ArrayPrototype, {
	        sort: function sort(compareFn) {
	            if (typeof compareFn === 'undefined') {
	                return arraySort(this);
	            }
	            if (!isCallable(compareFn)) {
	                throw new TypeError('Array.prototype.sort callback must be a function');
	            }
	            return arraySort(this, compareFn);
	        }
	    }, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);

	    //
	    // Object
	    // ======
	    //

	    // ES5 15.2.3.14
	    // http://es5.github.com/#x15.2.3.14

	    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
	    var hasDontEnumBug = !isEnum({ 'toString': null }, 'toString');
	    var hasProtoEnumBug = isEnum(function () {}, 'prototype');
	    var hasStringEnumBug = !owns('x', '0');
	    var equalsConstructorPrototype = function (o) {
	        var ctor = o.constructor;
	        return ctor && ctor.prototype === o;
	    };
	    var blacklistedKeys = {
	        $window: true,
	        $console: true,
	        $parent: true,
	        $self: true,
	        $frame: true,
	        $frames: true,
	        $frameElement: true,
	        $webkitIndexedDB: true,
	        $webkitStorageInfo: true,
	        $external: true
	    };
	    var hasAutomationEqualityBug = (function () {
	        /* globals window */
	        if (typeof window === 'undefined') {
	            return false;
	        }
	        for (var k in window) {
	            try {
	                if (!blacklistedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
	                    equalsConstructorPrototype(window[k]);
	                }
	            } catch (e) {
	                return true;
	            }
	        }
	        return false;
	    }());
	    var equalsConstructorPrototypeIfNotBuggy = function (object) {
	        if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
	            return equalsConstructorPrototype(object);
	        }
	        try {
	            return equalsConstructorPrototype(object);
	        } catch (e) {
	            return false;
	        }
	    };
	    var dontEnums = [
	        'toString',
	        'toLocaleString',
	        'valueOf',
	        'hasOwnProperty',
	        'isPrototypeOf',
	        'propertyIsEnumerable',
	        'constructor'
	    ];
	    var dontEnumsLength = dontEnums.length;

	    // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
	    // can be replaced with require('is-arguments') if we ever use a build process instead
	    var isStandardArguments = function isArguments(value) {
	        return toStr(value) === '[object Arguments]';
	    };
	    var isLegacyArguments = function isArguments(value) {
	        return value !== null &&
	            typeof value === 'object' &&
	            typeof value.length === 'number' &&
	            value.length >= 0 &&
	            !isArray(value) &&
	            isCallable(value.callee);
	    };
	    var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

	    defineProperties($Object, {
	        keys: function keys(object) {
	            var isFn = isCallable(object);
	            var isArgs = isArguments(object);
	            var isObject = object !== null && typeof object === 'object';
	            var isStr = isObject && isString(object);

	            if (!isObject && !isFn && !isArgs) {
	                throw new TypeError('Object.keys called on a non-object');
	            }

	            var theKeys = [];
	            var skipProto = hasProtoEnumBug && isFn;
	            if ((isStr && hasStringEnumBug) || isArgs) {
	                for (var i = 0; i < object.length; ++i) {
	                    pushCall(theKeys, $String(i));
	                }
	            }

	            if (!isArgs) {
	                for (var name in object) {
	                    if (!(skipProto && name === 'prototype') && owns(object, name)) {
	                        pushCall(theKeys, $String(name));
	                    }
	                }
	            }

	            if (hasDontEnumBug) {
	                var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
	                for (var j = 0; j < dontEnumsLength; j++) {
	                    var dontEnum = dontEnums[j];
	                    if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
	                        pushCall(theKeys, dontEnum);
	                    }
	                }
	            }
	            return theKeys;
	        }
	    });

	    var keysWorksWithArguments = $Object.keys && (function () {
	        // Safari 5.0 bug
	        return $Object.keys(arguments).length === 2;
	    }(1, 2));
	    var keysHasArgumentsLengthBug = $Object.keys && (function () {
	        var argKeys = $Object.keys(arguments);
	        return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
	    }(1));
	    var originalKeys = $Object.keys;
	    defineProperties($Object, {
	        keys: function keys(object) {
	            if (isArguments(object)) {
	                return originalKeys(arraySlice(object));
	            } else {
	                return originalKeys(object);
	            }
	        }
	    }, !keysWorksWithArguments || keysHasArgumentsLengthBug);

	    //
	    // Date
	    // ====
	    //

	    var hasNegativeMonthYearBug = new Date(-3509827329600292).getUTCMonth() !== 0;
	    var aNegativeTestDate = new Date(-1509842289600292);
	    var aPositiveTestDate = new Date(1449662400000);
	    var hasToUTCStringFormatBug = aNegativeTestDate.toUTCString() !== 'Mon, 01 Jan -45875 11:59:59 GMT';
	    var hasToDateStringFormatBug;
	    var hasToStringFormatBug;
	    var timeZoneOffset = aNegativeTestDate.getTimezoneOffset();
	    if (timeZoneOffset < -720) {
	        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Tue Jan 02 -45875';
	        hasToStringFormatBug = !(/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
	    } else {
	        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Mon Jan 01 -45875';
	        hasToStringFormatBug = !(/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
	    }

	    var originalGetFullYear = call.bind(Date.prototype.getFullYear);
	    var originalGetMonth = call.bind(Date.prototype.getMonth);
	    var originalGetDate = call.bind(Date.prototype.getDate);
	    var originalGetUTCFullYear = call.bind(Date.prototype.getUTCFullYear);
	    var originalGetUTCMonth = call.bind(Date.prototype.getUTCMonth);
	    var originalGetUTCDate = call.bind(Date.prototype.getUTCDate);
	    var originalGetUTCDay = call.bind(Date.prototype.getUTCDay);
	    var originalGetUTCHours = call.bind(Date.prototype.getUTCHours);
	    var originalGetUTCMinutes = call.bind(Date.prototype.getUTCMinutes);
	    var originalGetUTCSeconds = call.bind(Date.prototype.getUTCSeconds);
	    var originalGetUTCMilliseconds = call.bind(Date.prototype.getUTCMilliseconds);
	    var dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	    var monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	    var daysInMonth = function daysInMonth(month, year) {
	        return originalGetDate(new Date(year, month, 0));
	    };

	    defineProperties(Date.prototype, {
	        getFullYear: function getFullYear() {
	            if (!this || !(this instanceof Date)) {
	                throw new TypeError('this is not a Date object.');
	            }
	            var year = originalGetFullYear(this);
	            if (year < 0 && originalGetMonth(this) > 11) {
	                return year + 1;
	            }
	            return year;
	        },
	        getMonth: function getMonth() {
	            if (!this || !(this instanceof Date)) {
	                throw new TypeError('this is not a Date object.');
	            }
	            var year = originalGetFullYear(this);
	            var month = originalGetMonth(this);
	            if (year < 0 && month > 11) {
	                return 0;
	            }
	            return month;
	        },
	        getDate: function getDate() {
	            if (!this || !(this instanceof Date)) {
	                throw new TypeError('this is not a Date object.');
	            }
	            var year = originalGetFullYear(this);
	            var month = originalGetMonth(this);
	            var date = originalGetDate(this);
	            if (year < 0 && month > 11) {
	                if (month === 12) {
	                    return date;
	                }
	                var days = daysInMonth(0, year + 1);
	                return (days - date) + 1;
	            }
	            return date;
	        },
	        getUTCFullYear: function getUTCFullYear() {
	            if (!this || !(this instanceof Date)) {
	                throw new TypeError('this is not a Date object.');
	            }
	            var year = originalGetUTCFullYear(this);
	            if (year < 0 && originalGetUTCMonth(this) > 11) {
	                return year + 1;
	            }
	            return year;
	        },
	        getUTCMonth: function getUTCMonth() {
	            if (!this || !(this instanceof Date)) {
	                throw new TypeError('this is not a Date object.');
	            }
	            var year = originalGetUTCFullYear(this);
	            var month = originalGetUTCMonth(this);
	            if (year < 0 && month > 11) {
	                return 0;
	            }
	            return month;
	        },
	        getUTCDate: function getUTCDate() {
	            if (!this || !(this instanceof Date)) {
	                throw new TypeError('this is not a Date object.');
	            }
	            var year = originalGetUTCFullYear(this);
	            var month = originalGetUTCMonth(this);
	            var date = originalGetUTCDate(this);
	            if (year < 0 && month > 11) {
	                if (month === 12) {
	                    return date;
	                }
	                var days = daysInMonth(0, year + 1);
	                return (days - date) + 1;
	            }
	            return date;
	        }
	    }, hasNegativeMonthYearBug);

	    defineProperties(Date.prototype, {
	        toUTCString: function toUTCString() {
	            if (!this || !(this instanceof Date)) {
	                throw new TypeError('this is not a Date object.');
	            }
	            var day = originalGetUTCDay(this);
	            var date = originalGetUTCDate(this);
	            var month = originalGetUTCMonth(this);
	            var year = originalGetUTCFullYear(this);
	            var hour = originalGetUTCHours(this);
	            var minute = originalGetUTCMinutes(this);
	            var second = originalGetUTCSeconds(this);
	            return dayName[day] + ', ' +
	                (date < 10 ? '0' + date : date) + ' ' +
	                monthName[month] + ' ' +
	                year + ' ' +
	                (hour < 10 ? '0' + hour : hour) + ':' +
	                (minute < 10 ? '0' + minute : minute) + ':' +
	                (second < 10 ? '0' + second : second) + ' GMT';
	        }
	    }, hasNegativeMonthYearBug || hasToUTCStringFormatBug);

	    // Opera 12 has `,`
	    defineProperties(Date.prototype, {
	        toDateString: function toDateString() {
	            if (!this || !(this instanceof Date)) {
	                throw new TypeError('this is not a Date object.');
	            }
	            var day = this.getDay();
	            var date = this.getDate();
	            var month = this.getMonth();
	            var year = this.getFullYear();
	            return dayName[day] + ' ' +
	                monthName[month] + ' ' +
	                (date < 10 ? '0' + date : date) + ' ' +
	                year;
	        }
	    }, hasNegativeMonthYearBug || hasToDateStringFormatBug);

	    // can't use defineProperties here because of toString enumeration issue in IE <= 8
	    if (hasNegativeMonthYearBug || hasToStringFormatBug) {
	        Date.prototype.toString = function toString() {
	            if (!this || !(this instanceof Date)) {
	                throw new TypeError('this is not a Date object.');
	            }
	            var day = this.getDay();
	            var date = this.getDate();
	            var month = this.getMonth();
	            var year = this.getFullYear();
	            var hour = this.getHours();
	            var minute = this.getMinutes();
	            var second = this.getSeconds();
	            var timezoneOffset = this.getTimezoneOffset();
	            var hoursOffset = Math.floor(Math.abs(timezoneOffset) / 60);
	            var minutesOffset = Math.floor(Math.abs(timezoneOffset) % 60);
	            return dayName[day] + ' ' +
	                monthName[month] + ' ' +
	                (date < 10 ? '0' + date : date) + ' ' +
	                year + ' ' +
	                (hour < 10 ? '0' + hour : hour) + ':' +
	                (minute < 10 ? '0' + minute : minute) + ':' +
	                (second < 10 ? '0' + second : second) + ' GMT' +
	                (timezoneOffset > 0 ? '-' : '+') +
	                (hoursOffset < 10 ? '0' + hoursOffset : hoursOffset) +
	                (minutesOffset < 10 ? '0' + minutesOffset : minutesOffset);
	        };
	        if (supportsDescriptors) {
	            $Object.defineProperty(Date.prototype, 'toString', {
	                configurable: true,
	                enumerable: false,
	                writable: true
	            });
	        }
	    }

	    // ES5 15.9.5.43
	    // http://es5.github.com/#x15.9.5.43
	    // This function returns a String value represent the instance in time
	    // represented by this Date object. The format of the String is the Date Time
	    // string format defined in 15.9.1.15. All fields are present in the String.
	    // The time zone is always UTC, denoted by the suffix Z. If the time value of
	    // this object is not a finite Number a RangeError exception is thrown.
	    var negativeDate = -62198755200000;
	    var negativeYearString = '-000001';
	    var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
	    var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';

	    var getTime = call.bind(Date.prototype.getTime);

	    defineProperties(Date.prototype, {
	        toISOString: function toISOString() {
	            if (!isFinite(this) || !isFinite(getTime(this))) {
	                // Adope Photoshop requires the second check.
	                throw new RangeError('Date.prototype.toISOString called on non-finite value.');
	            }

	            var year = originalGetUTCFullYear(this);

	            var month = originalGetUTCMonth(this);
	            // see https://github.com/es-shims/es5-shim/issues/111
	            year += Math.floor(month / 12);
	            month = (month % 12 + 12) % 12;

	            // the date time string format is specified in 15.9.1.15.
	            var result = [month + 1, originalGetUTCDate(this), originalGetUTCHours(this), originalGetUTCMinutes(this), originalGetUTCSeconds(this)];
	            year = (
	                (year < 0 ? '-' : (year > 9999 ? '+' : '')) +
	                strSlice('00000' + Math.abs(year), (0 <= year && year <= 9999) ? -4 : -6)
	            );

	            for (var i = 0; i < result.length; ++i) {
	                // pad months, days, hours, minutes, and seconds to have two digits.
	                result[i] = strSlice('00' + result[i], -2);
	            }
	            // pad milliseconds to have three digits.
	            return (
	                year + '-' + arraySlice(result, 0, 2).join('-') +
	                'T' + arraySlice(result, 2).join(':') + '.' +
	                strSlice('000' + originalGetUTCMilliseconds(this), -3) + 'Z'
	            );
	        }
	    }, hasNegativeDateBug || hasSafari51DateBug);

	    // ES5 15.9.5.44
	    // http://es5.github.com/#x15.9.5.44
	    // This function provides a String representation of a Date object for use by
	    // JSON.stringify (15.12.3).
	    var dateToJSONIsSupported = (function () {
	        try {
	            return Date.prototype.toJSON &&
	                new Date(NaN).toJSON() === null &&
	                new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&
	                Date.prototype.toJSON.call({ // generic
	                    toISOString: function () { return true; }
	                });
	        } catch (e) {
	            return false;
	        }
	    }());
	    if (!dateToJSONIsSupported) {
	        Date.prototype.toJSON = function toJSON(key) {
	            // When the toJSON method is called with argument key, the following
	            // steps are taken:

	            // 1.  Let O be the result of calling ToObject, giving it the this
	            // value as its argument.
	            // 2. Let tv be ES.ToPrimitive(O, hint Number).
	            var O = $Object(this);
	            var tv = ES.ToPrimitive(O);
	            // 3. If tv is a Number and is not finite, return null.
	            if (typeof tv === 'number' && !isFinite(tv)) {
	                return null;
	            }
	            // 4. Let toISO be the result of calling the [[Get]] internal method of
	            // O with argument "toISOString".
	            var toISO = O.toISOString;
	            // 5. If IsCallable(toISO) is false, throw a TypeError exception.
	            if (!isCallable(toISO)) {
	                throw new TypeError('toISOString property is not callable');
	            }
	            // 6. Return the result of calling the [[Call]] internal method of
	            //  toISO with O as the this value and an empty argument list.
	            return toISO.call(O);

	            // NOTE 1 The argument is ignored.

	            // NOTE 2 The toJSON function is intentionally generic; it does not
	            // require that its this value be a Date object. Therefore, it can be
	            // transferred to other kinds of objects for use as a method. However,
	            // it does require that any such object have a toISOString method. An
	            // object is free to use the argument key to filter its
	            // stringification.
	        };
	    }

	    // ES5 15.9.4.2
	    // http://es5.github.com/#x15.9.4.2
	    // based on work shared by Daniel Friesen (dantman)
	    // http://gist.github.com/303249
	    var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
	    var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
	    var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
	    if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
	        // XXX global assignment won't work in embeddings that use
	        // an alternate object for the context.
	        /* global Date: true */
	        /* eslint-disable no-undef */
	        var maxSafeUnsigned32Bit = Math.pow(2, 31) - 1;
	        var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
	        /* eslint-disable no-implicit-globals */
	        Date = (function (NativeDate) {
	        /* eslint-enable no-implicit-globals */
	        /* eslint-enable no-undef */
	            // Date.length === 7
	            var DateShim = function Date(Y, M, D, h, m, s, ms) {
	                var length = arguments.length;
	                var date;
	                if (this instanceof NativeDate) {
	                    var seconds = s;
	                    var millis = ms;
	                    if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
	                        // work around a Safari 8/9 bug where it treats the seconds as signed
	                        var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
	                        var sToShift = Math.floor(msToShift / 1e3);
	                        seconds += sToShift;
	                        millis -= sToShift * 1e3;
	                    }
	                    date = length === 1 && $String(Y) === Y ? // isString(Y)
	                        // We explicitly pass it through parse:
	                        new NativeDate(DateShim.parse(Y)) :
	                        // We have to manually make calls depending on argument
	                        // length here
	                        length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis) :
	                        length >= 6 ? new NativeDate(Y, M, D, h, m, seconds) :
	                        length >= 5 ? new NativeDate(Y, M, D, h, m) :
	                        length >= 4 ? new NativeDate(Y, M, D, h) :
	                        length >= 3 ? new NativeDate(Y, M, D) :
	                        length >= 2 ? new NativeDate(Y, M) :
	                        length >= 1 ? new NativeDate(Y instanceof NativeDate ? +Y : Y) :
	                                      new NativeDate();
	                } else {
	                    date = NativeDate.apply(this, arguments);
	                }
	                if (!isPrimitive(date)) {
	                    // Prevent mixups with unfixed Date object
	                    defineProperties(date, { constructor: DateShim }, true);
	                }
	                return date;
	            };

	            // 15.9.1.15 Date Time String Format.
	            var isoDateExpression = new RegExp('^' +
	                '(\\d{4}|[+-]\\d{6})' + // four-digit year capture or sign +
	                                          // 6-digit extended year
	                '(?:-(\\d{2})' + // optional month capture
	                '(?:-(\\d{2})' + // optional day capture
	                '(?:' + // capture hours:minutes:seconds.milliseconds
	                    'T(\\d{2})' + // hours capture
	                    ':(\\d{2})' + // minutes capture
	                    '(?:' + // optional :seconds.milliseconds
	                        ':(\\d{2})' + // seconds capture
	                        '(?:(\\.\\d{1,}))?' + // milliseconds capture
	                    ')?' +
	                '(' + // capture UTC offset component
	                    'Z|' + // UTC capture
	                    '(?:' + // offset specifier +/-hours:minutes
	                        '([-+])' + // sign capture
	                        '(\\d{2})' + // hours offset capture
	                        ':(\\d{2})' + // minutes offset capture
	                    ')' +
	                ')?)?)?)?' +
	            '$');

	            var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];

	            var dayFromMonth = function dayFromMonth(year, month) {
	                var t = month > 1 ? 1 : 0;
	                return (
	                    months[month] +
	                    Math.floor((year - 1969 + t) / 4) -
	                    Math.floor((year - 1901 + t) / 100) +
	                    Math.floor((year - 1601 + t) / 400) +
	                    365 * (year - 1970)
	                );
	            };

	            var toUTC = function toUTC(t) {
	                var s = 0;
	                var ms = t;
	                if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
	                    // work around a Safari 8/9 bug where it treats the seconds as signed
	                    var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
	                    var sToShift = Math.floor(msToShift / 1e3);
	                    s += sToShift;
	                    ms -= sToShift * 1e3;
	                }
	                return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
	            };

	            // Copy any custom methods a 3rd party library may have added
	            for (var key in NativeDate) {
	                if (owns(NativeDate, key)) {
	                    DateShim[key] = NativeDate[key];
	                }
	            }

	            // Copy "native" methods explicitly; they may be non-enumerable
	            defineProperties(DateShim, {
	                now: NativeDate.now,
	                UTC: NativeDate.UTC
	            }, true);
	            DateShim.prototype = NativeDate.prototype;
	            defineProperties(DateShim.prototype, {
	                constructor: DateShim
	            }, true);

	            // Upgrade Date.parse to handle simplified ISO 8601 strings
	            var parseShim = function parse(string) {
	                var match = isoDateExpression.exec(string);
	                if (match) {
	                    // parse months, days, hours, minutes, seconds, and milliseconds
	                    // provide default values if necessary
	                    // parse the UTC offset component
	                    var year = $Number(match[1]),
	                        month = $Number(match[2] || 1) - 1,
	                        day = $Number(match[3] || 1) - 1,
	                        hour = $Number(match[4] || 0),
	                        minute = $Number(match[5] || 0),
	                        second = $Number(match[6] || 0),
	                        millisecond = Math.floor($Number(match[7] || 0) * 1000),
	                        // When time zone is missed, local offset should be used
	                        // (ES 5.1 bug)
	                        // see https://bugs.ecmascript.org/show_bug.cgi?id=112
	                        isLocalTime = Boolean(match[4] && !match[8]),
	                        signOffset = match[9] === '-' ? 1 : -1,
	                        hourOffset = $Number(match[10] || 0),
	                        minuteOffset = $Number(match[11] || 0),
	                        result;
	                    var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
	                    if (
	                        hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25) &&
	                        minute < 60 && second < 60 && millisecond < 1000 &&
	                        month > -1 && month < 12 && hourOffset < 24 &&
	                        minuteOffset < 60 && // detect invalid offsets
	                        day > -1 &&
	                        day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
	                    ) {
	                        result = (
	                            (dayFromMonth(year, month) + day) * 24 +
	                            hour +
	                            hourOffset * signOffset
	                        ) * 60;
	                        result = (
	                            (result + minute + minuteOffset * signOffset) * 60 +
	                            second
	                        ) * 1000 + millisecond;
	                        if (isLocalTime) {
	                            result = toUTC(result);
	                        }
	                        if (-8.64e15 <= result && result <= 8.64e15) {
	                            return result;
	                        }
	                    }
	                    return NaN;
	                }
	                return NativeDate.parse.apply(this, arguments);
	            };
	            defineProperties(DateShim, { parse: parseShim });

	            return DateShim;
	        }(Date));
	        /* global Date: false */
	    }

	    // ES5 15.9.4.4
	    // http://es5.github.com/#x15.9.4.4
	    if (!Date.now) {
	        Date.now = function now() {
	            return new Date().getTime();
	        };
	    }

	    //
	    // Number
	    // ======
	    //

	    // ES5.1 15.7.4.5
	    // http://es5.github.com/#x15.7.4.5
	    var hasToFixedBugs = NumberPrototype.toFixed && (
	      (0.00008).toFixed(3) !== '0.000' ||
	      (0.9).toFixed(0) !== '1' ||
	      (1.255).toFixed(2) !== '1.25' ||
	      (1000000000000000128).toFixed(0) !== '1000000000000000128'
	    );

	    var toFixedHelpers = {
	        base: 1e7,
	        size: 6,
	        data: [0, 0, 0, 0, 0, 0],
	        multiply: function multiply(n, c) {
	            var i = -1;
	            var c2 = c;
	            while (++i < toFixedHelpers.size) {
	                c2 += n * toFixedHelpers.data[i];
	                toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
	                c2 = Math.floor(c2 / toFixedHelpers.base);
	            }
	        },
	        divide: function divide(n) {
	            var i = toFixedHelpers.size;
	            var c = 0;
	            while (--i >= 0) {
	                c += toFixedHelpers.data[i];
	                toFixedHelpers.data[i] = Math.floor(c / n);
	                c = (c % n) * toFixedHelpers.base;
	            }
	        },
	        numToString: function numToString() {
	            var i = toFixedHelpers.size;
	            var s = '';
	            while (--i >= 0) {
	                if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
	                    var t = $String(toFixedHelpers.data[i]);
	                    if (s === '') {
	                        s = t;
	                    } else {
	                        s += strSlice('0000000', 0, 7 - t.length) + t;
	                    }
	                }
	            }
	            return s;
	        },
	        pow: function pow(x, n, acc) {
	            return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
	        },
	        log: function log(x) {
	            var n = 0;
	            var x2 = x;
	            while (x2 >= 4096) {
	                n += 12;
	                x2 /= 4096;
	            }
	            while (x2 >= 2) {
	                n += 1;
	                x2 /= 2;
	            }
	            return n;
	        }
	    };

	    var toFixedShim = function toFixed(fractionDigits) {
	        var f, x, s, m, e, z, j, k;

	        // Test for NaN and round fractionDigits down
	        f = $Number(fractionDigits);
	        f = isActualNaN(f) ? 0 : Math.floor(f);

	        if (f < 0 || f > 20) {
	            throw new RangeError('Number.toFixed called with invalid number of decimals');
	        }

	        x = $Number(this);

	        if (isActualNaN(x)) {
	            return 'NaN';
	        }

	        // If it is too big or small, return the string value of the number
	        if (x <= -1e21 || x >= 1e21) {
	            return $String(x);
	        }

	        s = '';

	        if (x < 0) {
	            s = '-';
	            x = -x;
	        }

	        m = '0';

	        if (x > 1e-21) {
	            // 1e-21 < x < 1e21
	            // -70 < log2(x) < 70
	            e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
	            z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
	            z *= 0x10000000000000; // Math.pow(2, 52);
	            e = 52 - e;

	            // -18 < e < 122
	            // x = z / 2 ^ e
	            if (e > 0) {
	                toFixedHelpers.multiply(0, z);
	                j = f;

	                while (j >= 7) {
	                    toFixedHelpers.multiply(1e7, 0);
	                    j -= 7;
	                }

	                toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
	                j = e - 1;

	                while (j >= 23) {
	                    toFixedHelpers.divide(1 << 23);
	                    j -= 23;
	                }

	                toFixedHelpers.divide(1 << j);
	                toFixedHelpers.multiply(1, 1);
	                toFixedHelpers.divide(2);
	                m = toFixedHelpers.numToString();
	            } else {
	                toFixedHelpers.multiply(0, z);
	                toFixedHelpers.multiply(1 << (-e), 0);
	                m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
	            }
	        }

	        if (f > 0) {
	            k = m.length;

	            if (k <= f) {
	                m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
	            } else {
	                m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
	            }
	        } else {
	            m = s + m;
	        }

	        return m;
	    };
	    defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);

	    var hasToPrecisionUndefinedBug = (function () {
	        try {
	            return 1.0.toPrecision(undefined) === '1';
	        } catch (e) {
	            return true;
	        }
	    }());
	    var originalToPrecision = NumberPrototype.toPrecision;
	    defineProperties(NumberPrototype, {
	        toPrecision: function toPrecision(precision) {
	            return typeof precision === 'undefined' ? originalToPrecision.call(this) : originalToPrecision.call(this, precision);
	        }
	    }, hasToPrecisionUndefinedBug);

	    //
	    // String
	    // ======
	    //

	    // ES5 15.5.4.14
	    // http://es5.github.com/#x15.5.4.14

	    // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
	    // Many browsers do not split properly with regular expressions or they
	    // do not perform the split correctly under obscure conditions.
	    // See http://blog.stevenlevithan.com/archives/cross-browser-split
	    // I've tested in many browsers and this seems to cover the deviant ones:
	    //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
	    //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
	    //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
	    //       [undefined, "t", undefined, "e", ...]
	    //    ''.split(/.?/) should be [], not [""]
	    //    '.'.split(/()()/) should be ["."], not ["", "", "."]

	    if (
	        'ab'.split(/(?:ab)*/).length !== 2 ||
	        '.'.split(/(.?)(.?)/).length !== 4 ||
	        'tesst'.split(/(s)*/)[1] === 't' ||
	        'test'.split(/(?:)/, -1).length !== 4 ||
	        ''.split(/.?/).length ||
	        '.'.split(/()()/).length > 1
	    ) {
	        (function () {
	            var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
	            var maxSafe32BitInt = Math.pow(2, 32) - 1;

	            StringPrototype.split = function (separator, limit) {
	                var string = String(this);
	                if (typeof separator === 'undefined' && limit === 0) {
	                    return [];
	                }

	                // If `separator` is not a regex, use native split
	                if (!isRegex(separator)) {
	                    return strSplit(this, separator, limit);
	                }

	                var output = [];
	                var flags = (separator.ignoreCase ? 'i' : '') +
	                            (separator.multiline ? 'm' : '') +
	                            (separator.unicode ? 'u' : '') + // in ES6
	                            (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
	                    lastLastIndex = 0,
	                    // Make `global` and avoid `lastIndex` issues by working with a copy
	                    separator2, match, lastIndex, lastLength;
	                var separatorCopy = new RegExp(separator.source, flags + 'g');
	                if (!compliantExecNpcg) {
	                    // Doesn't need flags gy, but they don't hurt
	                    separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	                }
	                /* Values for `limit`, per the spec:
	                 * If undefined: 4294967295 // maxSafe32BitInt
	                 * If 0, Infinity, or NaN: 0
	                 * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
	                 * If negative number: 4294967296 - Math.floor(Math.abs(limit))
	                 * If other: Type-convert, then use the above rules
	                 */
	                var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
	                match = separatorCopy.exec(string);
	                while (match) {
	                    // `separatorCopy.lastIndex` is not reliable cross-browser
	                    lastIndex = match.index + match[0].length;
	                    if (lastIndex > lastLastIndex) {
	                        pushCall(output, strSlice(string, lastLastIndex, match.index));
	                        // Fix browsers whose `exec` methods don't consistently return `undefined` for
	                        // nonparticipating capturing groups
	                        if (!compliantExecNpcg && match.length > 1) {
	                            /* eslint-disable no-loop-func */
	                            match[0].replace(separator2, function () {
	                                for (var i = 1; i < arguments.length - 2; i++) {
	                                    if (typeof arguments[i] === 'undefined') {
	                                        match[i] = void 0;
	                                    }
	                                }
	                            });
	                            /* eslint-enable no-loop-func */
	                        }
	                        if (match.length > 1 && match.index < string.length) {
	                            array_push.apply(output, arraySlice(match, 1));
	                        }
	                        lastLength = match[0].length;
	                        lastLastIndex = lastIndex;
	                        if (output.length >= splitLimit) {
	                            break;
	                        }
	                    }
	                    if (separatorCopy.lastIndex === match.index) {
	                        separatorCopy.lastIndex++; // Avoid an infinite loop
	                    }
	                    match = separatorCopy.exec(string);
	                }
	                if (lastLastIndex === string.length) {
	                    if (lastLength || !separatorCopy.test('')) {
	                        pushCall(output, '');
	                    }
	                } else {
	                    pushCall(output, strSlice(string, lastLastIndex));
	                }
	                return output.length > splitLimit ? arraySlice(output, 0, splitLimit) : output;
	            };
	        }());

	    // [bugfix, chrome]
	    // If separator is undefined, then the result array contains just one String,
	    // which is the this value (converted to a String). If limit is not undefined,
	    // then the output array is truncated so that it contains no more than limit
	    // elements.
	    // "0".split(undefined, 0) -> []
	    } else if ('0'.split(void 0, 0).length) {
	        StringPrototype.split = function split(separator, limit) {
	            if (typeof separator === 'undefined' && limit === 0) {
	                return [];
	            }
	            return strSplit(this, separator, limit);
	        };
	    }

	    var str_replace = StringPrototype.replace;
	    var replaceReportsGroupsCorrectly = (function () {
	        var groups = [];
	        'x'.replace(/x(.)?/g, function (match, group) {
	            pushCall(groups, group);
	        });
	        return groups.length === 1 && typeof groups[0] === 'undefined';
	    }());

	    if (!replaceReportsGroupsCorrectly) {
	        StringPrototype.replace = function replace(searchValue, replaceValue) {
	            var isFn = isCallable(replaceValue);
	            var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
	            if (!isFn || !hasCapturingGroups) {
	                return str_replace.call(this, searchValue, replaceValue);
	            } else {
	                var wrappedReplaceValue = function (match) {
	                    var length = arguments.length;
	                    var originalLastIndex = searchValue.lastIndex;
	                    searchValue.lastIndex = 0;
	                    var args = searchValue.exec(match) || [];
	                    searchValue.lastIndex = originalLastIndex;
	                    pushCall(args, arguments[length - 2], arguments[length - 1]);
	                    return replaceValue.apply(this, args);
	                };
	                return str_replace.call(this, searchValue, wrappedReplaceValue);
	            }
	        };
	    }

	    // ECMA-262, 3rd B.2.3
	    // Not an ECMAScript standard, although ECMAScript 3rd Edition has a
	    // non-normative section suggesting uniform semantics and it should be
	    // normalized across all browsers
	    // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
	    var string_substr = StringPrototype.substr;
	    var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
	    defineProperties(StringPrototype, {
	        substr: function substr(start, length) {
	            var normalizedStart = start;
	            if (start < 0) {
	                normalizedStart = max(this.length + start, 0);
	            }
	            return string_substr.call(this, normalizedStart, length);
	        }
	    }, hasNegativeSubstrBug);

	    // ES5 15.5.4.20
	    // whitespace from: http://es5.github.io/#x15.5.4.20
	    var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	        '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
	        '\u2029\uFEFF';
	    var zeroWidth = '\u200b';
	    var wsRegexChars = '[' + ws + ']';
	    var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
	    var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
	    var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
	    defineProperties(StringPrototype, {
	        // http://blog.stevenlevithan.com/archives/faster-trim-javascript
	        // http://perfectionkills.com/whitespace-deviations/
	        trim: function trim() {
	            if (typeof this === 'undefined' || this === null) {
	                throw new TypeError("can't convert " + this + ' to object');
	            }
	            return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
	        }
	    }, hasTrimWhitespaceBug);
	    var trim = call.bind(String.prototype.trim);

	    var hasLastIndexBug = StringPrototype.lastIndexOf && 'abcあい'.lastIndexOf('あい', 2) !== -1;
	    defineProperties(StringPrototype, {
	        lastIndexOf: function lastIndexOf(searchString) {
	            if (typeof this === 'undefined' || this === null) {
	                throw new TypeError("can't convert " + this + ' to object');
	            }
	            var S = $String(this);
	            var searchStr = $String(searchString);
	            var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
	            var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
	            var start = min(max(pos, 0), S.length);
	            var searchLen = searchStr.length;
	            var k = start + searchLen;
	            while (k > 0) {
	                k = max(0, k - searchLen);
	                var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
	                if (index !== -1) {
	                    return k + index;
	                }
	            }
	            return -1;
	        }
	    }, hasLastIndexBug);

	    var originalLastIndexOf = StringPrototype.lastIndexOf;
	    defineProperties(StringPrototype, {
	        lastIndexOf: function lastIndexOf(searchString) {
	            return originalLastIndexOf.apply(this, arguments);
	        }
	    }, StringPrototype.lastIndexOf.length !== 1);

	    // ES-5 15.1.2.2
	    /* eslint-disable radix */
	    if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
	    /* eslint-enable radix */
	        /* global parseInt: true */
	        parseInt = (function (origParseInt) {
	            var hexRegex = /^[\-+]?0[xX]/;
	            return function parseInt(str, radix) {
	                var string = trim(String(str));
	                var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
	                return origParseInt(string, defaultedRadix);
	            };
	        }(parseInt));
	    }

	    // https://es5.github.io/#x15.1.2.3
	    if (1 / parseFloat('-0') !== -Infinity) {
	        /* global parseFloat: true */
	        parseFloat = (function (origParseFloat) {
	            return function parseFloat(string) {
	                var inputString = trim(String(string));
	                var result = origParseFloat(inputString);
	                return result === 0 && strSlice(inputString, 0, 1) === '-' ? -0 : result;
	            };
	        }(parseFloat));
	    }

	    if (String(new RangeError('test')) !== 'RangeError: test') {
	        var errorToStringShim = function toString() {
	            if (typeof this === 'undefined' || this === null) {
	                throw new TypeError("can't convert " + this + ' to object');
	            }
	            var name = this.name;
	            if (typeof name === 'undefined') {
	                name = 'Error';
	            } else if (typeof name !== 'string') {
	                name = $String(name);
	            }
	            var msg = this.message;
	            if (typeof msg === 'undefined') {
	                msg = '';
	            } else if (typeof msg !== 'string') {
	                msg = $String(msg);
	            }
	            if (!name) {
	                return msg;
	            }
	            if (!msg) {
	                return name;
	            }
	            return name + ': ' + msg;
	        };
	        // can't use defineProperties here because of toString enumeration issue in IE <= 8
	        Error.prototype.toString = errorToStringShim;
	    }

	    if (supportsDescriptors) {
	        var ensureNonEnumerable = function (obj, prop) {
	            if (isEnum(obj, prop)) {
	                var desc = Object.getOwnPropertyDescriptor(obj, prop);
	                if (desc.configurable) {
	                    desc.enumerable = false;
	                    Object.defineProperty(obj, prop, desc);
	                }
	            }
	        };
	        ensureNonEnumerable(Error.prototype, 'message');
	        if (Error.prototype.message !== '') {
	            Error.prototype.message = '';
	        }
	        ensureNonEnumerable(Error.prototype, 'name');
	    }

	    if (String(/a/mig) !== '/a/gim') {
	        var regexToString = function toString() {
	            var str = '/' + this.source + '/';
	            if (this.global) {
	                str += 'g';
	            }
	            if (this.ignoreCase) {
	                str += 'i';
	            }
	            if (this.multiline) {
	                str += 'm';
	            }
	            return str;
	        };
	        // can't use defineProperties here because of toString enumeration issue in IE <= 8
	        RegExp.prototype.toString = regexToString;
	    }
	}));


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(38)

	module.exports = forEach

	var toString = Object.prototype.toString
	var hasOwnProperty = Object.prototype.hasOwnProperty

	function forEach(list, iterator, context) {
	    if (!isFunction(iterator)) {
	        throw new TypeError('iterator must be a function')
	    }

	    if (arguments.length < 3) {
	        context = this
	    }
	    
	    if (toString.call(list) === '[object Array]')
	        forEachArray(list, iterator, context)
	    else if (typeof list === 'string')
	        forEachString(list, iterator, context)
	    else
	        forEachObject(list, iterator, context)
	}

	function forEachArray(array, iterator, context) {
	    for (var i = 0, len = array.length; i < len; i++) {
	        if (hasOwnProperty.call(array, i)) {
	            iterator.call(context, array[i], i, array)
	        }
	    }
	}

	function forEachString(string, iterator, context) {
	    for (var i = 0, len = string.length; i < len; i++) {
	        // no such thing as a sparse string.
	        iterator.call(context, string.charAt(i), i, string)
	    }
	}

	function forEachObject(object, iterator, context) {
	    for (var k in object) {
	        if (hasOwnProperty.call(object, k)) {
	            iterator.call(context, object[k], k, object)
	        }
	    }
	}


/***/ },
/* 77 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {if (typeof window !== "undefined") {
	    module.exports = window;
	} else if (typeof global !== "undefined") {
	    module.exports = global;
	} else if (typeof self !== "undefined"){
	    module.exports = self;
	} else {
	    module.exports = {};
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(84);

	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };

	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window] && window || this,
	      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }

	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());

	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];

	    // Delegate to the native `stringify` and `parse` implementations.
	    if (typeof nativeJSON == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }

	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        isProperty, forEach, undef;

	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	        // Safari < 2.0.2 stores the internal millisecond time value correctly,
	        // but clips the values returned by the date methods to the range of
	        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}

	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function () {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	                // Firefox 3.1b1 and b2 serialize string, number, and boolean
	                // primitives as object literals.
	                stringify(0) === "0" &&
	                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	                // literals.
	                stringify(new Number()) === "0" &&
	                stringify(new String()) == '""' &&
	                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	                // does not define a canonical JSON representation (this applies to
	                // objects with `toJSON` properties as well, *unless* they are nested
	                // within an object or array).
	                stringify(getClass) === undef &&
	                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	                // FF 3.1b3 pass this test.
	                stringify(undef) === undef &&
	                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	                // respectively, if the value is omitted entirely.
	                stringify() === undef &&
	                // FF 3.1b1, 2 throw an error if the given value is not a number,
	                // string, array, object, Boolean, or `null` literal. This applies to
	                // objects with custom `toJSON` methods as well, unless they are nested
	                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	                // methods entirely.
	                stringify(value) === "1" &&
	                stringify([value]) == "[1]" &&
	                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	                // `"[null]"`.
	                stringify([undef]) == "[null]" &&
	                // YUI 3.0.0b1 fails to serialize `null` literals.
	                stringify(null) == "null" &&
	                // FF 3.1b1, 2 halts serialization if an array contains a function:
	                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	                // elides non-JSON values from objects and arrays, unless they
	                // define custom `toJSON` methods.
	                stringify([undef, getClass, null]) == "[null,null,null]" &&
	                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	                // where character escape codes are expected (e.g., `\b` => `\u0008`).
	                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	                stringify(null, value) === "1" &&
	                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	                // serialize extended years.
	                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	                // The milliseconds are optional in ES 5, but required in 5.1.
	                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	                // four-digit years instead of six-digit years. Credits: @Yaffle.
	                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	                // values less than 1000. Credits: @Yaffle.
	                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }

	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";

	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");

	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function (year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }

	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(isProperty = objectProto.hasOwnProperty)) {
	        isProperty = function (property) {
	          var members = {}, constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            isProperty = function (property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__, result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            isProperty = function (property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return isProperty.call(this, property);
	        };
	      }

	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      forEach = function (object, callback) {
	        var size = 0, Properties, members, property;

	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function () {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;

	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;

	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          forEach = function (object, callback) {
	            // Create a set of iterated properties.
	            var members = {}, isFunction = getClass.call(object) == functionClass, property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
	              callback(property);
	            }
	          };
	        }
	        return forEach(object, callback);
	      };

	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };

	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function (width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };

	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function (value) {
	          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };

	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if (typeof value == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
	                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                  // Months, dates, hours, minutes, and seconds should have two
	                  // digits; milliseconds should have three.
	                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                  // Milliseconds are optional in ES 5.0, but required in 5.1.
	                  "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if (typeof value == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };

	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }

	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;

	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };

	        // Internal: Stores the parser state.
	        var Index, Source;

	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function () {
	          Index = Source = null;
	          throw SyntaxError();
	        };

	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function () {
	          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9: case 10: case 13: case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123: case 125: case 91: case 93: case 58: case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };

	        // Internal: Parses a JSON `value` token.
	        var get = function (value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };

	        // Internal: Updates a traversed object member.
	        var update = function (source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };

	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function (source, property, callback) {
	          var value = source[property], length;
	          if (typeof value == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };

	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }

	    exports["runInContext"] = runInContext;
	    return exports;
	  }

	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;

	    var JSON3 = runInContext(root, (root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function () {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    }));

	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }

	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)(module), (function() { return this; }())))

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var trim = __webpack_require__(80)
	  , forEach = __webpack_require__(76)
	  , isArray = function(arg) {
	      return Object.prototype.toString.call(arg) === '[object Array]';
	    }

	module.exports = function (headers) {
	  if (!headers)
	    return {}

	  var result = {}

	  forEach(
	      trim(headers).split('\n')
	    , function (row) {
	        var index = row.indexOf(':')
	          , key = trim(row.slice(0, index)).toLowerCase()
	          , value = trim(row.slice(index + 1))

	        if (typeof(result[key]) === 'undefined') {
	          result[key] = value
	        } else if (isArray(result[key])) {
	          result[key].push(value)
	        } else {
	          result[key] = [ result[key], value ]
	        }
	      }
	  )

	  return result
	}

/***/ },
/* 80 */
/***/ function(module, exports) {

	
	exports = module.exports = trim;

	function trim(str){
	  return str.replace(/^\s*|\s*$/g, '');
	}

	exports.left = function(str){
	  return str.replace(/^\s*/, '');
	};

	exports.right = function(str){
	  return str.replace(/\s*$/, '');
	};


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
		Copyright 2015 Axinom
		Copyright 2011-2013 Abdulla Abdurakhmanov
		Original sources are available at https://code.google.com/p/x2js/

		Licensed under the Apache License, Version 2.0 (the "License");
		you may not use this file except in compliance with the License.
		You may obtain a copy of the License at

		http://www.apache.org/licenses/LICENSE-2.0

		Unless required by applicable law or agreed to in writing, software
		distributed under the License is distributed on an "AS IS" BASIS,
		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		See the License for the specific language governing permissions and
		limitations under the License.
	*/

	/*
		Supported export methods:
		* AMD
		* <script> (window.X2JS)
		* Node.js

		Limitations:
		* Attribute namespace prefixes are not parsed as such.
		* Overall the serialization/deserializaton code is "best effort" and not foolproof.
	*/

	// Module definition pattern used is returnExports from https://github.com/umdjs/umd
	(function (root, factory) {
		"use strict";

		/* global define */
	    if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === 'object' && module.exports) {
	        // Node. Does not work with strict CommonJS, but only CommonJS-like
			// environments that support module.exports, like Node.
	        module.exports = factory(require("xmldom").DOMParser);
	    } else {
	        // Browser globals (root is window)
	        root.X2JS = factory();
		}
	})(this, function (CustomDOMParser) {
		"use strict";

	    // We return a constructor that can be used to make X2JS instances.
	    return function X2JS(config) {
			var VERSION = "3.1.1";

			config = config || {};

			function initConfigDefaults() {
				// If set to "property" then <element>_asArray will be created
				// to allow you to access any element as an array (even if there is only one of it).
				config.arrayAccessForm = config.arrayAccessForm || "none";

				// If "text" then <empty></empty> will be transformed to "".
				// If "object" then <empty></empty> will be transformed to {}.
				config.emptyNodeForm = config.emptyNodeForm || "text";

				// Allows attribute values to be converted on the fly during parsing to objects.
				// 	"test": function(name, value) { return true; }
				//	"convert": function(name, value) { return parseFloat(value);
				// convert() will be called for every attribute where test() returns true
				// and the return value from convert() will replace the original value of the attribute.
				config.attributeConverters = config.attributeConverters || [];

				// Any elements that match the paths here will have their text parsed
				// as an XML datetime value (2011-11-12T13:00:00-07:00 style).
				// The path can be a plain string (parent.child1.child2),
				// a regex (/.*\.child2/) or function(elementPath).
				config.datetimeAccessFormPaths = config.datetimeAccessFormPaths || [];

				// Any elements that match the paths listed here will be stored in JavaScript objects
				// as arrays even if there is only one of them. The path can be a plain string
				// (parent.child1.child2), a regex (/.*\.child2/) or function(elementName, elementPath).
				config.arrayAccessFormPaths = config.arrayAccessFormPaths || [];

				// If true, a toString function is generated to print nodes containing text or cdata.
				// Useful if you want to accept both plain text and CData as equivalent inputs.
				if (config.enableToStringFunc === undefined) {
					config.enableToStringFunc = true;
				}

				// If true, empty text tags are ignored for elements with child nodes.
				if (config.skipEmptyTextNodesForObj === undefined) {
					config.skipEmptyTextNodesForObj = true;
				}

				// If true, whitespace is trimmed from text nodes.
				if (config.stripWhitespaces === undefined) {
					config.stripWhitespaces = true;
				}

				// If true, double quotes are used in generated XML.
				if (config.useDoubleQuotes === undefined) {
					config.useDoubleQuotes = true;
				}

				// If true, the root element of the XML document is ignored when converting to objects.
				// The result will directly have the root element's children as its own properties.
				if (config.ignoreRoot === undefined) {
					config.ignoreRoot = false;
				}

				// Whether XML characters in text are escaped when reading/writing XML.
				if (config.escapeMode === undefined) {
					config.escapeMode = true;
				}

				// Prefix to use for properties that are created to represent XML attributes.
				if (config.attributePrefix === undefined) {
					config.attributePrefix = "_";
				}

				// If true, empty elements will created as self closing elements (<element />)
				// If false, empty elements will be created with start and end tags (<element></element>)
				if (config.selfClosingElements === undefined) {
					config.selfClosingElements = true;
				}

				// If this property defined as false and an XML element has CData node ONLY, it will be converted to text without additional property "__cdata"
				if (config.keepCData === undefined) {
					config.keepCData = false;
				}
			}

			function initRequiredPolyfills() {
				function pad(number) {
					var r = String(number);
					if (r.length === 1) {
						r = '0' + r;
					}
					return r;
				}
				// Hello IE8-
				if (typeof String.prototype.trim !== 'function') {
					String.prototype.trim = function trim() {
						return this.replace(/^\s+|^\n+|(\s|\n)+$/g, '');
					};
				}
				if (typeof Date.prototype.toISOString !== 'function') {
					// Implementation from http://stackoverflow.com/questions/2573521/how-do-i-output-an-iso-8601-formatted-string-in-javascript
					Date.prototype.toISOString = function toISOString() {
						var MS_IN_S = 1000;

						return this.getUTCFullYear()
							+ '-' + pad(this.getUTCMonth() + 1)
							+ '-' + pad(this.getUTCDate())
							+ 'T' + pad(this.getUTCHours())
							+ ':' + pad(this.getUTCMinutes())
							+ ':' + pad(this.getUTCSeconds())
							+ '.' + String((this.getUTCMilliseconds() / MS_IN_S).toFixed(3)).slice(2, 5)
							+ 'Z';
					};
				}
			}

			initConfigDefaults();
			initRequiredPolyfills();

			var DOMNodeTypes = {
				"ELEMENT_NODE": 1,
				"TEXT_NODE": 3,
				"CDATA_SECTION_NODE": 4,
				"COMMENT_NODE": 8,
				"DOCUMENT_NODE": 9
			};

			function getDomNodeLocalName(domNode) {
				var localName = domNode.localName;
				if (localName == null) {
					// Yeah, this is IE!!
					localName = domNode.baseName;
				}
				if (localName == null || localName === "") {
					// ==="" is IE too
					localName = domNode.nodeName;
				}
				return localName;
			}

			function getDomNodeNamespacePrefix(node) {
				return node.prefix;
			}

			function escapeXmlChars(str) {
				if (typeof str === "string")
					return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;');
				else
					return str;
			}

			function unescapeXmlChars(str) {
				return str.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&amp;/g, '&');
			}

			function ensureProperArrayAccessForm(element, childName, elementPath) {
				switch (config.arrayAccessForm) {
					case "property":
						if (!(element[childName] instanceof Array))
							element[childName + "_asArray"] = [element[childName]];
						else
							element[childName + "_asArray"] = element[childName];
						break;
				}

				if (!(element[childName] instanceof Array) && config.arrayAccessFormPaths.length > 0) {
					var match = false;

					for (var i = 0; i < config.arrayAccessFormPaths.length; i++) {
						var arrayPath = config.arrayAccessFormPaths[i];
						if (typeof arrayPath === "string") {
							if (arrayPath === elementPath) {
								match = true;
								break;
							}
						} else if (arrayPath instanceof RegExp) {
							if (arrayPath.test(elementPath)) {
								match = true;
								break;
							}
						} else if (typeof arrayPath === "function") {
							if (arrayPath(childName, elementPath)) {
								match = true;
								break;
							}
						}
					}

					if (match)
						element[childName] = [element[childName]];
				}
			}

			function xmlDateTimeToDate(prop) {
				// Implementation based up on http://stackoverflow.com/questions/8178598/xml-datetime-to-javascript-date-object
				// Improved to support full spec and optional parts
				var MINUTES_PER_HOUR = 60;

				var bits = prop.split(/[-T:+Z]/g);

				var d = new Date(bits[0], bits[1] - 1, bits[2]);
				var secondBits = bits[5].split("\.");
				d.setHours(bits[3], bits[4], secondBits[0]);
				if (secondBits.length > 1)
					d.setMilliseconds(secondBits[1]);

				// Get supplied time zone offset in minutes
				if (bits[6] && bits[7]) {
					var offsetMinutes = bits[6] * MINUTES_PER_HOUR + Number(bits[7]);
					var sign = /\d\d-\d\d:\d\d$/.test(prop) ? '-' : '+';

					// Apply the sign
					offsetMinutes = 0 + (sign === '-' ? -1 * offsetMinutes : offsetMinutes);

					// Apply offset and local timezone
					d.setMinutes(d.getMinutes() - offsetMinutes - d.getTimezoneOffset());
				} else if (prop.indexOf("Z", prop.length - 1) !== -1) {
					d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));
				}

				// d is now a local time equivalent to the supplied time
				return d;
			}

			function convertToDateIfRequired(value, childName, fullPath) {
				if (config.datetimeAccessFormPaths.length > 0) {
					var pathWithoutTextNode = fullPath.split("\.#")[0];

					for (var i = 0; i < config.datetimeAccessFormPaths.length; i++) {
						var candidatePath = config.datetimeAccessFormPaths[i];
						if (typeof candidatePath === "string") {
							if (candidatePath === pathWithoutTextNode)
								return xmlDateTimeToDate(value);
						} else if (candidatePath instanceof RegExp) {
							if (candidatePath.test(pathWithoutTextNode))
								return xmlDateTimeToDate(value);
						} else if (typeof candidatePath === "function") {
							if (candidatePath(pathWithoutTextNode))
								return xmlDateTimeToDate(value);
						}
					}
				}

				return value;
			}

			function deserializeRootElementChildren(rootElement) {
				var result = {};
				var children = rootElement.childNodes;

				// Alternative for firstElementChild which is not supported in some environments
				for (var i = 0; i < children.length; i++) {
					var child = children.item(i);
					if (child.nodeType === DOMNodeTypes.ELEMENT_NODE) {
						var childName = getDomNodeLocalName(child);

						if (config.ignoreRoot)
							result = deserializeDomChildren(child, childName);
						else
							result[childName] = deserializeDomChildren(child, childName);
					}
				}

				return result;
			}

			function deserializeElementChildren(element, elementPath) {
				var result = {};
				result.__cnt = 0;

				var nodeChildren = element.childNodes;

				// Child nodes.
				for (var iChild = 0; iChild < nodeChildren.length; iChild++) {
					var child = nodeChildren.item(iChild);
					var childName = getDomNodeLocalName(child);

					if (child.nodeType === DOMNodeTypes.COMMENT_NODE)
						continue;

					result.__cnt++;

					// We deliberately do not accept everything falsey here because
					// elements that resolve to empty string should still be preserved.
					if (result[childName] == null) {
						result[childName] = deserializeDomChildren(child, elementPath + "." + childName);
						ensureProperArrayAccessForm(result, childName, elementPath + "." + childName);
					} else {
						if (!(result[childName] instanceof Array)) {
							result[childName] = [result[childName]];
							ensureProperArrayAccessForm(result, childName, elementPath + "." + childName);
						}

						result[childName][result[childName].length] = deserializeDomChildren(child, elementPath + "." + childName);
					}
				}

				// Attributes
				for (var iAttribute = 0; iAttribute < element.attributes.length; iAttribute++) {
					var attribute = element.attributes.item(iAttribute);
					result.__cnt++;

					var adjustedValue = attribute.value;
					for (var iConverter = 0; iConverter < config.attributeConverters.length; iConverter++) {
						var converter = config.attributeConverters[iConverter];
						if (converter.test.call(null, attribute.name, attribute.value))
							adjustedValue = converter.convert.call(null, attribute.name, attribute.value);
					}

					result[config.attributePrefix + attribute.name] = adjustedValue;
				}

				// Node namespace prefix
				var namespacePrefix = getDomNodeNamespacePrefix(element);
				if (namespacePrefix) {
					result.__cnt++;
					result.__prefix = namespacePrefix;
				}

				if (result["#text"]) {
					result.__text = result["#text"];

					if (result.__text instanceof Array) {
						result.__text = result.__text.join("\n");
					}

					if (config.escapeMode)
						result.__text = unescapeXmlChars(result.__text);

					if (config.stripWhitespaces)
						result.__text = result.__text.trim();

					delete result["#text"];

					if (config.arrayAccessForm === "property")
						delete result["#text_asArray"];

					result.__text = convertToDateIfRequired(result.__text, "#text", elementPath + ".#text");
				}

				if (result.hasOwnProperty('#cdata-section')) {
					result.__cdata = result["#cdata-section"];
					delete result["#cdata-section"];

					if (config.arrayAccessForm === "property")
						delete result["#cdata-section_asArray"];
				}

				if (result.__cnt === 1 && result.__text) {
					result = result.__text;
				} else if (result.__cnt === 0 && config.emptyNodeForm === "text") {
					result = '';
				} else if (result.__cnt > 1 && result.__text !== undefined && config.skipEmptyTextNodesForObj) {
					if (config.stripWhitespaces && result.__text === "" || result.__text.trim() === "") {
						delete result.__text;
					}
				}
				delete result.__cnt;
				
				if (!config.keepCData && (!result.hasOwnProperty('__text') && result.hasOwnProperty('__cdata'))) {
					return (result.__cdata ? result.__cdata : '');
				}

				if (config.enableToStringFunc && (result.__text || result.__cdata)) {
					result.toString = function toString() {
						return (this.__text ? this.__text : '') + (this.__cdata ? this.__cdata : '');
					};
				}

				return result;
			}

			function deserializeDomChildren(node, parentPath) {
				if (node.nodeType === DOMNodeTypes.DOCUMENT_NODE) {
					return deserializeRootElementChildren(node);
				} else if (node.nodeType === DOMNodeTypes.ELEMENT_NODE) {
					return deserializeElementChildren(node, parentPath);
				} else if (node.nodeType === DOMNodeTypes.TEXT_NODE || node.nodeType === DOMNodeTypes.CDATA_SECTION_NODE) {
					return node.nodeValue;
				} else {
					return null;
				}
			}

			function serializeStartTag(jsObject, elementName, attributeNames, selfClosing) {
				var resultStr = "<" + ((jsObject && jsObject.__prefix) ? (jsObject.__prefix + ":") : "") + elementName;

				if (attributeNames) {
					for (var i = 0; i < attributeNames.length; i++) {
						var attributeName = attributeNames[i];
						var attributeValue = jsObject[attributeName];

						if (config.escapeMode)
							attributeValue = escapeXmlChars(attributeValue);

						resultStr += " " + attributeName.substr(config.attributePrefix.length) + "=";

						if (config.useDoubleQuotes)
							resultStr += '"' + attributeValue + '"';
						else
							resultStr += "'" + attributeValue + "'";
					}
				}

				if (!selfClosing)
					resultStr += ">";
				else
					resultStr += " />";

				return resultStr;
			}

			function serializeEndTag(jsObject, elementName) {
				return "</" + ((jsObject && jsObject.__prefix) ? (jsObject.__prefix + ":") : "") + elementName + ">";
			}

			function endsWith(str, suffix) {
				return str.indexOf(suffix, str.length - suffix.length) !== -1;
			}

			function isSpecialProperty(jsonObj, propertyName) {
				if ((config.arrayAccessForm === "property" && endsWith(propertyName.toString(), ("_asArray")))
					|| propertyName.toString().indexOf(config.attributePrefix) === 0
					|| propertyName.toString().indexOf("__") === 0
					|| (jsonObj[propertyName] instanceof Function))
					return true;
				else
					return false;
			}

			function getDataElementCount(jsObject) {
				var count = 0;

				if (jsObject instanceof Object) {
					for (var propertyName in jsObject) {
						if (isSpecialProperty(jsObject, propertyName))
							continue;

						count++;
					}
				}

				return count;
			}

			function getDataAttributeNames(jsObject) {
				var names = [];

				if (jsObject instanceof Object) {
					for (var attributeName in jsObject) {
						if (attributeName.toString().indexOf("__") === -1
							&& attributeName.toString().indexOf(config.attributePrefix) === 0) {
							names.push(attributeName);
						}
					}
				}

				return names;
			}

			function serializeComplexTextNodeContents(textNode) {
				var result = "";

				if (textNode.__cdata) {
					result += "<![CDATA[" + textNode.__cdata + "]]>";
				}

				if (textNode.__text) {
					if (config.escapeMode)
						result += escapeXmlChars(textNode.__text);
					else
						result += textNode.__text;
				}

				return result;
			}

			function serializeTextNodeContents(textNode) {
				var result = "";

				if (textNode instanceof Object) {
					result += serializeComplexTextNodeContents(textNode);
				} else if (textNode !== null) {
					if (config.escapeMode)
						result += escapeXmlChars(textNode);
					else
						result += textNode;
				}

				return result;
			}

			function serializeArray(elementArray, elementName, attributes) {
				var result = "";

				if (elementArray.length === 0) {
					result += serializeStartTag(elementArray, elementName, attributes, true);
				} else {
					for (var i = 0; i < elementArray.length; i++) {
						result += serializeJavaScriptObject(elementArray[i], elementName, getDataAttributeNames(elementArray[i]));
					}
				}

				return result;
			}

			function serializeJavaScriptObject(element, elementName, attributes) {
				var result = "";

				if ((element === undefined || element === null || element === '') && config.selfClosingElements) {
					result += serializeStartTag(element, elementName, attributes, true);
				} else if (typeof element === 'object') {
					if (Object.prototype.toString.call(element) === '[object Array]') {
						result += serializeArray(element, elementName, attributes);
					} else if (element instanceof Date) {
						result += serializeStartTag(element, elementName, attributes, false);
						result += element.toISOString();
						result += serializeEndTag(element, elementName);
					} else {
						var childElementCount = getDataElementCount(element);
						if (childElementCount > 0 || element.__text || element.__cdata) {
							result += serializeStartTag(element, elementName, attributes, false);
							result += serializeJavaScriptObjectChildren(element);
							result += serializeEndTag(element, elementName);
						} else if (config.selfClosingElements) {
							result += serializeStartTag(element, elementName, attributes, true);
						} else {
							result += serializeStartTag(element, elementName, attributes, false);
							result += serializeEndTag(element, elementName);
						}
					}
				} else {
					result += serializeStartTag(element, elementName, attributes, false);
					result += serializeTextNodeContents(element);
					result += serializeEndTag(element, elementName);
				}

				return result;
			}

			function serializeJavaScriptObjectChildren(jsObject) {
				var result = "";

				var elementCount = getDataElementCount(jsObject);

				if (elementCount > 0) {
					for (var elementName in jsObject) {
						if (isSpecialProperty(jsObject, elementName))
							continue;

						var element = jsObject[elementName];
						var attributes = getDataAttributeNames(element);

						result += serializeJavaScriptObject(element, elementName, attributes);
					}
				}

				result += serializeTextNodeContents(jsObject);

				return result;
			}

			function parseXml(xml) {
				if (xml === undefined) {
					return null;
				}

				if (typeof xml !== "string") {
					return null;
				}

				var parser = null;
				var domNode = null;

				if (CustomDOMParser) {
					// This branch is used for node.js, with the xmldom parser.
					parser = new CustomDOMParser();

					domNode = parser.parseFromString(xml, "text/xml");
				} else if (window && window.DOMParser) {
					parser = new window.DOMParser();
					var parsererrorNS = null;

					var isIEParser = window.ActiveXObject || "ActiveXObject" in window;

					// IE9+ now is here
					if (!isIEParser) {
						try {
							parsererrorNS = parser.parseFromString("INVALID", "text/xml").childNodes[0].namespaceURI;
						} catch (err) {
							parsererrorNS = null;
						}
					}

					try {
						domNode = parser.parseFromString(xml, "text/xml");
						if (parsererrorNS !== null && domNode.getElementsByTagNameNS(parsererrorNS, "parsererror").length > 0) {
							domNode = null;
						}
					} catch (err) {
						domNode = null;
					}
				} else {
					// IE :(
					if (xml.indexOf("<?") === 0) {
						xml = xml.substr(xml.indexOf("?>") + 2);
					}

					/* global ActiveXObject */
					domNode = new ActiveXObject("Microsoft.XMLDOM");
					domNode.async = "false";
					domNode.loadXML(xml);
				}

				return domNode;
			}

			this.asArray = function asArray(prop) {
				if (prop === undefined || prop === null) {
					return [];
				} else if (prop instanceof Array) {
					return prop;
				} else {
					return [prop];
				}
			};

			this.toXmlDateTime = function toXmlDateTime(dt) {
				if (dt instanceof Date) {
					return dt.toISOString();
				} else if (typeof (dt) === 'number') {
					return new Date(dt).toISOString();
				} else {
					return null;
				}
			};

			this.asDateTime = function asDateTime(prop) {
				if (typeof (prop) === "string") {
					return xmlDateTimeToDate(prop);
				} else {
					return prop;
				}
			};

			/*
				Internally the logic works in a cycle:
				DOM->JS - implemented by custom logic (deserialization).
				JS->XML - implemented by custom logic (serialization).
				XML->DOM - implemented by browser.
			*/

			// Transformns an XML string into DOM-tree
			this.xml2dom = function xml2dom(xml) {
				return parseXml(xml);
			};

			// Transforms a DOM tree to JavaScript objects.
			this.dom2js = function dom2js(domNode) {
				return deserializeDomChildren(domNode, null);
			};

			// Transforms JavaScript objects to a DOM tree.
			this.js2dom = function js2dom(jsObject) {
				var xml = this.js2xml(jsObject);
				return parseXml(xml);
			};

			// Transformns an XML string into JavaScript objects.
			this.xml2js = function xml2js(xml) {
				var domNode = parseXml(xml);
				if (domNode != null)
					return this.dom2js(domNode);
				else
					return null;
			};

			// Transforms JavaScript objects into an XML string.
			this.js2xml = function js2xml(jsObject) {
				return serializeJavaScriptObjectChildren(jsObject);
			};

			this.getVersion = function getVersion() {
				return VERSION;
			};
		};
	});


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var window = __webpack_require__(77)
	var isFunction = __webpack_require__(38)
	var parseHeaders = __webpack_require__(79)
	var xtend = __webpack_require__(83)

	module.exports = createXHR
	createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
	createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

	forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
	    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
	        options = initParams(uri, options, callback)
	        options.method = method.toUpperCase()
	        return _createXHR(options)
	    }
	})

	function forEachArray(array, iterator) {
	    for (var i = 0; i < array.length; i++) {
	        iterator(array[i])
	    }
	}

	function isEmpty(obj){
	    for(var i in obj){
	        if(obj.hasOwnProperty(i)) return false
	    }
	    return true
	}

	function initParams(uri, options, callback) {
	    var params = uri

	    if (isFunction(options)) {
	        callback = options
	        if (typeof uri === "string") {
	            params = {uri:uri}
	        }
	    } else {
	        params = xtend(options, {uri: uri})
	    }

	    params.callback = callback
	    return params
	}

	function createXHR(uri, options, callback) {
	    options = initParams(uri, options, callback)
	    return _createXHR(options)
	}

	function _createXHR(options) {
	    if(typeof options.callback === "undefined"){
	        throw new Error("callback argument missing")
	    }

	    var called = false
	    var callback = function cbOnce(err, response, body){
	        if(!called){
	            called = true
	            options.callback(err, response, body)
	        }
	    }

	    function readystatechange() {
	        if (xhr.readyState === 4) {
	            loadFunc()
	        }
	    }

	    function getBody() {
	        // Chrome with requestType=blob throws errors arround when even testing access to responseText
	        var body = undefined

	        if (xhr.response) {
	            body = xhr.response
	        } else {
	            body = xhr.responseText || getXml(xhr)
	        }

	        if (isJson) {
	            try {
	                body = JSON.parse(body)
	            } catch (e) {}
	        }

	        return body
	    }

	    var failureResponse = {
	                body: undefined,
	                headers: {},
	                statusCode: 0,
	                method: method,
	                url: uri,
	                rawRequest: xhr
	            }

	    function errorFunc(evt) {
	        clearTimeout(timeoutTimer)
	        if(!(evt instanceof Error)){
	            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
	        }
	        evt.statusCode = 0
	        return callback(evt, failureResponse)
	    }

	    // will load the data & process the response in a special response object
	    function loadFunc() {
	        if (aborted) return
	        var status
	        clearTimeout(timeoutTimer)
	        if(options.useXDR && xhr.status===undefined) {
	            //IE8 CORS GET successful response doesn't have a status field, but body is fine
	            status = 200
	        } else {
	            status = (xhr.status === 1223 ? 204 : xhr.status)
	        }
	        var response = failureResponse
	        var err = null

	        if (status !== 0){
	            response = {
	                body: getBody(),
	                statusCode: status,
	                method: method,
	                headers: {},
	                url: uri,
	                rawRequest: xhr
	            }
	            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
	                response.headers = parseHeaders(xhr.getAllResponseHeaders())
	            }
	        } else {
	            err = new Error("Internal XMLHttpRequest Error")
	        }
	        return callback(err, response, response.body)
	    }

	    var xhr = options.xhr || null

	    if (!xhr) {
	        if (options.cors || options.useXDR) {
	            xhr = new createXHR.XDomainRequest()
	        }else{
	            xhr = new createXHR.XMLHttpRequest()
	        }
	    }

	    var key
	    var aborted
	    var uri = xhr.url = options.uri || options.url
	    var method = xhr.method = options.method || "GET"
	    var body = options.body || options.data || null
	    var headers = xhr.headers = options.headers || {}
	    var sync = !!options.sync
	    var isJson = false
	    var timeoutTimer

	    if ("json" in options && options.json !== false) {
	        isJson = true
	        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
	        if (method !== "GET" && method !== "HEAD") {
	            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
	            body = JSON.stringify(options.json === true ? body : options.json)
	        }
	    }

	    xhr.onreadystatechange = readystatechange
	    xhr.onload = loadFunc
	    xhr.onerror = errorFunc
	    // IE9 must have onprogress be set to a unique function.
	    xhr.onprogress = function () {
	        // IE must die
	    }
	    xhr.onabort = function(){
	        aborted = true;
	    }
	    xhr.ontimeout = errorFunc
	    xhr.open(method, uri, !sync, options.username, options.password)
	    //has to be after open
	    if(!sync) {
	        xhr.withCredentials = !!options.withCredentials
	    }
	    // Cannot set timeout with sync request
	    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
	    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
	    if (!sync && options.timeout > 0 ) {
	        timeoutTimer = setTimeout(function(){
	            if (aborted) return
	            aborted = true//IE9 may still call readystatechange
	            xhr.abort("timeout")
	            var e = new Error("XMLHttpRequest timeout")
	            e.code = "ETIMEDOUT"
	            errorFunc(e)
	        }, options.timeout )
	    }

	    if (xhr.setRequestHeader) {
	        for(key in headers){
	            if(headers.hasOwnProperty(key)){
	                xhr.setRequestHeader(key, headers[key])
	            }
	        }
	    } else if (options.headers && !isEmpty(options.headers)) {
	        throw new Error("Headers cannot be set on an XDomainRequest object")
	    }

	    if ("responseType" in options) {
	        xhr.responseType = options.responseType
	    }

	    if ("beforeSend" in options &&
	        typeof options.beforeSend === "function"
	    ) {
	        options.beforeSend(xhr)
	    }

	    xhr.send(body)

	    return xhr


	}

	function getXml(xhr) {
	    if (xhr.responseType === "document") {
	        return xhr.responseXML
	    }
	    var firefoxBugTakenEffect = xhr.status === 204 && xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
	    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
	        return xhr.responseXML
	    }

	    return null
	}

	function noop() {}


/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = extend

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function extend() {
	    var target = {}

	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]

	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }

	    return target
	}


/***/ },
/* 84 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIMFn = __webpack_require__(6).fn;
	var util = __webpack_require__(1);

	/**
	 * 音频转文字
	 *
	 * - 仅支持通过{@link NIM#previewFile|previewFile}或者{@link NIM#sendFile|sendFile}拿到的音频 url, 或者收到的音频消息的 url
	 *
	 * @memberOf NIM#
	 * @method audioToText
	 * 
	 * @param  {Object} options 配置参数
	 * @param {String} options.url 音频 url
	 * @param {Function} options.done 结果回调函数, 成功时会额外附上文本 text
	 * @return {Void}
	 *
	 * @example
	 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ1MTg5MDI2MjY0MF9lYzk1MWMyZC1hMzRmLTQ1YzctYWI2ZS1kZWE2NTA2M2Q4NjY=';
	 * nim.audioToText({
	 *     url: url,
	 *     done: audioToTextDone
	 * });
	 * function audioToTextDone(error, obj) {
	 *     console.log('语音转文字' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.audioToText = function (options) {
	  util.verifyOptions(options, 'url');
	  options.audioToText = util.filterObj(options, 'url');
	  var self = this;
	  self.processCallback(options);
	  self.sendCmd('audioToText', options);
	};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIMFn = __webpack_require__(6).fn;
	var util = __webpack_require__(1);

	/**
	 * 获取聊天室服务器地址
	 *
	 * - 可以在 IM 连接上获取聊天室服务器地址
	 * 
	 * @memberOf NIM#
	 * @method getChatroomAddress
	 * 
	 * @param  {Object} options 配置参数
	 * @param {String} [options.chatroomId] 聊天室 id
	 * @return {Void}
	 *
	 * @example
	 * nim.getChatroomAddress({
	 *     chatroomId: 'chatroomId',
	 *     done: getChatroomAddressDone
	 * });
	 * function getChatroomAddressDone(error, obj) {
	 *     console.log('获取聊天室地址' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.getChatroomAddress = function (options) {
	  util.verifyOptions(options, 'chatroomId');
	  var self = this;
	  self.processCallback(options);
	  self.sendCmd('getChatroomAddress', options);
	};

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIMFn = __webpack_require__(6).fn;
	var util = __webpack_require__(1);

	/**
	 * 是否连接上服务器
	 * @private
	 * @return {Boolean} 连接状态
	 *
	 * @see {@link NIM#connect|connect}
	 * @see {@link NIM#disconnect|disconnect}
	 *
	 * @example
	 * if (!nim.isConnected()) {
	 *     console.log('未连接');
	 * }
	 */

	/**
	 * 登录 SDK
	 *
	 * @memberOf NIM#
	 * @method connect
	 *
	 * @return {Void}
	 *
	 * @see {@link NIM#disconnect|disconnect}
	 *
	 * @example
	 * nim.connect();
	 */

	/**
	 * 登出 SDK
	 *
	 * @memberOf NIM#
	 * @method disconnect
	 *
	 * @return {Void}
	 *
	 * @see {@link NIM#connect|connect}
	 *
	 * @example
	 * nim.disconnect();
	 */

	/**
	 * 踢当前用户登录的其它端
	 *
	 * @method kick
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options             配置参数
	 * @param  {String[]}   options.deviceIds   要踢掉的端的设备号数组
	 * @param  {done}       options.done        结果回调函数, 成功时会收到被踢掉的设备号数组
	 * @return {Void}
	 *
	 * @example
	 * nim.kick({
	 *     deviceIds: ['device1'],
	 *     done: onKick
	 * });
	 * function onKick(error, obj) {
	 *     console.log('踢其它端' + (!error?'成功':'失败'));
	 *     console.log(error);
	 *     console.log(obj);
	 * }
	 */
	NIMFn.kick = function (options) {
	  util.verifyOptions(options, 'deviceIds');
	  this.processCallback(options);
	  this.sendCmd('kick', { deviceIds: options.deviceIds.slice(0) }, options.callback);
	};

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIMFn = __webpack_require__(6).fn;

	NIMFn.clearDB = function (options) {
	  var self = this;
	  var db = self.db;
	  self.processCallback(options);
	  var done = options.done;
	  if (db.enable) {
	    db.clear().then(done, done);
	  } else {
	    done();
	  }
	};

	NIMFn.removeDB = function (options) {
	  var self = this;
	  var db = self.db;
	  self.processCallback(options);
	  var done = options.done;
	  if (db.enable) {
	    db.destroy().then(done, done);
	  } else {
	    done();
	  }
	};

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var Promise = __webpack_require__(2).Promise;
	var NIMFn = __webpack_require__(6).fn;
	var util = __webpack_require__(1);
	var MsgEvent = __webpack_require__(142);
	var MsgEventSubscribe = __webpack_require__(143);

	// 逆转化返回对象的数据格式
	function formatReturnEventObj(obj) {
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    if (obj.msgEventSubscribes) {
	      obj = obj.msgEventSubscribes;
	    } else if (obj.msgEventSubscribe) {
	      obj = obj.msgEventSubscribe;
	    } else if (obj.accounts) {
	      obj = obj.accounts;
	    } else if (obj.msgEvent) {
	      obj = obj.msgEvent;
	      if (obj.time) {
	        obj.time = +obj.time;
	      }
	    }
	    if (obj.sync === 1) {
	      obj.sync = true;
	    } else if (obj.sync === 0) {
	      obj.sync = false;
	    }
	  }
	  return obj;
	}

	// 批量发送事件消息接口，因为accids一次最多只能发100个
	// usages: this.batchSendEventsCmds('subscribeEvent', {msgEventSubscribe, accounts: tempAccounts}, callback)
	NIMFn.batchSendEventsCmds = function (cmd, options, callback) {
	  var self = this;
	  // 一次最多请求服务器的accounts数目
	  var accidsCount = 100;
	  var accountArray = util.dropArrayDuplicates(options.accounts);
	  accountArray = util.reshape2d(accountArray, accidsCount);
	  var promiseList = [];
	  accountArray.forEach(function (tempAccounts) {
	    promiseList.push(new Promise(function (resolve, reject) {
	      var tempOptions = util.simpleClone(options);
	      tempOptions.accounts = tempAccounts;
	      self.sendCmdWithResp(cmd, tempOptions, function (err, content) {
	        if (err) {
	          reject(err);
	        } else {
	          resolve(formatReturnEventObj(content));
	        }
	      }); // end this.sendCmd
	    }) // end new Promise
	    );
	  }); // end forEach
	  Promise.all(promiseList).then(function (resolve) {
	    var result = null;
	    if (resolve.length > 0) {
	      if (resolve[0].msgEventSubscribe) {
	        (function () {
	          var msgEventSubscribe = resolve[0].msgEventSubscribe;
	          msgEventSubscribe = formatReturnEventObj(msgEventSubscribe);
	          var accounts = [];
	          resolve.forEach(function (item) {
	            accounts = accounts.concat(item.accounts);
	          });
	          result = { accounts: accounts, msgEventSubscribe: msgEventSubscribe };
	        })();
	      } else {
	        result = [];
	        resolve.forEach(function (item) {
	          result = result.concat(item);
	        });
	      }
	    }
	    callback(null, result);
	  }, function (reject) {
	    callback(reject, null);
	  });
	};

	/**
	 * 发布事件
	 *
	 * @method publishEvent
	 * @memberOf NIM#
	 *
	 * @param {Object} options    配置参数
	 * @param {Int}    options.type    事件类型 必须指定100000以上 由上层做自定义映射
	 * @param {Int}    options.value    事件状态/事件内容，由上层做自定义映射
	 * @param {String} options.custom [可选]用户自定义事件扩展属性，最长256字节
	 * @param {Int}    options.vaildTime [可选]发布事件的有效时间 单位秒 60s~7天(604800s)，默认7天
	 * @param {Int} options.broadcastType [可选] 广播类型 1:仅在线 2:在线和离线，默认2(在线和离线)
	 * @param {Boolean} options.sync [可选] true:同步给自己，false:不同步给自己，默认false
	 * @param {done}   options.done    结果回调函数
	 * @return {Void}
	 *
	 * @callback
	 * @param {Object} error
	 * @param {Object} msgEvent  回调函数返回事件对象
	 * @param {String} msgEvent.idClient 消息标识
	 * @param {String} msgEvent.idServer 消息标识
	 * @param {String} msgEvent.time 事件发布时间戳
	 *
	 * @example
	 * nim.publishEvent({
	 *     type: 100000,
	 *     value: 2,
	 *     custom: 'hello world',
	 *     vaildTime: 60,
	 *     sync: false,
	 *     done: publishEventDone
	 * });
	 * function publishEventDone(error, obj) {
	 *     console.log('发布事件' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.publishEvent = function (options) {
	  var self = this;
	  var msgEvent = new MsgEvent(options);
	  msgEvent = msgEvent.assembleEvent();
	  self.processCallback(options);
	  this.sendCmdWithResp('publishEvent', { msgEvent: msgEvent }, function onPublishEvent(err, obj) {
	    if (!err) {
	      obj = formatReturnEventObj(obj);
	    }
	    options.callback(err, obj);
	  });
	};

	/**
	 * 订阅事件
	 *
	 * @method subscribeEvent
	 * @memberOf NIM#
	 *
	 * @param {Object} options    配置参数
	 * @param {Int}    options.type  事件类型 必须指定100000以上 由上层做自定义映射
	 * @param {Int}    options.subscribeTime   [可选]订阅关系的有效时间 单位秒 60s~30天(2592000)，默认30天
	 * @param {Boolean} options.sync  [可选]订阅后是否立即同步最新事件，true:同步，false:不同步，默认同步
	 * @param {Array} options.accounts 订阅好友的账号列表。当accounts元素数量大于100时，SDK会以每100个帐号做为一组事务进行处理，按组并行执行操作(每组操作为一个事务)，任意一组失败都会抛出异常，但之前成功的组不会因后续失败的组而异常回滚；若用户有较强烈的事务处理要求，可多次调用此接口，且每次accounts元素数量小于100，进行上层实现
	 * @param {done}   options.done  结果回调函数
	 * @return {Void}
	 *
	 * @callback
	 * @param {Object} error
	 * @param {Object} result  回调函数返回事件对象
	 * @param {StringArray} result.failedAccounts 订阅失败的accounts数组，数组长度为0则全部成功
	 *
	 * @example
	 * nim.subscribeEvent({
	 *     type: 100000,
	 *     accounts: ['cs3'],
	 *     subscribeTime: 70,
	 *     sync: true,
	 *     done: subscribeEventDone
	 * });
	 * function subscribeEventDone(error, obj) {
	 *     console.log('订阅事件' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.subscribeEvent = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'accounts');
	  // 默认更新后同步吧
	  var msgEventSubscribe = new MsgEventSubscribe(options);
	  util.verifyParamType('accounts', options.accounts, 'array');
	  self.processCallback(options);
	  msgEventSubscribe = msgEventSubscribe.assembleEvent();
	  // this.sendCmd('subscribeEvent', {msgEventSubscribe, accounts: options.accounts}, options.callback)
	  this.batchSendEventsCmds('subscribeEvent', { msgEventSubscribe: msgEventSubscribe, accounts: options.accounts }, function (err, obj) {
	    if (!err && obj) {
	      obj = { failedAccounts: obj };
	    }
	    options.callback(err, obj);
	  });
	};
	/**
	 * 按账号取消指定事件的订阅关系
	 *
	 * @method unSubscribeEventsByAccounts
	 * @memberOf NIM#
	 *
	 * @param {Object} options    配置参数
	 * @param {Int}    options.type  事件类型 必须指定100000以上 由上层做自定义映射
	 * @param {Array} options.accounts 取消订阅好友的账号列表。当accounts元素数量大于100时，SDK会以每100个帐号做为一组事务进行处理，按组并行执行操作(每组操作为一个事务)，任意一组失败都会抛出异常，但之前成功的组不会因后续失败的组而异常回滚；若用户有较强烈的事务处理要求，可多次调用此接口，且每次accounts元素数量小于100，进行上层实现
	 * @param {done}   options.done  结果回调函数
	 * @return {Void}
	 *
	 * @callback
	 * @param {Object} error
	 * @param {Object} result  回调函数返回事件对象
	 * @param {StringArray} result.failedAccounts 订阅失败的accounts数组，数组长度为0则全部成功
	 *
	 * @example
	 * nim.unSubscribeEventsByAccounts({
	 *     type: 100000,
	 *     accounts: ['cs3'],
	 *     done: unSubscribeEventDone
	 * });
	 * function unSubscribeEventDone(error, obj) {
	 *     console.log('取消订阅事件' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.unSubscribeEventsByAccounts = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'accounts');
	  util.verifyParamType('accounts', options.accounts, 'array');
	  var msgEventSubscribe = new MsgEventSubscribe(options);
	  msgEventSubscribe = msgEventSubscribe.assembleEvent();
	  self.processCallback(options);
	  // this.sendCmd('unSubscribeEventsByAccounts', {msgEventSubscribe, accounts: options.accounts}, options.callback)
	  this.batchSendEventsCmds('unSubscribeEventsByAccounts', { msgEventSubscribe: msgEventSubscribe, accounts: options.accounts }, function (err, obj) {
	    if (!err && obj) {
	      obj = { failedAccounts: obj };
	    }
	    options.callback(err, obj);
	  });
	};
	/**
	 * 取消指定事件的全部订阅关系
	 *
	 * @method unSubscribeEventsByType
	 * @memberOf NIM#
	 *
	 * @param {Object} options    配置参数
	 * @param {Int}    options.type  事件类型 必须指定100000以上 由上层做自定义映射
	 * @param {done}   options.done  结果回调函数
	 * @return {Void}
	 *
	 * @callback
	 * @param {Object} error
	 *
	 * @example
	 * nim.unSubscribeEventsByType({
	 *     type: 100000,
	 *     done: unSubscribeEventDone
	 * });
	 * function unSubscribeEventDone(error, obj) {
	 *     console.log('取消订阅事件' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.unSubscribeEventsByType = function (options) {
	  var self = this;
	  var msgEventSubscribe = new MsgEventSubscribe(options);
	  msgEventSubscribe = msgEventSubscribe.assembleEvent();
	  self.processCallback(options);
	  this.sendCmdWithResp('unSubscribeEventsByType', { msgEventSubscribe: msgEventSubscribe }, function onUnSubscribeEventsByType(err, obj) {
	    options.callback(err);
	  });
	};
	/**
	 * 按账号获取指定事件的订阅关系
	 *
	 * @method querySubscribeEventsByAccounts
	 * @memberOf NIM#
	 *
	 * @param {Object} options    配置参数
	 * @param {Int}    options.type  事件类型 必须指定100000以上 由上层做自定义映射
	 * @param {Array} options.accounts 查询订阅好友的账号列表。当accounts元素数量大于100时，SDK会以每100个帐号做为一组事务进行处理，按组并行执行操作(每组操作为一个事务)，任意一组失败都会抛出异常，但之前成功的组不会因后续失败的组而异常回滚；若用户有较强烈的事务处理要求，可多次调用此接口，且每次accounts元素数量小于100，进行上层实现
	 * @param {done}   options.done  结果回调函数
	 * @return {Void}
	 *
	 * @callback
	 * @param {Object} error
	 * @param {Object} result  回调函数返回事件对象
	 * @param {ObjectArray} result.msgEventSubscribes 订阅的对象数组
	 * @param {String} result.msgEventSubscribes.subscribeTime 订阅关系有效时间
	 * @param {String} result.msgEventSubscribes.time 订阅时间
	 * @param {String} result.msgEventSubscribes.to 订阅人
	 * @param {String} result.msgEventSubscribes.type 订阅类型
	 *
	 * @example
	 * nim.querySubscribeEventsByAccounts({
	 *     type: 100000,
	 *     accounts: ['cs3'],
	 *     done: querySubscribeEventDone
	 * });
	 * function querySubscribeEventDone(error, obj) {
	 *     console.log('获取订阅列表' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.querySubscribeEventsByAccounts = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'accounts');
	  util.verifyParamType('accounts', options.accounts, 'array');
	  var msgEventSubscribe = new MsgEventSubscribe(options);
	  msgEventSubscribe = msgEventSubscribe.assembleEvent();
	  self.processCallback(options);
	  // this.sendCmd('querySubscribeEventsByAccounts', {msgEventSubscribe, accounts: options.accounts}, options.callback)
	  this.batchSendEventsCmds('querySubscribeEventsByAccounts', { msgEventSubscribe: msgEventSubscribe, accounts: options.accounts }, function (err, obj) {
	    if (!err && obj) {
	      obj = { msgEventSubscribes: obj };
	    }
	    options.callback(err, obj);
	  });
	};
	/**
	 * 查询指定事件的全部订阅关系
	 *
	 * @method querySubscribeEventsByType
	 * @memberOf NIM#
	 *
	 * @param {Object} options    配置参数
	 * @param {Int}    options.type  事件类型 必须指定100000以上 由上层做自定义映射
	 * @param {done}   options.done  结果回调函数
	 * @return {Void}
	 *
	 * @callback
	 * @param {Object} error
	 * @param {Object} result  回调函数返回事件对象
	 * @param {ObjectArray} result.msgEventSubscribes 订阅的对象数组
	 * @param {String} result.msgEventSubscribes.subscribeTime 订阅关系有效时间
	 * @param {String} result.msgEventSubscribes.time 订阅时间
	 * @param {String} result.msgEventSubscribes.to 订阅人
	 * @param {String} result.msgEventSubscribes.type 订阅类型
	 *
	 * @example
	 * nim.querySubscribeEventsByType({
	 *     type: 100000,
	 *     done: querySubscribeEventDone
	 * });
	 * function querySubscribeEventDone(error, obj) {
	 *     console.log('获取订阅列表' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.querySubscribeEventsByType = function (options) {
	  var self = this;
	  var msgEventSubscribe = new MsgEventSubscribe(options);
	  msgEventSubscribe = msgEventSubscribe.assembleEvent();
	  self.processCallback(options);
	  this.sendCmdWithResp('querySubscribeEventsByType', { msgEventSubscribe: msgEventSubscribe }, function onQuerySubscribeEventsByType(err, obj) {
	    if (!err) {
	      obj = { msgEventSubscribes: formatReturnEventObj(obj) };
	    }
	    options.callback(err, obj);
	  });
	};

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIMFn = __webpack_require__(6).fn;
	var util = __webpack_require__(1);
	var notundef = util.notundef;
	var Friend = __webpack_require__(57);

	/**
	 * 好友请求
	 *
	 * - 此接口可以完成以下四个功能, 通过参数`type`来决定实际的功能, `type`可取的值有以下几种
	 *     - `'addFriend'` (直接加为好友)
	 *         - {@link NIM#addFriend|直接加某个用户为好友}后, 对方不需要确认, 直接成为当前登录用户的好友。
	 *         - 对方会收到一条类型为`'addFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号。
	 *     - `'applyFriend'` (申请加为好友)
	 *         - {@link NIM#applyFriend|申请加某个用户为好友}后, 对方会收到一条类型为`'applyFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号, 用户在收到好友申请后, 可以选择通过或者拒绝好友申请。
	 *     - `'passFriendApply'` (通过好友申请)
	 *         - 如果{@link NIM#passFriendApply|通过好友申请}, 那么申请方会收到一条类型为`'passFriendApply'`的{@link SystemMessage.type|系统通知}, 此类群通知消息的`from`字段的值为通过方的帐号, `to`字段的值为申请方的账号。
	 *     - `'rejectFriendApply'` (拒绝好友申请)
	 *         - 如果{@link NIM#rejectFriendApply|拒绝好友申请}, 那么申请方会收到一条类型为`'rejectFriendApply'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为申请方的账号。
	 * - 每个功能SDK也提供了相应的独立接口
	 *
	 * @private
	 * @method friendRequest
	 * @memberOf NIM#
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.type    {@link Friend.requestType|好友请求类型}
	 * @param  {String} options.account 账号
	 * @param  {String} [options.ps]    附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
	 * @param  {done}   options.done    结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#rejectFriendApply|直接加为好友}
	 * @see {@link NIM#applyFriend|申请加为好友}
	 * @see {@link NIM#passFriendApply|通过好友申请}
	 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
	 * @see {@link NIM#deleteFriend|删除好友}
	 * @see {@link NIM#updateFriend|更新好友}
	 * @see {@link NIM#getFriends|获取好友列表}
	 */
	NIMFn.friendRequest = function (options) {
	  util.verifyOptions(options, 'type account');
	  util.verifyParamValid('type', options.type, Friend.validTypes());
	  this.processPs(options);
	  this.processCallback(options);
	  var content = {
	    account: options.account,
	    type: Friend.getByteFromType(options.type),
	    ps: options.ps
	  };
	  if (notundef(options.idServer)) {
	    content.idServer = options.idServer;
	  }
	  this.sendCmd('friendRequest', content, options.callback);
	};
	/**
	 * 直接加为好友
	 *
	 * - {@link NIM#addFriend|直接加某个用户为好友}后, 对方不需要确认, 直接成为当前登录用户的好友。
	 * - 对方会收到一条类型为`'addFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号。
	 *
	 * @method addFriend
	 * @memberOf NIM#
	 *
	 * @param {Object}  options         配置参数
	 * @param {String}  options.account 要直接加为好友的账号
	 * @param {String}  [options.ps]    附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
	 * @param {done}    options.done    结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#applyFriend|申请加为好友}
	 * @see {@link NIM#passFriendApply|通过好友申请}
	 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
	 * @see {@link NIM#deleteFriend|删除好友}
	 * @see {@link NIM#updateFriend|更新好友}
	 * @see {@link NIM#getFriends|获取好友列表}
	 *
	 * @example
	 * nim.addFriend({
	 *     account: 'account',
	 *     ps: 'ps',
	 *     done: addFriendDone
	 * });
	 * function addFriendDone(error, obj) {
	 *     console.log('直接加为好友' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         onAddFriend(obj.friend);
	 *     }
	 * }
	 */
	NIMFn.addFriend = function (options) {
	  options.type = 'addFriend';
	  this.friendRequest(options);
	};
	/**
	 * 申请加为好友
	 *
	 * - {@link NIM#applyFriend|申请加某个用户为好友}后, 对方会收到一条类型为`'applyFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号, 用户在收到好友申请后, 可以选择通过或者拒绝好友申请。
	 *     - 如果{@link NIM#passFriendApply|通过好友申请}, 那么申请方会收到一条类型为`'passFriendApply'`的{@link SystemMessage.type|系统通知}, 此类群通知消息的`from`字段的值为通过方的帐号, `to`字段的值为申请方的账号。
	 *     - 如果{@link NIM#rejectFriendApply|拒绝好友申请}, 那么申请方会收到一条类型为`'rejectFriendApply'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为申请方的账号。
	 *
	 * @method applyFriend
	 * @memberOf NIM#
	 *
	 * @param {Object}  options         配置参数
	 * @param {String}  options.account 要申请加为好友的账号
	 * @param {String}  [options.ps]    附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
	 * @param {done}    options.done    结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#applyFriend|直接加为好友}
	 * @see {@link NIM#passFriendApply|通过好友申请}
	 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
	 * @see {@link NIM#deleteFriend|删除好友}
	 * @see {@link NIM#updateFriend|更新好友}
	 * @see {@link NIM#getFriends|获取好友列表}
	 *
	 * @example
	 * nim.applyFriend({
	 *     account: 'account',
	 *     ps: 'ps',
	 *     done: applyFriendDone
	 * });
	 * function applyFriendDone(error, obj) {
	 *     console.log('申请加为好友' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.applyFriend = function (options) {
	  options.type = 'applyFriend';
	  this.friendRequest(options);
	};
	/**
	 * 通过好友申请
	 *
	 * - {@link NIM#applyFriend|申请加某个用户为好友}后, 对方会收到一条类型为`'applyFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号, 用户在收到好友申请后, 可以选择通过或者拒绝好友申请。
	 *     - 如果{@link NIM#passFriendApply|通过好友申请}, 那么申请方会收到一条类型为`'passFriendApply'`的{@link SystemMessage.type|系统通知}, 此类群通知消息的`from`字段的值为通过方的帐号, `to`字段的值为申请方的账号。
	 *     - 如果{@link NIM#rejectFriendApply|拒绝好友申请}, 那么申请方会收到一条类型为`'rejectFriendApply'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为申请方的账号。
	 *
	 * @method passFriendApply
	 * @memberOf NIM#
	 *
	 * @param {Object}  options             配置参数
	 * @param {String}  options.idServer    对应的系统通知的 `idServer`
	 * @param {String}  options.account     要通过好友申请的账号
	 * @param {String}  [options.ps]        附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
	 * @param {done}    options.done    结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#passFriendApply|直接加为好友}
	 * @see {@link NIM#applyFriend|申请加为好友}
	 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
	 * @see {@link NIM#deleteFriend|删除好友}
	 * @see {@link NIM#updateFriend|更新好友}
	 * @see {@link NIM#getFriends|获取好友列表}
	 *
	 * @example
	 * // 假设 sysMsg 是通过回调 `onsysmsg` 收到的系统通知
	 * nim.passFriendApply({
	 *     idServer: sysMsg.idServer,
	 *     account: 'account',
	 *     ps: 'ps',
	 *     done: passFriendApplyDone
	 * });
	 * function passFriendApplyDone(error, obj) {
	 *     console.log('通过好友申请' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         onAddFriend(obj.friend);
	 *     }
	 * }
	 */
	NIMFn.passFriendApply = function (options) {
	  util.verifyOptions(options, 'idServer');
	  options.type = 'passFriendApply';
	  this.friendRequest(options);
	};
	/**
	 * 拒绝好友申请
	 *
	 * - {@link NIM#applyFriend|申请加某个用户为好友}后, 对方会收到一条类型为`'applyFriend'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为接收方的账号, 用户在收到好友申请后, 可以选择通过或者拒绝好友申请。
	 *     - 如果{@link NIM#passFriendApply|通过好友申请}, 那么申请方会收到一条类型为`'passFriendApply'`的{@link SystemMessage.type|系统通知}, 此类群通知消息的`from`字段的值为通过方的帐号, `to`字段的值为申请方的账号。
	 *     - 如果{@link NIM#rejectFriendApply|拒绝好友申请}, 那么申请方会收到一条类型为`'rejectFriendApply'`的{@link SystemMessage.type|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为申请方的账号。
	 *
	 * @method rejectFriendApply
	 * @memberOf NIM#
	 *
	 * @param {Object}  options             配置参数
	 * @param {String}  options.idServer    对应的系统通知的 `idServer`
	 * @param {String}  options.account     要拒绝好友申请的账号
	 * @param {String}  [options.ps]        附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
	 * @param {done}    options.done    结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#rejectFriendApply|直接加为好友}
	 * @see {@link NIM#applyFriend|申请加为好友}
	 * @see {@link NIM#passFriendApply|通过好友申请}
	 * @see {@link NIM#deleteFriend|删除好友}
	 * @see {@link NIM#updateFriend|更新好友}
	 * @see {@link NIM#getFriends|获取好友列表}
	 *
	 * @example
	 * // 假设 sysMsg 是通过回调 `onsysmsg` 收到的系统通知
	 * nim.rejectFriendApply({
	 *     idServer: sysMsg.idServer,
	 *     account: 'account',
	 *     ps: 'ps',
	 *     done: rejectFriendApplyDone
	 * });
	 * function rejectFriendApplyDone(error, obj) {
	 *     console.log(error);
	 *     console.log(obj);
	 *     console.log('拒绝好友申请' + (!error?'成功':'失败'));
	 * }
	 */
	NIMFn.rejectFriendApply = function (options) {
	  util.verifyOptions(options, 'idServer');
	  options.type = 'rejectFriendApply';
	  this.friendRequest(options);
	};
	/**
	 * 删除好友
	 *
	 * - {@link NIM#deleteFriend|删除好友}后, 被删除的人会收到一条类型为`'deleteFriend'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为删除方的帐号, `to`字段的值为被删除方的账号。
	 *
	 * @method deleteFriend
	 * @memberOf NIM#
	 *
	 * @param {Object}  options         配置参数
	 * @param {String}  options.account 要删除好友的账号
	 * @param {done}    options.done    结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#deleteFriend|直接加为好友}
	 * @see {@link NIM#applyFriend|申请加为好友}
	 * @see {@link NIM#passFriendApply|通过好友申请}
	 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
	 * @see {@link NIM#updateFriend|更新好友}
	 * @see {@link NIM#getFriends|获取好友列表}
	 *
	 * @example
	 * nim.deleteFriend({
	 *     account: 'account',
	 *     done: deleteFriendDone
	 * });
	 * function deleteFriendDone(error, obj) {
	 *     console.log('删除好友' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         onDeleteFriend(obj.account);
	 *     }
	 * }
	 */
	NIMFn.deleteFriend = function (options) {
	  util.verifyOptions(options, 'account');
	  this.processCallback(options);
	  this.sendCmd('deleteFriend', { account: options.account }, options.callback);
	};
	/**
	 * 更新好友
	 *
	 * - 开发者可以用此接口来更新好友的备注
	 * - 开发者也可以使用JSON格式的扩展字段来进行扩展
	 *
	 * @method updateFriend
	 * @memberOf NIM#
	 *
	 * @param {Object}  options             配置参数
	 * @param {String}  options.account     要更新的好友的account
	 * @param {String}  [options.alias]     备注
	 * @param {String}  [options.custom]    扩展字段, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
	 * @param {done}    options.done        结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#updateFriend|直接加为好友}
	 * @see {@link NIM#applyFriend|申请加为好友}
	 * @see {@link NIM#passFriendApply|通过好友申请}
	 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
	 * @see {@link NIM#deleteFriend|删除好友}
	 * @see {@link NIM#getFriends|获取好友列表}
	 *
	 * @example
	 * nim.updateFriend({
	 *     account: 'account',
	 *     alias: 'alias',
	 *     custom: 'custom',
	 *     done: updateFriendDone
	 * });
	 * function updateFriendDone(error, obj) {
	 *     console.log('更新好友' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         onUpdateFriend(obj);
	 *     }
	 * }
	 */
	NIMFn.updateFriend = function (options) {
	  this.processCallback(options);
	  var friend = new Friend(options);
	  this.sendCmd('updateFriend', { friend: friend, single: true }, options.callback);
	};
	/**
	 * 获取好友列表
	 *
	 * - 如果开发者在{@link NIM|初始化SDK}的时候设置了`syncFriends`为`false`, 那么就收不到`onfriends`回调, 可以调用此接口来获取好友列表。
	 *
	 * @method getFriends
	 * @memberOf NIM#
	 *
	 * @param {Object}  options         配置参数
	 * @param {done}    options.done    结果回调函数, 成功的时候会收到{@link Friend|好友}列表
	 * @return {Void}
	 *
	 * @see {@link NIM#addFriend|直接加为好友}
	 * @see {@link NIM#applyFriend|申请加为好友}
	 * @see {@link NIM#passFriendApply|通过好友申请}
	 * @see {@link NIM#rejectFriendApply|拒绝好友申请}
	 * @see {@link NIM#deleteFriend|删除好友}
	 * @see {@link NIM#updateFriend|更新好友}
	 *
	 * @example
	 * nim.getFriends({
	 *     done: getFriendsDone
	 * });
	 * function getFriendsDone(error, friends) {
	 *     console.log('获取好友列表' + (!error?'成功':'失败'), error, friends);
	 *     if (!error) {
	 *         onFriends(friends);
	 *     }
	 * }
	 */
	NIMFn.getFriends = function (options) {
	  var self = this;
	  var db = self.db;
	  var timetag = 0;
	  util.verifyOptions(options);
	  self.processCallback(options);
	  if (db.enable) {
	    db.getFriendsTimetag().then(function (t) {
	      timetag = t;
	      getFriendsFromServer();
	    }, getFriendsFromServer);
	  } else {
	    getFriendsFromServer();
	  }
	  function getFriendsFromServer() {
	    self.sendCmd('getFriends', { timetag: timetag, NOTSTORE: 'timetag' }, options.callback);
	  }
	};

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIMFn = __webpack_require__(6).fn;
	var util = __webpack_require__(1);
	var isArray = util.isArray;
	var TeamMember = __webpack_require__(20);

	// util util.isArray util.mergeObjArray util.cutObjArray 和 [] 只应该出现一次
	NIMFn.mergeObjArray = function (olds, news, options) {
	  if (!olds) {
	    olds = [];
	  }
	  if (!news) {
	    return olds;
	  }
	  if (!isArray(news)) {
	    news = [news];
	  }
	  if (!news.length) {
	    return olds;
	  }
	  options = options || {};
	  return util.mergeObjArray(olds, news, options);
	};

	NIMFn.cutObjArray = function (olds, invalids, options) {
	  if (!olds) {
	    return olds;
	  }
	  if (!invalids) {
	    return olds;
	  }
	  if (!isArray(invalids)) {
	    invalids = [invalids];
	  }
	  if (!invalids.length) {
	    return olds;
	  }
	  options = options || {};
	  return util.cutObjArray(olds, invalids, options);
	};

	/**
	 * 合并登录端
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的登录端列表
	 * - 合并时按照 `deviceId` 的值去重，按照 `deviceId` 的值正序排序
	 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {olds = [];}
	 * if (!news) {return olds;}
	 * if (!NIM.util.isArray(news)) { news = [news]; }
	 * if (!news.length) {return olds;}
	 * var options = {
	 *     keyPath: 'deviceId'
	 * };
	 * NIM.util.mergeObjArray([], olds, news, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并登录端
	 *
	 * @method mergeLoginPorts
	 * @memberOf NIM#
	 *
	 * @param  {LoginPort[]}             olds    原始登录端数组
	 * @param  {LoginPort|LoginPort[]}    news    待合并的登录端或登录端数组
	 * @return {LoginPort[]}                     合并后的登录端数组
	 */
	NIMFn.mergeLoginPorts = function (olds, news) {
	  return this.mergeObjArray(olds, news, {
	    keyPath: 'deviceId'
	  });
	};

	/**
	 * 去除登录端
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的登录端列表
	 * - 去除时按照 `account` 的值去除
	 * - 此方法内部调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {return olds;}
	 * if (!invalids) {return olds;}
	 * if (!NIM.util.isArray(invalids)) { invalids = [invalids]; }
	 * if (!invalids.length) {return olds;}
	 * var options = {
	 *     keyPath: 'account'
	 * };
	 * NIM.util.cutObjArray(olds, invalids, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除登录端
	 *
	 * @method cutLoginPorts
	 * @memberOf NIM#
	 *
	 * @param  {LoginPort[]}             olds        原始登录端数组
	 * @param  {LoginPort|LoginPort[]}    invalids    待去除的登录端或登录端数组
	 * @return {LoginPort[]}                         去除后的登录端数组
	 */
	NIMFn.cutLoginPorts = function (olds, invalids) {
	  return this.cutObjArray(olds, invalids, {
	    keyPath: 'deviceId',
	    sortPath: 'type'
	  });
	};

	/**
	 * 合并关系
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的关系列表
	 * - 合并时按照 `account` 的值去重，按照 `account` 的值正序排序
	 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {olds = [];}
	 * if (!news) {return olds;}
	 * if (!NIM.util.isArray(news)) { news = [news]; }
	 * if (!news.length) {return olds;}
	 * var options = {
	 *     keyPath: 'account'
	 * };
	 * NIM.util.mergeObjArray([], olds, news, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并关系
	 *
	 * @method mergeRelations
	 * @memberOf NIM#
	 *
	 * @param  {Relation[]}             olds    原始关系数组
	 * @param  {Relation|Relation[]}    news    待合并的关系或关系数组
	 * @return {Relation[]}                     合并后的关系数组
	 */
	NIMFn.mergeRelations = function (olds, news) {
	  return this.mergeObjArray(olds, news, {
	    keyPath: 'account'
	  });
	};

	/**
	 * 去除关系
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的关系列表
	 * - 去除时按照 `account` 的值去除
	 * - 此方法内部调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {return olds;}
	 * if (!invalids) {return olds;}
	 * if (!NIM.util.isArray(invalids)) { invalids = [invalids]; }
	 * if (!invalids.length) {return olds;}
	 * var options = {
	 *     keyPath: 'account'
	 * };
	 * NIM.util.cutObjArray(olds, invalids, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除关系
	 *
	 * @method cutRelations
	 * @memberOf NIM#
	 *
	 * @param  {Relation[]}             olds        原始关系数组
	 * @param  {Relation|Relation[]}    invalids    待去除的关系或关系数组
	 * @return {Relation[]}                         去除后的关系数组
	 */
	NIMFn.cutRelations = function (olds, invalids) {
	  return this.cutObjArray(olds, invalids, {
	    keyPath: 'account'
	  });
	};

	/**
	 * 在关系数组里面根据 `account` 找到对应的关系
	 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
	 * ```
	 * NIM.util.findObjInArray(relations, {
	 *     keyPath: 'account',
	 *     value: account
	 * });
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个关系
	 *
	 * @method findRelation
	 * @memberOf NIM#
	 * @param  {Relation[]}     relations    关系数组
	 * @param  {String}         account     待查找的关系的 `account`
	 * @return {Relation|null}              对应的关系或者 null
	 */
	NIMFn.findRelation = function (relations, account) {
	  return util.findObjInArray(relations, {
	    keyPath: 'account',
	    value: account
	  });
	};

	/**
	 * 合并好友
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的好友列表
	 * - 合并时按照 `account` 的值去重，按照 `account` 的值正序排序
	 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {olds = [];}
	 * if (!news) {return olds;}
	 * if (!NIM.util.isArray(news)) { news = [news]; }
	 * if (!news.length) {return olds;}
	 * var options = {
	 *     keyPath: 'account'
	 * };
	 * NIM.util.mergeObjArray([], olds, news, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并好友
	 *
	 * @method mergeFriends
	 * @memberOf NIM#
	 *
	 * @param  {Friend[]}           olds    原始好友数组
	 * @param  {Friend|Friend[]}    news    待合并的好友或好友数组
	 * @return {Friend[]}                   合并后的好友数组
	 */
	NIMFn.mergeFriends = function (olds, news) {
	  return this.mergeObjArray(olds, news, {
	    keyPath: 'account'
	  });
	};

	/**
	 * 去除好友
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的好友列表
	 * - 去除时按照 `account` 的值去除
	 * - 此方法内部调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {return olds;}
	 * if (!invalids) {return olds;}
	 * if (!NIM.util.isArray(invalids)) { invalids = [invalids]; }
	 * if (!invalids.length) {return olds;}
	 * var options = {
	 *     keyPath: 'account'
	 * };
	 * NIM.util.cutObjArray(olds, invalids, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除好友
	 *
	 * @method cutFriends
	 * @memberOf NIM#
	 *
	 * @param  {Friend[]}             olds        原始好友数组
	 * @param  {Friend|Friend[]}    invalids    待去除的好友或好友数组
	 * @return {Friend[]}                         去除后的好友数组
	 */
	NIMFn.cutFriends = function (olds, invalids) {
	  return this.cutObjArray(olds, invalids, {
	    keyPath: 'account'
	  });
	};

	/**
	 * 去除`accounts`对应的好友
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的好友列表
	 * - 去除时按照 `account` 的值去除
	 * - 此方法内部调用 {@link NIM#cutFriends|nim.cutFriends} 来完成实际工作
	 * ```
	 * if (!NIM.util.isArray(accounts)) { accounts = [accounts]; }
	 * var invalids = accounts.map(function(account) {
	 *     return {
	 *         account: account
	 *     };
	 * });
	 * return nim.cutFriends(olds, invalids);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除好友
	 *
	 * @method cutFriendsByAccounts
	 * @memberOf NIM#
	 *
	 * @param  {Friend[]}           olds        原始好友数组
	 * @param  {Friend|Friend[]}    invalids    待去除的好友或好友数组
	 * @return {Friend[]}                       去除后的好友数组
	 */
	NIMFn.cutFriendsByAccounts = function (olds, accounts) {
	  if (!isArray(accounts)) {
	    accounts = [accounts];
	  }
	  var invalids = accounts.map(function (account) {
	    return {
	      account: account
	    };
	  });
	  return this.cutFriends(olds, invalids);
	};

	/**
	 * 在好友数组里面根据 `account` 找到对应的好友
	 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
	 * ```
	 * NIM.util.findObjInArray(friends, {
	 *     keyPath: 'account',
	 *     value: account
	 * });
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个好友
	 *
	 * @method findFriend
	 * @memberOf NIM#
	 * @param  {Friend[]}       friends     好友数组
	 * @param  {String}         account     待查找的好友的 `account`
	 * @return {Friend|null}                对应的好友或者 null
	 */
	NIMFn.findFriend = function (friends, account) {
	  return util.findObjInArray(friends, {
	    keyPath: 'account',
	    value: account
	  });
	};

	/**
	 * 合并名片
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的名片列表
	 * - 合并时按照 `account` 的值去重，按照 `account` 的值正序排序
	 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {olds = [];}
	 * if (!news) {return olds;}
	 * if (!NIM.util.isArray(news)) { news = [news]; }
	 * if (!news.length) {return olds;}
	 * var options = {
	 *     keyPath: 'account'
	 * };
	 * NIM.util.mergeObjArray([], olds, news, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并名片
	 *
	 * @method mergeUsers
	 * @memberOf NIM#
	 *
	 * @param  {User[]}         olds    原始名片数组
	 * @param  {User|User[]}    news    待合并的名片或名片数组
	 * @return {User[]}                 合并后的名片数组
	 */
	NIMFn.mergeUsers = function (olds, news) {
	  return this.mergeObjArray(olds, news, {
	    keyPath: 'account'
	  });
	};

	/**
	 * 在名片数组里面根据 `account` 找到对应的名片
	 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
	 * ```
	 * NIM.util.findObjInArray(users, {
	 *     keyPath: 'account',
	 *     value: account
	 * });
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个名片
	 *
	 * @method findUser
	 * @memberOf NIM#
	 * @param  {User[]}     users    名片数组
	 * @param  {String}     account  待查找的名片的 `account`
	 * @return {User|null}           对应的名片或者 null
	 */
	NIMFn.findUser = function (users, account) {
	  return util.findObjInArray(users, {
	    keyPath: 'account',
	    value: account
	  });
	};

	/**
	 * 合并群
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的群列表
	 * - 合并时按照 `teamId` 的值去重，按照 `teamId` 的值正序排序
	 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {olds = [];}
	 * if (!news) {return olds;}
	 * if (!NIM.util.isArray(news)) { news = [news]; }
	 * if (!news.length) {return olds;}
	 * var options = {
	 *     keyPath: 'teamId'
	 * };
	 * NIM.util.mergeObjArray([], olds, news, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并群
	 *
	 * @method mergeTeams
	 * @memberOf NIM#
	 *
	 * @param  {Team[]}         olds    原始群数组
	 * @param  {Team|Team[]}    news    待合并的群或群数组
	 * @return {Team[]}                 合并后的群数组
	 */
	NIMFn.mergeTeams = function (olds, news) {
	  return this.mergeObjArray(olds, news, {
	    keyPath: 'teamId'
	  });
	};

	/**
	 * 去除群
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的群列表
	 * - 去除时按照 `teamId` 的值去除
	 * - 此方法内部调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {return olds;}
	 * if (!invalids) {return olds;}
	 * if (!NIM.util.isArray(invalids)) { invalids = [invalids]; }
	 * if (!invalids.length) {return olds;}
	 * var options = {
	 *     keyPath: 'teamId'
	 * };
	 * NIM.util.cutObjArray(olds, invalids, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除群
	 *
	 * @method cutTeams
	 * @memberOf NIM#
	 *
	 * @param  {Team[]}         olds        原始群数组
	 * @param  {Team|Team[]}    invalids    待去除的群或群数组
	 * @return {Team[]}                     去除后的群数组
	 */
	NIMFn.cutTeams = function (olds, invalids) {
	  return this.cutObjArray(olds, invalids, {
	    keyPath: 'teamId'
	  });
	};

	/**
	 * 在群数组里面根据 `teamId` 找到对应的群
	 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
	 * ```
	 * NIM.util.findObjInArray(teams, {
	 *     keyPath: 'teamId',
	 *     value: teamId
	 * });
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个群
	 *
	 * @method findTeam
	 * @memberOf NIM#
	 * @param  {Team[]}      teams    群数组
	 * @param  {String}      teamId   待查找的群的 `teamId`
	 * @return {Team|null}            对应的群或者 null
	 */
	NIMFn.findTeam = function (teams, teamId) {
	  return util.findObjInArray(teams, {
	    keyPath: 'teamId',
	    value: teamId
	  });
	};

	NIMFn.assembleTeamOwner = TeamMember.assembleOwner;
	NIMFn.assembleTeamMembers = TeamMember.assembleMembers;
	NIMFn.genTeamMemberId = TeamMember.genId;

	/**
	 * 合并群成员
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的群成员列表
	 * - 合并时按照 `id` 的值去重，按照 `id` 的值正序排序
	 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {olds = [];}
	 * if (!news) {return olds;}
	 * if (!NIM.util.isArray(news)) { news = [news]; }
	 * if (!news.length) {return olds;}
	 * var options = {
	 * };
	 * NIM.util.mergeObjArray([], olds, news, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并群成员
	 *
	 * @method mergeTeamMembers
	 * @memberOf NIM#
	 *
	 * @param  {TeamMember[]}               olds    原始群成员数组
	 * @param  {TeamMember|TeamMember[]}    news    待合并的群成员或群成员数组
	 * @return {TeamMember[]}                       合并后的群成员数组
	 */
	NIMFn.mergeTeamMembers = function (olds, news) {
	  // keyPath 默认为 id
	  return this.mergeObjArray(olds, news);
	};

	/**
	 * 去除群成员
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的群成员列表
	 * - 去除时按照 `id` 的值去除
	 * - 此方法内部调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {return olds;}
	 * if (!invalids) {return olds;}
	 * if (!NIM.util.isArray(invalids)) { invalids = [invalids]; }
	 * if (!invalids.length) {return olds;}
	 * var options = {
	 * };
	 * NIM.util.cutObjArray(olds, invalids, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除群成员
	 *
	 * @method cutTeamMembers
	 * @memberOf NIM#
	 *
	 * @param  {TeamMember[]}               olds        原始群成员数组
	 * @param  {TeamMember|TeamMember[]}    invalids    待去除的群成员或群成员数组
	 * @return {TeamMember[]}                           去除后的群成员数组
	 */
	NIMFn.cutTeamMembers = function (olds, invalids) {
	  // keyPath 默认为 id
	  return this.cutObjArray(olds, invalids);
	};

	/**
	 * 去除`accounts`对应的群成员
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含去除后的群成员列表
	 * - 去除时按照 `account` 的值去除
	 * - 此方法内部调用 {@link NIM#cutTeamMembers|nim.cutTeamMembers} 来完成实际工作
	 * ```
	 * if (!NIM.util.isArray(accounts)) { accounts = [accounts]; }
	 * var invalids = TeamMember.assembleMembers({
	 *     teamId: teamId
	 * }, accounts);
	 * return nim.cutTeamMembers(olds, invalids);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.cutObjArray|NIM.util.cutObjArray} 来去除群成员
	 *
	 * @method cutTeamMembersByAccounts
	 * @memberOf NIM#
	 *
	 * @param  {TeamMember[]}               olds        原始群成员数组
	 * @param  {TeamMember|TeamMember[]}    invalids    待去除的群成员或群成员数组
	 * @return {TeamMember[]}                           去除后的群成员数组
	 */
	NIMFn.cutTeamMembersByAccounts = function (olds, teamId, accounts) {
	  if (!isArray(accounts)) {
	    accounts = [accounts];
	  }
	  var invalids = TeamMember.assembleMembers({
	    teamId: teamId
	  }, accounts);
	  return this.cutTeamMembers(olds, invalids);
	};

	/**
	 * 在群成员数组里面根据 `id` 找到对应的群成员
	 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
	 * ```
	 * NIM.util.findObjInArray(members, {
	 *     keyPath: 'id',
	 *     value: id
	 * });
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个群成员
	 *
	 * @method findTeamMember
	 * @memberOf NIM#
	 * @param  {TeamMember[]}       members     群成员数组
	 * @param  {String}             id          待查找的群成员的 `id`
	 * @return {TeamMember|null}                对应的群成员或者 null
	 */
	NIMFn.findTeamMember = function (members, id) {
	  return util.findObjInArray(members, {
	    keyPath: 'id',
	    value: id
	  });
	};

	/**
	 * 合并会话
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的会话列表
	 * - 合并时按照 `id` 的值去重，按照 `updateTime` 的值倒序排序
	 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {olds = [];}
	 * if (!news) {return olds;}
	 * if (!NIM.util.isArray(news)) { news = [news]; }
	 * if (!news.length) {return olds;}
	 * var options = {
	 *     sortPath: 'updateTime',
	 *     desc: true
	 * };
	 * NIM.util.mergeObjArray([], olds, news, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并会话
	 *
	 * @method mergeSessions
	 * @memberOf NIM#
	 *
	 * @param  {Session[]}          olds    原始会话数组
	 * @param  {Session|Session[]}  news    待合并的会话或会话数组
	 * @return {Session[]}                  合并后的会话数组
	 */
	NIMFn.mergeSessions = function (olds, news) {
	  return this.mergeObjArray(olds, news, {
	    sortPath: 'updateTime',
	    desc: true
	  });
	};

	NIMFn.cutSessions = function (olds, invalids) {
	  return this.cutObjArray(olds, invalids);
	};

	NIMFn.cutSessionsByIds = function (olds, ids) {
	  if (!isArray(ids)) {
	    ids = [ids];
	  }
	  var invalids = ids.map(function (id) {
	    return { id: id };
	  });
	  return this.cutSessions(olds, invalids);
	};

	/**
	 * 在会话数组里面根据 `id` 找到对应的会话
	 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
	 * ```
	 * NIM.util.findObjInArray(sessions, {
	 *     keyPath: 'id',
	 *     value: sessionId
	 * });
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个会话
	 *
	 * @method findSession
	 * @memberOf NIM#
	 * @param  {Session[]}      sessions    会话数组
	 * @param  {String}         sessionId   待查找的会话的 `id`
	 * @return {Session|null}               对应的会话或者 null
	 */
	NIMFn.findSession = function (sessions, sessionId) {
	  return util.findObjInArray(sessions, {
	    keyPath: 'id',
	    value: sessionId
	  });
	};

	/**
	 * 合并消息
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的消息列表
	 * - 合并时按照 `idClient` 的值去重，按照 `time` 的值排序
	 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {olds = [];}
	 * if (!news) {return olds;}
	 * if (!NIM.util.isArray(news)) { news = [news]; }
	 * if (!news.length) {return olds;}
	 * var options = {
	 *     keyPath: 'idClient',
	 *     sortPath: 'time'
	 * };
	 * NIM.util.mergeObjArray([], olds, news, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并消息
	 *
	 * @method mergeMsgs
	 * @memberOf NIM#
	 *
	 * @param  {Message[]}          olds    原始消息数组
	 * @param  {Message|Message[]}  news    待合并的消息或消息数组
	 * @return {Message[]}                  合并后的消息数组
	 */
	NIMFn.mergeMsgs = function (olds, news) {
	  return this.mergeObjArray(olds, news, {
	    keyPath: 'idClient',
	    sortPath: 'time'
	  });
	};

	NIMFn.cutMsgs = function (olds, invalids) {
	  return this.cutObjArray(olds, invalids, {
	    keyPath: 'idClient'
	  });
	};

	NIMFn.cutMsgsByIdClients = function (olds, idClients) {
	  if (!isArray(idClients)) {
	    idClients = [idClients];
	  }
	  var invalids = idClients.map(function (idClient) {
	    return { idClient: idClient };
	  });
	  return this.cutMsgs(olds, invalids);
	};

	/**
	 * 在消息数组里面根据 `idClient` 找到对应的消息
	 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
	 * ```
	 * NIM.util.findObjInArray(msgs, {
	 *     keyPath: 'idClient',
	 *     value: idClient
	 * });
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个消息
	 *
	 * @method findMsg
	 * @memberOf NIM#
	 * @param  {Message[]}      msgs        消息数组
	 * @param  {String}         idClient    待查找的消息的 `idClient`
	 * @return {Message|null}               对应的消息或者 null
	 */
	NIMFn.findMsg = function (msgs, idClient) {
	  return util.findObjInArray(msgs, {
	    keyPath: 'idClient',
	    value: idClient
	  });
	};

	/**
	 * 合并系统通知
	 * - 此方法不会改变参数的值，而是会返回新的数组，包含合并后的系统通知列表
	 * - 合并时按照 `idServer` 的值去重，按照 `idServer` 的值倒序排序
	 * - 此方法内部调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来完成实际工作
	 * ```
	 * if (!olds) {olds = [];}
	 * if (!news) {return olds;}
	 * if (!NIM.util.isArray(news)) { news = [news]; }
	 * if (!news.length) {return olds;}
	 * var options = {
	 *     keyPath: 'idServer',
	 *     desc: true
	 * };
	 * NIM.util.mergeObjArray([], olds, news, options);
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.mergeObjArray|NIM.util.mergeObjArray} 来合并系统通知
	 *
	 * @method mergeSysMsgs
	 * @memberOf NIM#
	 *
	 * @param  {SystemMessage[]}                olds    原始系统通知数组
	 * @param  {SystemMessage|SystemMessage[]}  news    待合并的系统通知或系统通知数组
	 * @return {SystemMessage[]}                        合并后的系统通知数组
	 */
	NIMFn.mergeSysMsgs = function (olds, news) {
	  return this.mergeObjArray(olds, news, {
	    keyPath: 'idServer',
	    desc: true
	  });
	};

	NIMFn.cutSysMsgs = function (olds, invalids) {
	  return this.cutObjArray(olds, invalids, {
	    keyPath: 'idServer'
	  });
	};

	NIMFn.cutSysMsgsByIdServers = function (olds, idServers) {
	  if (!isArray(idServers)) {
	    idServers = [idServers];
	  }
	  var invalids = idServers.map(function (idServer) {
	    return { idServer: idServer };
	  });
	  return this.cutSysMsgs(olds, invalids);
	};

	/**
	 * 在系统通知数组里面根据 `idServer` 找到对应的系统通知
	 * - 此方法内部调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来完成实际工作
	 * ```
	 * NIM.util.findObjInArray(sysMsgs, {
	 *     keyPath: 'idServer',
	 *     value: idServer
	 * });
	 * ```
	 * - 如果此方法不满足开发者的业务需求，那么开发者可以根据自己的业务需求调用 {@link util.findObjInArray|NIM.util.findObjInArray} 来查找某个系统通知
	 *
	 * @method findSysMsg
	 * @memberOf NIM#
	 * @param  {SystemMessage[]}    sysMsgs     系统通知数组
	 * @param  {String}             idServer    待查找的系统通知的 `idServer`
	 * @return {SystemMessage|null}             对应的系统通知或者 null
	 */
	NIMFn.findSysMsg = function (sysMsgs, idServer) {
	  return util.findObjInArray(sysMsgs, {
	    keyPath: 'idServer',
	    value: idServer
	  });
	};

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIMFn = __webpack_require__(6).fn;
	var util = __webpack_require__(1);
	var undef = util.undef;
	var notundef = util.notundef;
	var device = __webpack_require__(12);
	var Session = __webpack_require__(24);
	var SystemMessage = __webpack_require__(25);
	var NIMError = __webpack_require__(4);

	/**
	 * 发送文本消息
	 *
	 * - 文本消息是消息的一种, 请参考{@link IMMessage|消息}
	 *
	 * @memberOf NIM#
	 * @method sendText
	 *
	 * @param  {Object}             options                         配置参数
	 * @param  {String}             options.scene                   {@link IMMessage.scene|场景}
	 * @param  {String}             options.to                      接收方, 对方帐号或者群id
	 * @param  {String}             options.text                    文本消息内容
	 * @param  {Boolean}            [options.resend]                是否是重发
	 * @param  {String}             [options.idClient]              如果是重发, 那么需要带上之前生成的idClient来标记这条消息
	 * @param  {String}             [options.custom]                扩展字段
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @param  {String}             [options.pushContent]           自定义推送文案
	 * @param  {String}             [options.pushPayload]           自定义的推送属性
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @param  {Boolean}            [options.needPushNick=true]     是否需要推送昵称
	 * @param {Object}   [apns]          特殊推送选项, 只在群会话中使用
	 * @param {String[]} [apns.accounts] 需要特殊推送的账号列表, 不填表示推送给当前会话内的所有用户
	 * @param {String}   [apns.content]  需要特殊推送的文案, 不填的话默认为 pushContent
	 * @param {String}   [apns.forcePush=true] 是否强制推送, true 表示即使推送列表中的胡勇屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
	 * @param  {Boolean}            [options.isHistoryable=true]    是否存储云端历史
	 * @param  {Boolean}            [options.isRoamingable=true]    是否支持漫游
	 * @param  {Boolean}            [options.isSyncable=true]       是否支持发送者多端同步
	 * @param  {Boolean}            [options.cc]                    是否支持抄送
	 * @param  {Boolean}            [options.isPushable=true]       是否需要推送
	 * @param  {Boolean}            [options.isOfflinable=true]     是否要存离线
	 * @param  {Boolean}            [options.isUnreadable=true]     是否计入消息未读数
	 * @param {Boolean} [options.isLocal=false] 是否是本地消息
	 * - `true`表示本地消息, 那么SDK并不会发送此条消息, 而是直接调用回调表示发送成功, 并更新对应的会话
	 * @param  {Boolean}            [options.yidunEnable = false]   是否需要过易盾反垃圾
	 * @param  {String}             [options.antiSpamContent] 在开启yidunEnable后, 开发者自定义的反垃圾字段（json格式)，格式如下：{"type": 1, "data": "custom content"} 字段说明：type:1.文本，2.图片，3视频，data内容:文本内容or图片地址or视频地址
	 * @param  {done}               options.done                    结果回调函数
	 * @return {Message}                                            {@link IMMessage|消息}
	 *
	 * @example
	 * var msg = nim.sendText({
	 *     scene: 'p2p',
	 *     to: 'account',
	 *     text: 'hello',
	 *     done: sendMsgDone
	 * });
	 * console.log('正在发送p2p text消息, id=' + msg.idClient);
	 * pushMsg(msg);
	 * function sendMsgDone(error, msg) {
	 *     console.log('发送' + msg.scene + ' ' + msg.type + '消息' + (!error?'成功':'失败') + ', id=' + msg.idClient, error, msg);
	 * }
	 */

	/**
	 * 文件上传进度回调
	 * @private
	 * @callback uploadprogress
	 * @param {Object} obj                  进度信息
	 * @param {Number} obj.total            文件总大小
	 * @param {Number} obj.loaded           已经上传的大小
	 * @param {Number} obj.percentage       上传百分比
	 * @param {String} obj.percentageText   上传百分比的文字表示
	 * @see {@link NIM#previewFile|预览文件}
	 * @see {@link NIM#sendFile|发送文件消息}
	 */

	/**
	 * 预览文件
	 *
	 * - 开发者可以预览文件, 支持以下几种场景
	 *     - 通过参数`fileInput`传入文件选择 dom 节点或者节点 ID, SDK 会读取该节点下的文件, 在上传完成前请不要操作该节点下的文件
	 *     - 通过参数`blob`传入 Blob 对象
	 *     - 通过参数`dataURL`传入包含 MIME type 和 base64 数据的 data URL, 此用法需要浏览器支持 Blob
	 * - SDK会将文件上传到文件服务器, 然后将拿到的文件对象在`done`回调中传给开发者, 文件对象有以下几种
	 *     - {@link Image|图片对象}
	 *     - {@link Audio|音频对象}
	 *     - {@link Video|视频对象}
	 *     - {@link File|文件对象}
	 * - 开发者在拿到文件对象之后, 可以调用{@link NIM#sendFile|发送文件消息}来发送文件消息。
	 * - 文件大小限制为最大 100M
	 *     - 高级浏览器会在上传前就检测文件大小
	 *     - IE8/IE9 会在上传完成后检测文件大小
	 *
	 * @memberOf NIM#
	 * @method previewFile
	 *
	 * @param  {Object}         options                     配置参数
	 * @param  {String}         [options.type]              文件过滤器
	 * - image会过滤掉非图片的文件, audio过滤掉非音频, video会过滤掉非视频的文件
	 * - IE8/IE9 不支持文件过滤
	 * @param  {String|Node}    [options.fileInput]         文件选择 dom 节点或者节点 ID, SDK 会读取该节点下的文件, 在上传完成前请不要操作该节点下的文件
	 * @param  {Blob}           [options.blob]              Blob 对象
	 * @param  {String}         [options.dataURL]           包含 MIME type 和 base64 数据的 data URL
	 * @param  {uploadprogress} [options.uploadprogress]    上传进度, ie9以下不支持上传进度
	 * @param  {done}           options.done                结果回调函数, 成功时会收到文件对象, 请参考
	 * - {@link Image|图片对象}
	 * - {@link Audio|音频对象}
	 * - {@link Video|视频对象}
	 * - {@link File|文件对象}
	 * @return {Void}
	 *
	 * @example
	 * nim.previewFile({
	 *     type: 'image',
	 *     fileInput: fileInput,
	 *     uploadprogress: function(obj) {
	 *         console.log('文件总大小: ' + obj.total + 'bytes');
	 *         console.log('已经上传的大小: ' + obj.loaded + 'bytes');
	 *         console.log('上传进度: ' + obj.percentage);
	 *         console.log('上传进度文本: ' + obj.percentageText);
	 *     },
	 *     done: function(error, file) {
	 *         console.log('上传image' + (!error?'成功':'失败'));
	 *         // show file to the user
	 *         if (!error) {
	 *             var msg = nim.sendFile({
	 *                 scene: 'p2p',
	 *                 to: 'account',
	 *                 file: file,
	 *                 done: sendMsgDone
	 *             });
	 *             console.log('正在发送p2p image消息, id=' + msg.idClient);
	 *             pushMsg(msg);
	 *         }
	 *     }
	 * });
	 */

	/**
	 * 上传完成回调
	 * @private
	 * @callback uploaddone
	 * @param {NIMError}    error   是否出错
	 * @param {Object}      file    上传成功时会包含文件对象, 请参考
	 *                              {@link Image|图片对象}
	 *                              {@link Audio|音频对象}
	 *                              {@link Video|视频对象}
	 *                              {@link File|文件对象}
	 * @see {@link NIM#sendFile|发送文件消息}
	 */

	/**
	 * 发送文件消息之前的回调函数
	 * @private
	 * @callback beforesend
	 * @param {String} idClient SDK生成的ID
	 * @see {@link NIM#sendFile|发送文件消息}
	 */

	/**
	 * 发送文件消息
	 *
	 * - 文件消息是{@link IMMessage.type|消息类型}的一种
	 * - 开发者可以直接发送文件消息
	 *     - 支持以下几种场景
	 *         - 通过参数`fileInput`传入文件选择 dom 节点或者节点 ID, SDK 会读取该节点下的文件, 在上传完成前请不要操作该节点下的文件
	 *         - 通过参数`blob`传入 Blob 对象
	 *         - 通过参数`dataURL`传入包含 MIME type 和 base64 数据的 data URL, 此用法需要浏览器支持 Blob
	 *     - SDK会先将文件上传到文件服务器, 然后把拿到的文件对象在`uploaddone`回调中传给用户, 然后将其拼装成文件消息发送出去。
	 * - 开发者也可以先{@link NIM#previewFile|预览文件}来获取文件对象, 然后调用此接口发送文件消息。
	 *     - 通过参数`file`传入文件
	 * - 直接发送文件消息的话会在`beforesend`回调里面传入SDK生成的`idClient`, 如果先预览文件再发送, 那么此接口会直接返回`idClient`
	 * - 参数`type`指定了要发送的文件类型, 包括图片、音频、视频和普通文件, 对应的值分别为`'image'`、`'audio'`、`'video'`和`'file'`, 不传默认为`'file'`。
	 * - 图片、音频、视频和普通文件的区别在于具体的文件信息不一样, 具体字段请参考
	 *     - {@link Image|图片对象}
	 *     - {@link Audio|音频对象}
	 *     - {@link Video|视频对象}
	 *     - {@link File|文件对象}
	 *     - {@link Robot|机器人对象}
	 * - 文件大小限制为最大100M
	 *     - 高级浏览器会在上传前就检测文件大小
	 *     - IE8和IE9会在上传完成后检测文件大小
	 *
	 * @memberOf NIM#
	 * @method sendFile
	 *
	 * @param  {Object}         options                         配置参数
	 * @param  {String}         options.scene                   {@link IMMessage.scene|场景}
	 * @param  {String|Number}  options.to                      接收方, 对方帐号或者群id
	 * @param  {String}         [options.type]                  文件过滤器,
	 *                                                          `'image'`会过滤掉非图片的文件, `'audio'`过滤掉非音频, `'video'`会过滤掉非视频的文件,
	 *                                                          IE8/IE9 不支持文件过滤
	 * @param  {String|Node}    [options.fileInput]             文件选择 dom 节点或者节点 ID, SDK 会读取该节点下的文件, 在上传完成前请不要操作该节点下的文件
	 * @param  {Blob}           [options.blob]                  Blob 对象
	 * @param  {String}         [options.dataURL]               MIME type 和 base64 数据的 data URL
	 * @param  {Array}          [options.file]                  文件对象, 开发者可以通过{@link NIM#previewFile|预览文件}拿到文件对象
	 * @param {String} [options.wxFilePath] 仅供微信小程序使用, 通过 wx.chooseImage 或者 wx.startRecord 拿到的临时文件路径
	 * @param  {Boolean}        [options.resend=false]          是否是重发
	 * @param  {Function}       [options.beginupload]           开始上传图片的回调
	 * - 如果开发者传入 fileInput, 在此回调之前不能修改 fileInput
	 * - 在此回调之后可以取消图片上传, 此回调会接收一个参数 `upload`, 调用 `upload.abort();` 来取消文件上传
	 * @param  {uploadprogress} [options.uploadprogress]        上传进度, IE9以下不支持上传进度
	 * @param  {uploaddone}     [options.uploaddone]            上传完成回调
	 * - 此回调接收两个参数, error 和 obj
	 * - 如果出错, error 包含详细的错误信息
	 * - 如果上传成功, obj 包含详细的文件信息
	 * @param  {beforesend}     [options.beforesend]            发送文件消息之前的回调函数
	 * @param  {Boolean}        [options.resend]                是否是重发
	 * @param  {String}         [options.idClient]              如果是重发, 那么需要带上之前生成的idClient来标记这条消息
	 * @param  {String}         [options.custom]                扩展字段
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @param  {String}         [options.pushContent]           自定义推送文案
	 * @param  {String}         [options.pushPayload]           自定义的推送属性
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @param {Object}   [apns]          特殊推送选项, 只在群会话中使用
	 * @param {String[]} [apns.accounts] 需要特殊推送的账号列表, 不填表示推送给当前会话内的所有用户
	 * @param {String}   [apns.content]  需要特殊推送的文案, 不填的话默认为 pushContent
	 * @param {String}   [apns.forcePush=true] 是否强制推送, true 表示即使推送列表中的胡勇屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
	 * @param  {Boolean}        [options.isHistoryable=true]    是否存储云端历史
	 * @param  {Boolean}        [options.isRoamingable=true]    是否支持漫游
	 * @param  {Boolean}        [options.isSyncable=true]       是否支持发送者多端同步
	 * @param  {Boolean}        [options.cc]                    是否支持抄送
	 * @param  {Boolean}        [options.isPushable=true]       是否需要推送
	 * @param  {Boolean}        [options.isOfflinable=true]     是否要存离线
	 * @param  {Boolean}        [options.isUnreadable=true]     是否计入消息未读数
	 * @param  {Boolean}        [options.needPushNick=true]     是否需要推送昵称
	 * @param {Boolean} [options.isLocal=false] 是否是本地消息
	 * - `true`表示本地消息, 那么SDK并不会发送此条消息, 而是直接调用回调表示发送成功, 并更新对应的会话
	 * @param  {done}           options.done                结果回调函数
	 * @return {Void|Message}
	 * - 如果提供了参数fileInput, 那么先上传文件到服务器再发送, 不会返回{@link IMMessage|消息}, 会在beforesend里面返回{@link IMMessage|消息}.
	 * - 如果提供了参数file, 那么直接发送文件消息, 返回{@link IMMessage|消息}
	 *
	 * @example
	 * nim.sendFile({
	 *     scene: 'p2p',
	 *     to: 'account',
	 *     type: 'image',
	 *     fileInput: fileInput,
	 *     uploadprogress: function(obj) {
	 *         console.log('文件总大小: ' + obj.total + 'bytes');
	 *         console.log('已经上传的大小: ' + obj.loaded + 'bytes');
	 *         console.log('上传进度: ' + obj.percentage);
	 *         console.log('上传进度文本: ' + obj.percentageText);
	 *     },
	 *     uploaddone: function(error, file) {
	 *         console.log('上传' + (!error?'成功':'失败'), error, file);
	 *     },
	 *     beforesend: function(msg) {
	 *         console.log('正在发送p2p image消息, id=' + msg.idClient);
	 *         pushMsg(msg);
	 *     },
	 *     done: sendMsgDone
	 * });
	 */

	/**
	 * 发送自定义消息
	 *
	 * - 自定义消息是{@link IMMessage.type|消息类型}的一种
	 * - 下面的代码用自定义消息实现了`石头剪刀布`游戏
	 *
	 * @memberOf NIM#
	 * @method sendCustomMsg
	 *
	 * @param  {Object}         options                         配置参数
	 * @param  {String}         options.scene                   {@link IMMessage.scene|场景}
	 * @param  {String|Number}  options.to                      接收方, 对方帐号或者群id
	 * @param  {String}         options.content                 自定义消息的消息内容, 推荐使用JSON格式构建
	 * @param  {Boolean}        [options.resend]                是否是重发
	 * @param  {String}         [options.idClient]              如果是重发, 那么需要带上之前生成的idClient来标记这条消息
	 * @param  {String}         [options.custom]                扩展字段
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @param  {String}         [options.pushContent]           自定义推送文案
	 * @param  {String}         [options.pushPayload]           自定义的推送属性
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @param {Object}   [apns]          特殊推送选项, 只在群会话中使用
	 * @param {String[]} [apns.accounts] 需要特殊推送的账号列表, 不填表示推送给当前会话内的所有用户
	 * @param {String}   [apns.content]  需要特殊推送的文案, 不填的话默认为 pushContent
	 * @param {String}   [apns.forcePush=true] 是否强制推送, true 表示即使推送列表中的胡勇屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
	 * @param  {Boolean}        [options.isHistoryable=true]    是否存储云端历史
	 * @param  {Boolean}        [options.isRoamingable=true]    是否支持漫游
	 * @param  {Boolean}        [options.isSyncable=true]       是否支持发送者多端同步
	 * @param  {Boolean}        [options.cc]                    是否支持抄送
	 * @param  {Boolean}        [options.isPushable=true]       是否需要推送
	 * @param  {Boolean}        [options.isOfflinable=true]     是否要存离线
	 * @param  {Boolean}        [options.isUnreadable=true]     是否计入消息未读数
	 * @param  {Boolean}        [options.needPushNick=true]     是否需要推送昵称
	 * @param {Boolean} [options.isLocal=false] 是否是本地消息
	 * - `true`表示本地消息, 那么SDK并不会发送此条消息, 而是直接调用回调表示发送成功, 并更新对应的会话
	 * @return {Message}                            {@link IMMessage|消息}
	 *
	 * @example
	 * var value = Math.ceil(Math.random()*3);
	 * var content = {
	 *     type: 1,
	 *     data: {
	 *         value: value
	 *     }
	 * };
	 * var msg = nim.sendCustomMsg({
	 *     scene: 'p2p',
	 *     to: 'account',
	 *     content: JSON.stringify(content),
	 *     done: sendMsgDone
	 * });
	 * console.log('正在发送p2p自定义消息, id=' + msg.idClient);
	 * pushMsg(msg);
	 */

	/**
	 * 发送地理位置消息
	 *
	 * - 地理位置消息是{@link IMMessage.type|消息类型}的一种, `geo`参数请参考{@link Geo|地理位置对象}
	 *
	 * @method sendGeo
	 * @memberOf NIM#
	 *
	 * @param  {Object}         options                         配置参数
	 * @param  {String}         options.scene                   {@link IMMessage.scene|场景}
	 * @param  {String|Number}  options.to                      接收方, 对方帐号或者群id
	 * @param  {Object}         options.geo                     地理位置对象
	 * @param  {Number}         options.geo.lng                 经度
	 * @param  {Number}         options.geo.lat                 纬度
	 * @param  {String}         options.geo.title               地址描述
	 * @param  {Boolean}        [options.resend]                是否是重发
	 * @param  {String}         [options.idClient]              如果是重发, 那么需要带上之前生成的idClient来标记这条消息
	 * @param  {String}         [options.custom]                扩展字段
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @param  {String}         [options.pushContent]           自定义推送文案
	 * @param  {String}         [options.pushPayload]           自定义的推送属性
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @param {Object}   [apns]          特殊推送选项, 只在群会话中使用
	 * @param {String[]} [apns.accounts] 需要特殊推送的账号列表, 不填表示推送给当前会话内的所有用户
	 * @param {String}   [apns.content]  需要特殊推送的文案, 不填的话默认为 pushContent
	 * @param {String}   [apns.forcePush=true] 是否强制推送, true 表示即使推送列表中的用户屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
	 * @param  {Boolean}        [options.isHistoryable=true]    是否存储云端历史
	 * @param  {Boolean}        [options.isRoamingable=true]    是否支持漫游
	 * @param  {Boolean}        [options.isSyncable=true]       是否支持发送者多端同步
	 * @param  {Boolean}        [options.cc]                    是否支持抄送
	 * @param  {Boolean}        [options.isPushable=true]       是否需要推送
	 * @param  {Boolean}        [options.isOfflinable=true]     是否要存离线
	 * @param  {Boolean}        [options.isUnreadable=true]     是否计入消息未读数
	 * @param  {Boolean}        [options.needPushNick=true]     是否需要推送昵称
	 * @param {Boolean} [options.isLocal=false] 是否是本地消息
	 * - `true`表示本地消息, 那么SDK并不会发送此条消息, 而是直接调用回调表示发送成功, 并更新对应的会话
	 * @return {Message}                            {@link IMMessage|消息}
	 *
	 * @example
	 * var msg = nim.sendGeo({
	 *     scene: 'p2p',
	 *     to: 'account',
	 *     geo: {
	 *         lng: '116.3833',
	 *         lat: '39.9167',
	 *         title: 'Beijing'
	 *     },
	 *     done: sendMsgDone
	 * });
	 * console.log('正在发送p2p geo消息, id=' + msg.idClient);
	 * pushMsg(msg);
	 */

	/**
	 * 发送提醒消息
	 *
	 * - 提醒消息是{@link IMMessage.type|消息类型}的一种
	 * - 提醒消息用于会话内的状态提醒，如进入会话时出现的欢迎消息，或者会话命中敏感词后的提示消息等等.
	 *
	 * @method sendTipMsg
	 * @memberOf NIM#
	 *
	 * @param  {Object}         options                         配置参数
	 * @param  {String}         options.scene                   {@link IMMessage.scene|场景}
	 * @param  {String|Number}  options.to                      接收方, 对方帐号或者群id
	 * @param  {String}         options.tip                     提醒内容
	 * @param  {Boolean}        [options.resend]                是否是重发
	 * @param  {String}         [options.idClient]              如果是重发, 那么需要带上之前生成的idClient来标记这条消息
	 * @param  {String}         [options.custom]                扩展字段
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @param  {String}         [options.pushContent]           自定义推送文案
	 * @param  {String}         [options.pushPayload]           自定义的推送属性
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @param {Object}   [apns]          特殊推送选项, 只在群会话中使用
	 * @param {String[]} [apns.accounts] 需要特殊推送的账号列表, 不填表示推送给当前会话内的所有用户
	 * @param {String}   [apns.content]  需要特殊推送的文案, 不填的话默认为 pushContent
	 * @param {String}   [apns.forcePush=true] 是否强制推送, true 表示即使推送列表中的胡勇屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
	 * @param  {Boolean}        [options.isHistoryable=true]    是否存储云端历史
	 * @param  {Boolean}        [options.isRoamingable=true]    是否支持漫游
	 * @param  {Boolean}        [options.isSyncable=true]       是否支持发送者多端同步
	 * @param  {Boolean}        [options.cc]                    是否支持抄送
	 * @param  {Boolean}        [options.isPushable=true]       是否需要推送
	 * @param  {Boolean}        [options.isOfflinable=true]     是否要存离线
	 * @param  {Boolean}        [options.isUnreadable=true]     是否计入消息未读数
	 * @param  {Boolean}        [options.needPushNick=true]     是否需要推送昵称
	 * @param {Boolean} [options.isLocal=false] 是否是本地消息
	 * - `true`表示本地消息, 那么SDK并不会发送此条消息, 而是直接调用回调表示发送成功, 并更新对应的会话
	 * @return {Message}        {@link IMMessage|消息}
	 *
	 * @example
	 * var msg = nim.sendTipMsg({
	 *     scene: 'p2p',
	 *     to: 'account',
	 *     tip: 'tip content',
	 *     done: sendMsgDone
	 * });
	 * console.log('正在发送p2p提醒消息, id=' + msg.idClient);
	 * pushMsg(msg);
	 */

	/**
	 * 给机器人发送消息
	 *
	 * - 机器人消息是{@link IMMessage.type|消息类型}的一种
	 * - 机器人消息类型分为type为robot
	 *
	 * @memberOf NIM#
	 * @method sendRobotMsg
	 *
	 * @param  {Object}         options                         配置参数
	 * @param  {String}         [options.scene]                   {@link IMMessage.scene|场景}
	 * @param  {String|Number}  [options.to]                      接收方, 对方帐号或者群id，如果id为机器人，则点对点与机器人聊天，如果id为普通用户或者群，则相当于聊天界面@机器人
	 * @param  {Object}         [options.content]                 发送给机器人的消息内容
	 * @param {String}          [options.content.type]           welcome:欢迎消息，text:文本，link:模块跳转
	 * @param {String}          [options.content.content]           机器人消息内容
	 * @param {String}          [options.content.target]           返回消息类型为BOT时出现的link元素类型block中的target
	 * @param {String}          [options.content.params]           返回消息类型为BOT时出现的link元素类型block中的params
	 * @param {String}          [options.content.userid]           区分谁和机器人说话的ID
	 * @param {String}          [options.content.channel]          渠道
	 * @param  {Boolean}        [options.resend]                是否是重发
	 * @param  {String}         [options.idClient]              如果是重发, 那么需要带上之前生成的idClient来标记这条消息
	 * @param {Object}   [apns]          特殊推送选项, 只在群会话中使用
	 * @param {String[]} [apns.accounts] 需要特殊推送的账号列表, 不填表示推送给当前会话内的所有用户
	 * @param {String}   [apns.content]  需要特殊推送的文案, 不填的话默认为 pushContent
	 * @param {String}   [apns.forcePush=true] 是否强制推送, true 表示即使推送列表中的胡勇屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
	 * @param  {Boolean}        [options.isHistoryable=true]    是否存储云端历史
	 * @param  {Boolean}        [options.isRoamingable=true]    是否支持漫游
	 * @param  {Boolean}        [options.isSyncable=true]       是否支持发送者多端同步
	 * @param  {Boolean}        [options.cc]                    是否支持抄送
	 * @param  {Boolean}        [options.isPushable=true]       是否需要推送
	 * @param  {Boolean}        [options.isOfflinable=true]     是否要存离线
	 * @param  {Boolean}        [options.isUnreadable=true]     是否计入消息未读数
	 * @param  {Boolean}        [options.needPushNick=true]     是否需要推送昵称
	 * @param {Boolean} [options.isLocal=false] 是否是本地消息
	 * - `true`表示本地消息, 那么SDK并不会发送此条消息, 而是直接调用回调表示发送成功, 并更新对应的会话
	 * @return {Message}                            {@link IMMessage|消息}
	 *
	 * @example
	 * var msg = nim.sendRobotMsg({
	 *   scene: 'p2p',
	 *   to: 'nim-assistant',
	 *   content: {
	 *     type: 'text',
	 *     content: 'hello'
	 *   },
	 *   body: '欢迎',
	 *   robotAccid: 'nim-assistant',
	 *   done: function sendMsgDone (err) {
	 *     console.log(11111111, err)
	 *   }
	 * })
	 * console.log('正在发送p2p自定义消息, id=' + msg.idClient);
	 * pushMsg(msg);
	 */

	NIMFn.beforeSendMsg = function (options) {
	  var self = this;
	  var protocol = self.protocol;
	  var msg = options.msg;
	  // 如果是发送给自己, 需要带上设备号
	  if (msg.to === self.account) {
	    msg.fromDeviceId = device.deviceId;
	  }
	  // 在消息中带上当前用户的信息更新时间
	  msg.userUpdateTime = protocol.myInfo && protocol.myInfo.updateTime;
	  // 生成命令
	  var cmd;
	  // 区分点对点消息和群消息
	  switch (msg.getScene()) {
	    case 'p2p':
	      cmd = 'sendMsg';
	      break;
	    case 'team':
	      cmd = 'sendTeamMsg';
	      break;
	    default:
	      break;
	  }
	  // 是否是过滤消息
	  if (options.filter) {
	    cmd = 'sendFilterMsg';
	    msg.filter = true;
	  }
	  options.cmd = cmd;
	};

	NIMFn.afterSendMsg = function (options) {
	  var msg = options.rtnMsg;
	  var session = Session.genSessionByMsg(msg);
	  this.protocol.onUpdateSession(session);
	};

	/**
	 * 重发消息
	 * - 如果消息发送失败, 那么可以重发消息
	 *
	 * @memberOf NIM#
	 * @method resendMsg
	 *
	 * @param  {Object} options  配置参数
	 * @param {IMMessage} options.msg 待重发的消息
	 * @param {Function} options.done 结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.resendMsg({
	 *   msg: someMsg,
	 *   done: sendMsgDone
	 * })
	 * console.log('正在重发消息', someMsg)
	 */

	/**
	 * 转发消息
	 *
	 * @memberOf NIM#
	 * @method forwardMsg
	 *
	 * @param  {Object} options  配置参数
	 * @param {IMMessage} options.msg 待转发的消息
	 * @param {String}  options.scene 新的{@link IMMessage.scene|场景}
	 * @param {String}  options.to 新的接收方, 对方帐号或者群id
	 * @param {Function} options.done 结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.forwardMsg({
	 *   msg: someMsg,
	 *   scene: 'p2p',
	 *   to: 'account',
	 *   done: sendMsgDone
	 * })
	 * console.log('正在转发消息', someMsg)
	 */
	NIMFn.beforeForwardMsg = function (options) {
	  util.verifyOptions(options, 'msg scene to');
	  options.msg.scene = options.scene;
	  options.msg.to = options.to;
	};

	/**
	 * 标记消息为已收到
	 *
	 * - 如果没有消息、或者支持数据库、或者设置了自动标记, 那么直接返回
	 *
	 * @memberOf NIM#
	 * @method markMsgRead
	 *
	 * @param  {IMMessage[]}  msgs    待标记的消息或者消息数组
	 * @return {Void}
	 *
	 * @example
	 * nim.markMsgRead(someMsg);
	 * // or
	 * nim.markMsgRead([someMsg]);
	 */
	NIMFn.markMsgRead = function (msgs) {
	  var self = this;
	  var protocol = self.protocol;
	  if (!msgs || self.db.enable || protocol.options.autoMarkRead) {
	    self.logger.warn('不需要标记消息为已收到 (没有消息, 或者启用了数据库, 或者启用了自动标记已收到)');
	    return;
	  }
	  protocol.markMsgRead(msgs, true);
	};

	/**
	 * 发送消息已读回执
	 *
	 * - 目前只支持{@link IMMessage.scene|'p2p'}会话
	 * - 如果没有传入消息, 则直接返回成功
	 * - 如果已经发送过比传入的消息的时间戳大的已读回执, 那么直接返回成功
	 *
	 * @memberOf NIM#
	 * @method sendMsgReceipt
	 *
	 * @param {Object} options 参数
	 * @param {IMMessage} options.msg 要发送已读回执的会话的最后一条消息, 可以直接通过{@link Session|`session.lastMsg`}来获取此消息
	 * @param {Function} options.done 结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.sendMsgReceipt({
	 *     msg: session.lastMsg,
	 *     done: sendMsgReceiptDone
	 * });
	 * function sendMsgReceiptDone(error, obj) {
	 *     console.log('发送消息已读回执' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	/*
	// 测试代码
	nim.sendMsgReceipt({
	    msg: {
	        idClient: 'aaa',
	        sessionId: 'p2p-zyy1',
	        target: 'zyy1',
	        scene: 'p2p',
	        status: 'success',
	        time: +new Date(),
	    },
	    done: function() {}
	});
	 */
	NIMFn.sendMsgReceipt = function (options) {
	  var self = this;
	  util.verifyOptions(options);
	  self.processCallback(options);
	  if (!options.msg) {
	    // 没有消息返回
	    options.done();
	    return;
	  }
	  var properties = 'target idClient time';
	  util.verifyOptions(options, 'msg');
	  var msg = options.msg;
	  util.verifyOptions(msg, properties, true, 'msg.');
	  if (self.protocol.shouldSendMsgReceipt(msg)) {
	    self.sendCmd('sendMsgReceipt', {
	      msgReceipt: {
	        to: msg.target,
	        idClient: msg.idClient,
	        time: msg.time
	      }
	    }, options.callback);
	  } else {
	    // 返回
	    options.done();
	  }
	};

	/**
	 * 查询消息是否被对方读过了
	 *
	 * - 目前只支持{@link IMMessage.scene|'p2p'}会话
	 *
	 * @memberOf NIM#
	 * @method isMsgRemoteRead
	 *
	 * @param  {IMMessage}  msg 消息
	 * @return {Boolean}     是否被对方读过
	 *
	 * @example
	 * var isRemoteRead = nim.isMsgRemoteRead(msg);
	 */
	NIMFn.isMsgRemoteRead = function (msg) {
	  return this.protocol.isMsgRemoteRead(msg);
	};

	/**
	 * 撤回消息
	 *
	 * - {@link NIM#deleteMsg|撤回消息}后, 消息接收方会收到一条类型为`'deleteMsg'`的{@link SystemMessage|系统通知}, 此类系统通知的 `msg` 为被删除的消息的部分字段。如果是群消息, 那么群里的所有人都会收到这条系统通知. 如果同时在多个端登录了同一个账号, 那么其它端也会收到这条系统通知.
	 *
	 * @memberOf NIM#
	 * @method deleteMsg
	 *
	 * @param  {Object} options  配置参数
	 * @param {IMMessage} options.msg 待撤回的消息
	 * @param {Function} options.done 结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.deleteMsg({
	 *   msg: someMsg,
	 *   done: deleteMsgDone
	 * })
	 * console.log('正在撤回消息', someMsg)
	 * function deleteMsgDone (error) {
	 *   console.log('撤回消息' + (!error?'成功':'失败'), error);
	 * }
	 */
	NIMFn.deleteMsg = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'msg');
	  var msg = options.msg;
	  // 过滤
	  if (msg.flow !== 'out' || msg.status !== 'success' || msg.from === msg.to || msg.isLocal) {
	    return options.done(NIMError.newParamError('只能删除自己发送给别人的, 并且发送成功的消息'), options);
	  }
	  util.verifyOptions(msg, ['scene', 'to', 'from', 'time', 'idClient', 'idServer'], true, 'msg.');
	  util.verifyParamValid('msg.scene', msg.scene, self.message.validScenes);
	  var sysMsg = util.simpleClone(msg);
	  this.processPs(sysMsg);
	  this.processCallback(options);
	  if (sysMsg.scene === 'p2p') {
	    sysMsg.type = 'deleteMsgP2p';
	  } else {
	    sysMsg.type = 'deleteMsgTeam';
	  }
	  sysMsg.deletedIdClient = sysMsg.idClient;
	  sysMsg.deletedIdServer = sysMsg.idServer;
	  sysMsg = new SystemMessage(sysMsg);
	  self.sendCmd('deleteMsg', { sysMsg: sysMsg, msg: msg }, options.callback);
	};

	/**
	 * 获取云端历史记录
	 *
	 * - 该接口用于获取一段时间内的历史消息, 由参数`beginTime`和`endTime`来控制时间范围。
	 *     - 当`reverse`为`false`时, 后续查询的`endTime`对应上次查询的最后一条消息的`time`字段
	 *     - 当`reverse`为`true`时, 后续查询的`beginTime`对应上次查询的最后一条消息的`time`字段
	 * - 如果要搜索历史消息, 请参考{@link NIM#searchHistoryMsgs|获取包含关键词的历史消息}
	 *
	 * @method getHistoryMsgs
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options                 配置参数
	 * @param  {String}     options.scene           请参考{@link IMMessage.scene|消息场景}
	 * @param  {String}     options.to              聊天对象, 账号或者群id
	 * @param  {Number}     [options.beginTime]     时间戳, 开始时间, 精确到ms, 默认为0
	 * @param  {Number}     [options.endTime]       时间戳, 结束时间, 精确到ms, 默认为服务器的当前时间
	 * @param  {String}     [options.lastMsgId]     上次查询的最后一条消息的`idServer`, 第一次不填
	 * @param  {Number}     [options.limit]         本次查询的消息数量限制, 最多100条, 默认100条
	 * @param  {Boolean}    [options.reverse=false] 默认`false`表示从`endTime`开始往前查找历史消息;
	 *                                              `true`表示从`beginTime`开始往后查找历史消息
	 * @param  {Boolean}    [options.asc=false]     默认`false`表示返回的消息按时间逆序排序;
	 *                                              `true`表示按时间正序排序
	 * @param  {done}       options.done            结果回调函数, 成功时会额外附上{@link IMMessage|消息}列表
	 * @return {Void}
	 *
	 * @example
	 * nim.getHistoryMsgs({
	 *     scene: 'p2p',
	 *     to: 'account',
	 *     done: getHistoryMsgsDone
	 * });
	 * function getHistoryMsgsDone(error, obj) {
	 *     console.log('获取云端历史记录' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         console.log(obj.msgs);
	 *     }
	 * }
	 */
	NIMFn.getHistoryMsgs = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'scene to');
	  util.verifyParamValid('scene', options.scene, self.message.validScenes);
	  if (typeof options.beginTime === 'undefined') {
	    options.beginTime = 0;
	  }
	  util.verifyParamType('beginTime', options.beginTime, 'number');
	  if (typeof options.endTime === 'undefined') {
	    options.endTime = 0;
	  }
	  util.verifyParamType('endTime', options.endTime, 'number');

	  if (typeof options.lastMsgId === 'undefined' || options.lastMsgId === null) {
	    options.lastMsgId = '0';
	  }

	  if (typeof options.limit === 'undefined') {
	    options.limit = 100;
	  }
	  util.verifyParamType('limit', options.limit, 'number');
	  util.verifyParamMax('limit', options.limit, 100);
	  if (notundef(options.reverse)) {
	    util.verifyParamType('reverse', options.reverse, 'boolean');
	  } else {
	    options.reverse = false;
	  }
	  if (notundef(options.asc)) {
	    util.verifyParamType('asc', options.asc, 'boolean');
	  } else {
	    options.asc = false;
	  }

	  self.processCallback(options);

	  if (options.asc) {
	    options.cbaop = function (error, obj) {
	      if (!error) {
	        obj.msgs = obj.msgs.reverse();
	      }
	    };
	  }

	  var cmd;
	  switch (options.scene) {
	    case 'p2p':
	      cmd = 'getHistoryMsgs';
	      break;
	    case 'team':
	      cmd = 'getTeamHistoryMsgs';
	      break;
	    default:
	      break;
	  }
	  var content = {
	    scene: options.scene,
	    to: options.to,
	    beginTime: options.beginTime,
	    endTime: options.endTime,
	    lastMsgId: options.lastMsgId,
	    limit: options.limit,
	    reverse: options.reverse
	  };
	  self.sendCmd(cmd, content, options.callback);
	};

	/**
	 * 获取云端包含关键词的历史记录
	 *
	 * - 跟{@link NIM#getHistoryMsgs|获取历史消息}接口类似, 只是去掉了参数`lastMsgId`, 增加了参数`keyword(要搜索的关键词)`
	 *
	 * @method searchHistoryMsgs
	 * @memberOf NIM#
	 * @private
	 *
	 * @param  {Object}     options 配置参数
	 * @param  {String}     options.scene           {@link IMMessage.scene|场景}
	 * @param  {String}     options.to              聊天对象, 账号或者群id
	 * @param  {String}     options.keyword         待搜索的关键词
	 * @param  {Number}     [options.beginTime]     时间戳, 开始时间, 精确到ms, 默认为0
	 * @param  {Number}     [options.endTime]       时间戳, 结束时间, 精确到ms, 默认为服务器的当前时间
	 * @param  {Number}     [options.limit]         本次查询的消息数量限制, 最多100条, 默认100条
	 * @param  {Boolean}    [options.reverse=false] 默认`false`表示从`endTime`开始往前查找历史消息;
	 *                                              `true`表示从`beginTime`开始往后查找历史消息
	 * @param  {Boolean}    [options.asc=false]     默认`false`表示返回的消息按时间逆序排序;
	 *                                              `true`表示按时间正序排序
	 * @param  {done}       options.done            结果回调函数, 成功时会额外附上{@link IMMessage|消息}列表
	 * @return {Void}
	 *
	 * @example
	 * nim.searchHistoryMsgs({
	 *     scene: 'p2p',
	 *     to: 'account',
	 *     keyword: 'keyword',
	 *     done: searchHistoryMsgsDone
	 * });
	 * function searchHistoryMsgsDone(error, obj) {
	 *     console.log('获取云端包含关键词的历史记录' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         console.log(obj.msgs);
	 *     }
	 * }
	 */
	NIMFn.searchHistoryMsgs = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'scene to keyword');
	  util.verifyParamValid('scene', options.scene, self.message.validScenes);
	  if (typeof options.beginTime === 'undefined') {
	    options.beginTime = 0;
	  }
	  util.verifyParamType('beginTime', options.beginTime, 'number');
	  if (typeof options.endTime === 'undefined') {
	    options.endTime = 0;
	  }
	  util.verifyParamType('endTime', options.endTime, 'number');
	  if (typeof options.limit === 'undefined') {
	    options.limit = 100;
	  }
	  util.verifyParamType('limit', options.limit, 'number');
	  util.verifyParamMax('limit', options.limit, 100);
	  if (notundef(options.reverse)) {
	    util.verifyParamType('reverse', options.reverse, 'boolean');
	  } else {
	    options.reverse = false;
	  }
	  if (notundef(options.asc)) {
	    util.verifyParamType('asc', options.asc, 'boolean');
	  } else {
	    options.asc = false;
	  }
	  self.processCallback(options);

	  if (options.asc) {
	    options.cbaop = function (error, obj) {
	      if (!error) {
	        obj.msgs = obj.msgs.reverse();
	      }
	    };
	  }

	  var cmd;
	  switch (options.scene) {
	    case 'p2p':
	      cmd = 'searchHistoryMsgs';
	      break;
	    case 'team':
	      cmd = 'searchTeamHistoryMsgs';
	      break;
	    default:
	      break;
	  }
	  var content = util.filterObj(options, 'scene to beginTime endTime keyword limit reverse');
	  self.sendCmd(cmd, content, options.callback);
	};

	/**
	 * 获取本地历史记录
	 * - 如果不{@link support.db|支持数据库}, 算成功, 返回空数组
	 *
	 * @method getLocalMsgs
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options                     配置参数
	 *  @param {String} [options.sessionId] 如果提供该参数, 那么查询该会话的消息
	 *  @param {String[]} [options.sessionIds] 如果提供该参数, 那么查询这几个会话的消息
	 *  @param {Number} [options.start=0] 开始时间
	 *  @param {Number} [options.end=Infinity] 结束时间
	 *  @param {Boolean} [options.desc=true] true 表示从 end 开始查, false 表示从 begin 开始查
	 *  @param {Number} [options.limit=100] limit 数量限制
	 *  @param {String} [options.type] {@link IMMessage.type|消息类型}, 如果提供该参数, 那么查询该类型的消息
	 *  @param {String[]} [options.types] 如果提供该参数, 那么查询这几种类型的消息
	 *  @param {String} [options.keyword] 如果提供参数, 那么查询匹配该关键词的消息
	 *  @param {Function} [options.filterFunc] 可选参数, 过滤函数, 接收消息对象, 返回 true 表示结果保留该消息
	 * @param  {done} options.done 结果回调函数, 成功时会附上{@link IMMessage|消息}列表
	 * @return {Void}
	 *
	 * @example
	 * nim.getLocalMsgs({
	 *   sessionId: 'p2p-account'
	 *   limit: 100,
	 *   done: getLocalMsgsDone
	 * })
	 * function getLocalMsgsDone(error, obj) {
	 *   console.log('获取本地消息' + (!error?'成功':'失败'), error, obj)
	 * }
	 */
	NIMFn.getLocalMsgs = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  var msgs = [];

	  util.verifyOptions(options);
	  // start & end
	  var hasStart = false;
	  if (notundef(options.start)) {
	    hasStart = true;
	    util.verifyParamType('start', options.start, 'number');
	  }
	  var hasEnd = false;
	  if (notundef(options.end)) {
	    hasEnd = true;
	    util.verifyParamType('end', options.end, 'number');
	  }
	  if (hasStart && hasEnd && options.end <= options.start) {
	    util.onParamError('参数 end 必须晚于 start');
	  }
	  // limit
	  if (undef(options.limit)) {
	    options.limit = 100;
	  }
	  util.verifyParamType('limit', options.limit, 'number');
	  util.verifyParamMin('limit', options.limit, 1);
	  // 不指定最大数量限制, 由调用方负责, 数量大的话时间久
	  // util.verifyParamMax('limit', options.limit, 100)
	  self.processCallback(options);

	  if (db.enable) {
	    db.getMsgs(options).then(function (records) {
	      msgs = records;
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    options.msgs = msgs;
	    options.done(error, options);
	  }
	};

	/**
	 * 获取 idClient 对应的本地消息
	 * - 如果不{@link support.db|支持数据库}, 算成功, 返回 null
	 *
	 * @method getLocalMsgByIdClient
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options             配置参数
	 * @param  {String}     options.idClient    idClient
	 * @param  {Function}   options.done        结果回调函数, 成功时会额外附上{@link IMMessage|消息}
	 * @return {Void}
	 *
	 * @example
	 * nim.getLocalMsgByIdClient({
	 *     idClient: 'd7a1b2c63066e1038e9aa01321652370',
	 *     done: getLocalMsgByIdClientDone
	 * });
	 * function getLocalMsgByIdClientDone(error, obj) {
	 *     console.log('获取本地消息' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         console.log(obj.msg);
	 *     }
	 * }
	 */
	NIMFn.getLocalMsgByIdClient = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  var msg = null;
	  util.verifyOptions(options, 'idClient');
	  self.processCallback(options);
	  if (db.enable) {
	    db.getMsgByIdClient(options.idClient).then(function (record) {
	      if (record) {
	        msg = record;
	      }
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    options.msg = msg;
	    options.done(error, options);
	  }
	};

	/**
	 * 获取 idClients 对应的本地消息
	 * - 如果不{@link support.db|支持数据库}, 算成功, 返回空数组
	 *
	 * @method getLocalMsgsByIdClients
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options             配置参数
	 * @param  {String[]}   options.idClients   idClients
	 * @param  {Function}   options.done        结果回调函数, 成功时会额外附上{@link IMMessage|消息}列表
	 * @return {Void}
	 *
	 * @example
	 * nim.getLocalMsgsByIdClients({
	 *     idClients: [
	 *         'd7a1b2c63066e1038e9aa01321652370',
	 *         '22e604c7811c23586355f63f24658525'
	 *     ],
	 *     done: getLocalMsgsByIdClientsDone
	 * });
	 * function getLocalMsgsByIdClientsDone(error, obj) {
	 *     console.log('获取本地消息' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         console.log(obj.msgs);
	 *     }
	 * }
	 */
	NIMFn.getLocalMsgsByIdClients = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  var msgs = [];
	  util.verifyOptions(options, 'idClients');
	  util.verifyParamType('idClients', options.idClients, 'array');
	  self.processCallback(options);
	  if (db.enable) {
	    db.getMsgsByIdClients(options.idClients).then(function (records) {
	      msgs = records.filter(function (record) {
	        return !!record;
	      });
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    options.msgs = msgs;
	    options.done(error, options);
	  }
	};

	/**
	 * 更新本地消息
	 * - 更新 `idClient` 对应的本地消息
	 * - 如果不{@link support.db|支持数据库}, 算成功
	 * - 如果对应的消息不存在, 算成功, 返回 null
	 * - 这些字段只会被更新到本地数据库, 不会被更新到服务器上
	 *
	 * @method updateLocalMsg
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options                 配置参数
	 * @param  {String}     options.idClient        idClient
	 * @param {String}      [options.localCustom]   自定义字段
	 * @param  {Function}   options.done            结果回调函数, 成功时会额外附上{@link IMMessage|消息}
	 * @return {Void}
	 *
	 * @example
	 * nim.updateLocalMsg({
	 *     id: 'p2p-account',
	 *     localCustom: '{"key","value"}',
	 *     done: updateLocalMsgDone
	 * });
	 * function updateLocalMsgDone(error, obj) {
	 *     console.log('更新本地消息' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.updateLocalMsg = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  var msg = null;
	  util.verifyOptions(options, 'idClient');
	  self.processCallback(options);
	  if (db.enable) {
	    var obj = util.filterObj(options, 'idClient localCustom');
	    db.updateMsg(obj).then(function (record) {
	      msg = record;
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    options.msg = msg;
	    options.done(error, options);
	  }
	};

	/**
	 * 删除本地消息
	 * - 在{@link support.db|支持数据库}时
	 *     - 如果删除的是对应会话的最后一条消息, 那么对应会话的 `lastMsg` 属性会自动变为变为上一条消息, 同时触发 `onupdatesession` 回调
	 *     - 如果对应的消息不存在, 算成功
	 * - 如果不{@link support.db|支持数据库}, 算成功
	 *
	 * @method deleteLocalMsg
	 * @memberOf NIM#
	 *
	 * @param  {Object}             options             配置参数
	 * @param  {IMMessage}          options.msg         待删除的消息
	 * @param  {Function}           options.done        结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.deleteLocalMsg({
	 *     msg: msg,
	 *     done: deleteLocalMsgDone
	 * });
	 * function deleteLocalMsgDone(error, obj) {
	 *     console.log('删除本地消息' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.deleteLocalMsg = function (options) {
	  var self = this;
	  var error;
	  util.verifyOptions(options, 'msg');
	  var msg = options.msg;
	  util.verifyOptions(msg, 'idClient sessionId', true, 'msg.');
	  self.processCallback(options);
	  self.protocol.deleteLocalMsg(msg).then(bingo, function (event) {
	    error = event;
	    bingo();
	  });
	  function bingo() {
	    options.done(error, options);
	  }
	};

	/**
	 * 删除某个会话的本地消息
	 *
	 * - 如果不{@link support.db|支持数据库}, 算成功
	 *
	 * @method deleteLocalMsgsBySession
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options         配置参数
	 * @param  {String}     options.scene   {@link IMMessage.scene|场景}
	 * @param  {String}     options.to      聊天对象, 账号或者群id
	 * @param  {Function}   options.done    结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.deleteLocalMsgsBySession({
	 *     scene: 'p2p',
	 *     to: 'account',
	 *     done: deleteLocalMsgsBySessionDone
	 * });
	 * function deleteLocalMsgsBySession(error, obj) {
	 *     console.log('删除会话本地消息' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.deleteLocalMsgsBySession = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  util.verifyOptions(options, 'scene to');
	  util.verifyParamValid('scene', options.scene, self.message.validScenes);
	  options.sessionId = options.scene + '-' + options.to;
	  self.processCallback(options);
	  if (db.enable) {
	    db.deleteMsgsBySessionId(options.sessionId).then(function () {
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    options.done(error, options);
	  }
	};

	/**
	 * 删除所有本地消息
	 * - 如果不{@link support.db|支持数据库}, 算成功
	 * - 此方法同时会清空所有的会话, 请开发者自己清空内存里面的会话列表
	 *
	 * @method deleteAllLocalMsgs
	 * @memberOf NIM#
	 *
	 * @param  {Object} options 配置参数
	 * @return {Void}
	 *
	 * @example
	 * nim.deleteAllLocalMsgs({
	 *     done: deleteAllLocalMsgsDone
	 * });
	 * function deleteAllLocalMsgsDone(error, obj) {
	 *     console.log('删除所有本地消息' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.deleteAllLocalMsgs = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  self.processCallback(options);
	  if (db.enable) {
	    db.deleteAllMsgs().then(function () {
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  }
	  function bingo() {
	    options.done(error, options);
	  }
	};

/***/ },
/* 99 */,
/* 100 */
/***/ function(module, exports) {

	/**
	 * 修改图片下载的名字
	 *
	 * @memberOf NIM#
	 * @method packFileDownloadName
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.url     原图 url
	 * @param  {String} options.name    下载的名字
	 * @return {String}                 修改图片下载名字后的图片 url
	 *
	 * @example
	 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var nameUrl = nim.packFileDownloadName({
	 *     url: url,
	 *     name: '测试.jpg'
	 * });
	 * console.log(nameUrl);
	 */

	/**
	 * 将音频 url 转为 mp3
	 * - 此方法会返回一个新的 url
	 * @memberOf NIM#
	 * @method audioToMp3
	 *
	 * @param {Object} options 配置参数
	 * @param {String} options.url url
	 * @return {String} 转为 mp3 后的 url
	 *
	 * @example
	 * var url = 'http://b12026.nos.netease.com/MTAxMTAxMA==/bmltYV8xMTQwMzFfMTQ1MTg4ODk5MjMxMV9mNmI1Y2QyZC03N2UzLTQxNmUtYWY5NC1iODlhZGY4ZTYzYWQ=';
	 * var mp3Url = nim.audioToMp3({
	 *     url: url
	 * });
	 * console.log(mp3Url);
	 */

	/**
	 * 去除图片元信息
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 * - 去除元信息后的图片将不包含 [EXIF](https://en.wikipedia.org/wiki/Exchangeable_image_file_format) 信息
	 *
	 * @memberOf NIM#
	 * @method stripImageMeta
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.url     原图 url
	 * @param  {done}   options.done    结果回调函数, 成功时附上 interlace 后的图片 url
	 * @return {Void}
	 *
	 * @example
	 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var interlaceUrl = nim.stripImageMeta({
	 *     url: url,
	 *     strip: true,
	 *     done: stripImageMetaDone
	 * });
	 * function stripImageMetaDone(error, obj) {
	 *     console.log('去除图片元信息' + (!error?'成功':'失败'), error, obj);
	 * }
	 */

	/**
	 * 修改图片质量
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 * - 默认图片质量为100, 开发者可以降低图片质量来省流量
	 *
	 * @memberOf NIM#
	 * @method qualityImage
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.url     原图 url
	 * @param  {Int}    options.quality 图片质量, 必须为整数, 取值范围为 0-100, 此方法内部使用 Math.round 来格式化 quality
	 * @param  {done}   options.done    结果回调函数, 成功时附上修改质量后的图片 url
	 * @return {Void}
	 *
	 * @example
	 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var qualityUrl = nim.qualityImage({
	 *     url: url,
	 *     quality: 20,
	 *     done: qualityImageDone
	 * });
	 * function qualityImageDone(error, obj) {
	 *     console.log('修改图片质量' + (!error?'成功':'失败'), error, obj);
	 * }
	 */

	/**
	 * interlace 图片
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 * - 在网络环境较差时, interlace 后的图片会以从模糊到清晰的方式呈现给用户
	 *
	 * @memberOf NIM#
	 * @method interlaceImage
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.url     原图 url
	 * @param  {done}   options.done    结果回调函数, 成功时附上 interlace 后的图片 url
	 * @return {Void}
	 *
	 * @example
	 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var interlaceUrl = nim.interlaceImage({
	 *     url: url,
	 *     done: interlaceImageDone
	 * });
	 * function interlaceImageDone(error, obj) {
	 *     console.log('interlace 图片' + (!error?'成功':'失败'), error, obj);
	 * }
	 */

	/**
	 * 旋转图片
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 *
	 * @memberOf NIM#
	 * @method rotateImage
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.url     原图 url
	 * @param  {Int}    options.angle   旋转的角度, 正整数表示顺时针, 负整数表示逆时针, 必须为整数, 此方法内部会先将 angle 格式化为 [0, 360] 范围内的数字, 然后使用 Math.round 来格式化 angle
	 * @param  {done}   options.done    结果回调函数, 成功时附上旋转后的图片的 url
	 * @return {Void}
	 *
	 * @example
	 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var rotateUrl = nim.rotateImage({
	 *     url: url,
	 *     angle: 90,
	 *     done: rotateImageDone
	 * });
	 * function rotateImageDone(error, obj) {
	 *     console.log('旋转图片' + (!error?'成功':'失败'), error, obj);
	 * }
	 */

	/**
	 * 高斯模糊图片
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 *
	 * @memberOf NIM#
	 * @method blurImage
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.url     原图 url
	 * @param  {Number} radius          高斯模糊半径, 不包含中心点的像素, 取值范围 [1,50]
	 * @param  {Number} sigma           高斯模糊标准差, 不能小于 0
	 * @param  {done}   options.done    结果回调函数, 成功时附上高斯模糊后的图片 url
	 * @return {Void}
	 *
	 * @example
	 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var blurUrl = nim.blurImage({
	 *     url: url,
	 *     radius: 5,
	 *     sigma: 3,
	 *     done: blurImageDone
	 * });
	 * function blurImageDone(error, obj) {
	 *     console.log('高斯模糊图片' + (!error?'成功':'失败'), error, obj);
	 * }
	 */

	/**
	 * 裁剪图片
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 * - 从坐标 (x, y) 处截取尺寸为 width*height 的图片, (0, 0) 代表左上角
	 * - width/height 不能小于0, 如果 width/height 大于图片的原始宽度/高度, 那么将被替换为图片的原始宽度/高度
	 *
	 * @memberOf NIM#
	 * @method cropImage
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.url     原图 url
	 * @param  {Int}    options.x       起点坐标 x, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
	 * @param  {Int}    options.y       起点坐标 y, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
	 * @param  {Int}    options.width   宽度, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
	 * @param  {Int}    options.height  高度, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
	 * @param  {done}   options.done    结果回调函数, 成功时附上裁剪后的图片的 url
	 * @return {Void}
	 *
	 * @example
	 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var cropUrl = nim.cropImage({
	 *     url: url,
	 *     x: 100,
	 *     y: 0,
	 *     width: 250,
	 *     height: 250,
	 *     done: function cropImageDone
	 * });
	 * function cropImageDone(error, obj) {
	 *     console.log('裁剪图片' + (!error?'成功':'失败'), error, obj);
	 * }
	 */

	/**
	 * 生成缩略图
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 * - width/height 限制了缩略图的尺寸
	 *     - width/height 必须大于等于 0, 不能同时为 0, 必须小于 4096
	 * - 不同模式下生成的缩略图是不一样的, 目前支持以下三种模式
	 *     - `'cover'`: 原图片等比缩略, 缩略图一边等于请求的尺寸, 另一边大于请求的尺寸, 即缩略图刚好能覆盖住尺寸为 width*height 的矩形
	 *     - `'contain'`: 原图片等比缩略, 缩略图一边等于请求的尺寸, 另一边小于请求的尺寸, 即尺寸为 width*height 的矩形刚好能覆盖住缩略图
	 *     - `'crop'`: 先等比缩略原图片, 使得一边等于请求的尺寸, 另一边大于请求的尺寸, 然后对大于请求尺寸的那条边进行裁剪, 使得最终的图片大小刚好等于请求的尺寸
	 * - 如果缩略图尺寸大于图片尺寸, 默认情况下图片不会被放大, 可以传入参数`enlarge=true`来放大图片
	 * - `'crop'` 模式下可以传入参数 axis.x 或 axis.y 来控制最后一步裁剪的位置
	 *     - x/y 必须为整数, 取值范围为 0-10, 此方法内部使用 Math.round 来格式化 x/y
	 *     - x 为 0 时表示裁取最左端, x 为 10 时表示裁取最右端
	 *     - y 为 0 时表示裁取最上端, y 为 10 时表示裁取最下端
	 *     - x/y 默认值均为 5, 即裁取正中间
	 *
	 * @memberOf NIM#
	 * @method thumbnailImage
	 *
	 * @param  {Object}     options                 配置参数
	 * @param  {String}     options.url             原图 url
	 * @param  {Int}        [options.width]         缩略图的最大宽度, 必须为整数, 此方法内部使用 Math.round 来格式化 width/height
	 * @param  {Int}        [options.height]        缩略图的最大高度, 必须为整数, 此方法内部使用 Math.round 来格式化 width/height
	 * @param  {String}     options.mode            缩略模式, 目前支持以下三种模式, 请参考上面的描述
	 * - `'cover'`
	 * - `'contain'`
	 * - `'crop'`
	 * @param  {Int}        [options.axis.x]        `'crop'` 模式下控制最后一步裁剪的位置, 请参考上面的描述
	 * @param  {Int}        [options.axis.y]        `'crop'` 模式下控制最后一步裁剪的位置, 请参考上面的描述
	 * @param  {Boolean}    [options.enlarge=false] 当图片尺寸小于要缩略的尺寸时, 是否放大图片, 默认`false`不放大
	 * @param  {done}       options.done            结果回调函数, 成功时附上缩略后的图片 url
	 * @return {Void}
	 *
	 * @example
	 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var thumbnailUrl = nim.thumbnailImage({
	 *     url: url,
	 *     mode: 'cover',
	 *     width: 80,
	 *     height: 100,
	 *     done: thumbnailImageDone
	 * });
	 * function thumbnailImageDone(error, obj) {
	 *     console.log('生成缩略图' + (!error?'成功':'失败'), error, obj);
	 * }
	 */

	/**
	 * 处理图片
	 *
	 * 此方法接收一组图片操作, 按操作顺序依次处理图片, 可选的操作包括：
	 * - {@link NIM#qualityImage|修改图片质量}
	 * - {@link NIM#interlaceImage|interlace 图片}
	 * - {@link NIM#rotateImage|旋转图片}
	 * - {@link NIM#blurImage|高斯模糊图片}
	 * - {@link NIM#cropImage|裁剪图片}
	 * - {@link NIM#thumbnailImage|生成缩略图}
	 * - {@link NIM#previewFile|预览文件}
	 * - {@link NIM#sendFile|发送文件消息}
	 *
	 * 每个操作所需的参数请参考上面的各个方法, 除了上面方法列出来的参数之外, 每个操作需要提供操作类型, 分别是
	 * - `'quality'`
	 * - `'interlace'`
	 * - `'rotate'`
	 * - `'blur'`
	 * - `'crop'`
	 * - `'thumbnail'`
	 *
	 * 请参考下面的示例代码
	 *
	 * @memberOf NIM#
	 * @method processImage
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.url     原图 url
	 * @param  {Array}  options.ops     操作序列
	 * @param  {done}   options.done    结果回调函数, 成功时附上处理后的图片 url
	 * @return {Void}
	 *
	 * @example
	 * // 裁剪后旋转
	 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * nim.processImage({
	 *     url: url,
	 *     ops: [
	 *         {
	 *             type: 'crop',
	 *             x: 100,
	 *             y: 0,
	 *             width: 250,
	 *             height: 250,
	 *         },
	 *         {
	 *             type: 'thumbnail',
	 *             mode: 'cover',
	 *             width: 80,
	 *             height: 80
	 *         }
	 *     ],
	 *     done: processImageDone
	 * });
	 * function processImageDone(error, obj) {
	 *     console.log('处理图片' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	"use strict";

/***/ },
/* 101 */
/***/ function(module, exports) {

	/**
	 * 预览去除图片元信息
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 * - 去除元信息后的图片将不包含 [EXIF](https://en.wikipedia.org/wiki/Exchangeable_image_file_format) 信息
	 *
	 * @memberOf NIM#
	 * @method viewImageStripMeta
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.url     原图 url
	 * @param  {done}   options.done    结果回调函数, 成功时附上 interlace 后的图片 url
	 * @return {Void}
	 *
	 * @example
	 * var url = 'http://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var stripMetaUrl = nim.viewImageStripMeta({
	 *     url: url,
	 *     strip: true
	 * });
	 */

	/**
	 * 预览图片质量
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 * - 默认图片质量为100，开发者可以降低图片质量来省流量
	 *
	 * @memberOf NIM#
	 * @method viewImageQuality
	 * @private
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.url     原图 url
	 * @param  {Int}    options.quality 图片质量, 必须为整数, 取值范围为 0-100, 此方法内部使用 Math.round 来格式化 quality
	 * @return {String}                 修改图片质量后的图片 url
	 *
	 * @example
	 * var url = 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var qualityUrl = nim.viewImageQuality({
	 *     url: url,
	 *     quality: 20
	 * });
	 * // 修改图片质量后的图片 url 如下
	 * // qualityUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&quality=20'
	 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的修改图片质量的结果
	 */

	/**
	 * 预览interlace图片
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 * - 在网络环境较差时, interlace 后的图片会以从模糊到清晰的方式呈现给用户
	 *
	 * @memberOf NIM#
	 * @method viewImageInterlace
	 * @private
	 *
	 * @param  {Object} options     配置参数
	 * @param  {String} options.url 原图 url
	 * @return {String}             interlace 后的图片 url
	 *
	 * @example
	 * var url = 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var interlaceUrl = nim.viewImageInterlace({
	 *     url: url
	 * });
	 * // interlace 后的图片 url 如下
	 * // interlaceUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&interlace=1'
	 */

	/**
	 * 预览旋转图片
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 *
	 * @memberOf NIM#
	 * @method viewImageRotate
	 * @private
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.url     原图 url
	 * @param  {Int}    options.angle   旋转的角度, 正整数表示顺时针, 负整数表示逆时针, 必须为整数, 此方法内部会先将 angle 格式化为 [0, 360] 范围内的数字, 然后使用 Math.round 来格式化 angle
	 * @return {String}                 旋转后的图片的 url
	 *
	 * @example
	 * var url = 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var rotateUrl = nim.viewImageRotate({
	 *     url: url,
	 *     angle: 90
	 * });
	 * // 旋转后的图片的 url 如下
	 * // rotateUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&rotate=90'
	 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的旋转结果
	 */

	/**
	 * 预览高斯模糊图片
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 *
	 * @memberOf NIM#
	 * @method viewImageBlur
	 * @private
	 *
	 * @param  {Object} options     配置参数
	 * @param  {String} options.url 原图 url
	 * @param  {Number} radius      高斯模糊半径, 不包含中心点的像素, 取值范围 [1,50]
	 * @param  {Number} sigma       高斯模糊标准差, 不能小于 0
	 * @return {String}             高斯模糊后的图片 url
	 *
	 * @example
	 * var url = 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var blurUrl = nim.viewImageBlur({
	 *     url: url,
	 *     radius: 5,
	 *     sigma: 3
	 * });
	 * // 高斯模糊后的图片 url 如下
	 * // blurUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&blur=5x3'
	 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的高斯模糊后的结果
	 */

	/**
	 * 预览裁剪图片
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 * - 从坐标 (x, y) 处截取尺寸为 width*height 的图片，(0, 0) 代表左上角
	 * - width/height 不能小于0, 如果 width/height 大于图片的原始宽度/高度, 那么将被替换为图片的原始宽度/高度
	 * - 举个栗子, 假如说之前通过{@link NIM#previewFile|预览文件}拿到的 url 为
	 *     {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=}
	 * - 传入 x/y/width/height 为 100/0/250/250 得到的裁剪图片的 url 为
	 *     {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&crop=100_0_250_250|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&crop=100_0_250_250}
	 * - 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
	 *
	 * @memberOf NIM#
	 * @method viewImageCrop
	 * @private
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.url     原图 url
	 * @param  {Int}    options.x       起点坐标 x, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
	 * @param  {Int}    options.y       起点坐标 y, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
	 * @param  {Int}    options.width   宽度, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
	 * @param  {Int}    options.height  高度, 必须需为整数, 此方法内部使用 Math.round 来格式化 x/y/width/height
	 * @return {String}                 裁剪后的图片的 url
	 *
	 * @example
	 * var url = 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var cropUrl = nim.viewImageCrop({
	 *     url: url,
	 *     x: 100,
	 *     y: 0,
	 *     width: 250,
	 *     height: 250
	 * });
	 * // 裁剪后的图片的 url 如下
	 * // cropUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&crop=100_0_250_250'
	 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
	 */

	/**
	 * 预览生成缩略图
	 *
	 * - 只支持通过{@link NIM#previewFile|预览文件}或{@link NIM#sendFile|发送文件消息}拿到的图片 url, 或者经过其他图片操作后拿到的图片 url
	 * - width/height 限制了缩略图的尺寸
	 *     - width/height 必须大于等于 0, 不能同时为 0, 必须小于 4096
	 * - 不同模式下生成的缩略图是不一样的, 目前支持以下三种模式
	 *     - `'cover'`: 原图片等比缩略, 缩略图一边等于请求的尺寸, 另一边大于请求的尺寸, 即缩略图刚好能覆盖住尺寸为 width*height 的矩形
	 *         - 举个栗子, 假如说之前通过{@link NIM#previewFile|预览文件}拿到的 url 为
	 *             {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=}
	 *         - 此模式下传入 80*100 的尺寸得到的缩略图 url 为
	 *             {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80z100|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80z100}
	 *         - 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同尺寸得到的缩略图
	 *     - `'contain'`: 原图片等比缩略, 缩略图一边等于请求的尺寸, 另一边大于请求的尺寸, 即尺寸为 width*height 的矩形刚好能覆盖住缩略图
	 *         - 还是拿上面的 url 为例, 传入 80*100 的尺寸得到的缩略图 RUL 为
	 *             {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80x100|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80x100}
	 *         - 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同尺寸得到的缩略图
	 *     - `'crop'`: 先等比缩略原图片, 使得一边等于请求的尺寸, 另一边大于请求的尺寸, 然后对大于请求尺寸的那条边进行裁剪, 使得最终的图片大小刚好等于请求的尺寸
	 *         - 还是拿上面的 url 为例, 传入 80*100 的尺寸得到的缩略图 url 为
	 *             {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100}
	 *         - 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同尺寸得到的缩略图
	 * - 如果缩略图尺寸大于图片尺寸，默认情况下图片不会被放大，可以传入参数`enlarge=true`来放大图片
	 *     - 举个栗子, 假如说之前通过{@link NIM#previewFile|预览文件}拿到的 url 为
	 *         {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=}
	 *     - 此 url 对应的图片尺寸为 512-256, 如果使用 `'cover'` 模式来裁剪, 传入尺寸 1024-512, 得到的缩略图 url 为
	 *         {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=1024z512|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=1024z512}
	 *     - 会发现图片尺寸并没有放大, 如果再传入参数 `enlarge=true`, 得到的缩略图 url 为
	 *         {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=1024z512&enlarge=1|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=1024z512&enlarge=1}
	 *     - 会发现图片被放大了
	 * - `'crop'` 模式下可以传入参数 axis.x 或 axis.y 来控制最后一步裁剪的位置
	 *     - x/y 必须为整数, 取值范围为 0-10, 此方法内部使用 Math.round 来格式化 x/y
	 *     - x 为 0 时表示裁取最左端, x 为 10 时表示裁取最右端
	 *     - y 为 0 时表示裁取最上端, y 为 10 时表示裁取最下端
	 *     - x/y 默认值均为 5, 即裁取正中间
	 *     - 拿上面的 url 为例, 传入 80*100 的尺寸得到的缩略图 url 为
	 *         {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100}
	 *         - 依次传入 x=0,1,2,3,4,5,6,7,8,9,10 得到的缩略图 url 为
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=0_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=0_5}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=1_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=1_5}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=2_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=2_5}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=3_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=3_5}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=4_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=4_5}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=5_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=5_5}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=6_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=6_5}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=7_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=7_5}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=8_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=8_5}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=9_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=9_5}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=10_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=10_5}
	 *     - 拿上面的 url 为例, 传入 200*50 的尺寸得到的缩略图 RUL 为
	 *         {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50}
	 *         - 依次传入 y=0,1,2,3,4,5,6,7,8,9,10 得到的缩略图 url 为
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_0|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_0}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_1|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_1}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_2|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_2}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_3|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_3}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_4|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_4}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_5|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_5}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_6|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_6}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_7|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_7}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_8|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_8}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_9|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_9}
	 *             - {@link https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_10|https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=200y50&axis=5_10}
	 *
	 * @memberOf NIM#
	 * @method viewImageThumbnail
	 * @private
	 *
	 * @param  {Object} options                 配置参数
	 * @param  {String} options.url             原图 url
	 * @param  {Int}    [options.width]         缩略图的最大宽度, 必须为整数, 此方法内部使用 Math.round 来格式化 width/height
	 * @param  {Int}    [options.height]        缩略图的最大高度, 必须为整数, 此方法内部使用 Math.round 来格式化 width/height
	 * @param  {String} options.mode            缩略模式, 目前支持以下三种模式, 请参考上面的描述
	 * - `'cover'`
	 * - `'contain'`
	 * - `'crop'`
	 * @param  {Int}    [options.axis.x]        `'crop'` 模式下控制最后一步裁剪的位置, 请参考上面的描述
	 * @param  {Int}    [options.axis.y]        `'crop'` 模式下控制最后一步裁剪的位置, 请参考上面的描述
	 * @param {Boolean} [options.enlarge=false] 当图片尺寸小于要缩略的尺寸时，是否放大图片，默认`false`不放大
	 * @return {String}                         缩略图的url
	 *
	 * @example
	 * var url = 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=';
	 * var thumbnailUrl = nim.viewImageThumbnail({
	 *     url: url,
	 *     mode: 'cover',
	 *     width: 80,
	 *     height: 100
	 * });
	 * // 缩略后的图片的 url 如下
	 * // thumbnailUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80z100'
	 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
	 *
	 * thumbnailUrl = nim.viewImageThumbnail({
	 *     url: url,
	 *     mode: 'contain',
	 *     width: 80,
	 *     height: 100
	 * });
	 * // 缩略后的图片的 url 如下
	 * // thumbnailUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80x100'
	 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
	 *
	 * thumbnailUrl = nim.viewImageThumbnail({
	 *     url: url,
	 *     mode: 'contain',
	 *     width: 80,
	 *     height: 100
	 * });
	 * // 缩略后的图片的 url 如下
	 * // thumbnailUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100'
	 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
	 *
	 * thumbnailUrl = nim.viewImageThumbnail({
	 *     url: url,
	 *     mode: 'contain',
	 *     width: 80,
	 *     height: 100,
	 *     axis: {
	 *         // x 可取的值请参考上文描述
	 *         x: 0
	 *     }
	 * });
	 * // 缩略后的图片的 url 如下
	 * // thumbnailUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=0_5'
	 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
	 *
	 * thumbnailUrl = nim.viewImageThumbnail({
	 *     url: url,
	 *     mode: 'contain',
	 *     width: 80,
	 *     height: 100,
	 *     axis: {
	 *         // y 可取的值请参考上文描述
	 *         y: 0
	 *     }
	 * });
	 * // 缩略后的图片的 url 如下
	 * // thumbnailUrl === 'https://nim.nos.netease.com/MTAxMTAwMg==/bmltYV8xNDc5OTNfMTQ0MzE0NTgyNDI0M184YjFkYTMwMS02NjcxLTRiYjktYTUwZC04ZTVlZjZlNzZjMzA=?imageView&thumbnail=80y100&axis=5_0'
	 * // 开发者在浏览器中打开上面的链接之后, 可以直接修改 url 里面的数字来观察不同的裁剪结果
	 */
	"use strict";

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIMFn = __webpack_require__(6).fn;
	var PushNotificationMultiportConfig = __webpack_require__(42);
	var util = __webpack_require__(1);
	var undef = util.undef;

	/**
	 * 获取当前多端推送配置选项
	 *
	 * @method getPushNotificationMultiportConfig
	 * @memberOf NIM#
	 *
	 * @return {PushNotificationMultiportConfig}  多端推送配置选项
	 */
	NIMFn.getPushNotificationMultiportConfig = function () {
	  return this.protocol.getPushNotificationMultiportConfig();
	};

	/**
	 * 更新多端推送配置选项
	 * @param  {Object} options 配置参数
	 * @param {Boolean} [options.shouldPushNotificationWhenPCOnline] 桌面端在线时是否需要发送推送给手机端
	 * @return {Void}
	 */
	NIMFn.updatePushNotificationMultiportConfig = function (options) {
	  util.verifyOptions(options);
	  if (undef(options.shouldPushNotificationWhenPCOnline)) {
	    options.shouldPushNotificationWhenPCOnline = true;
	  }
	  options.donnop = new PushNotificationMultiportConfig(options);
	  this.processCallback(options);
	  this.sendCmd('updateDonnop', options);
	};

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIMFn = __webpack_require__(6).fn;
	var util = __webpack_require__(1);

	/**
	 * 加入黑名单/从黑名单移除
	 *
	 * - 此接口可以完成以下两个功能, 通过参数`isAdd`来决定实际的功能
	 *     - `isAdd`为`true`时, 会将`account`{@link NIM#addToBlacklist|加入黑名单}
	 *         - 如果一个用户被加入了黑名单, 那么就不再会收到此用户发送的消息
	 *     - `isAdd`为`false`时, 会将`account`{@link NIM#removeFromBlacklist|从黑名单移除}
	 *         - 如果一个用户被从黑名单移除, 那么会重新收到此用户发送的消息
	 * - 每个功能SDK都提供了相应的独立接口
	 *
	 * @method markInBlacklist
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options         配置参数
	 * @param  {String}     options.account 要加入黑名单/从黑名单移除的账号
	 * @param  {Boolean}    options.isAdd   `true`表示加入黑名单, `false`表示从黑名单移除
	 * @param  {done}       options.done    结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#addToBlacklist|nim.addToBlacklist}
	 * @see {@link NIM#removeFromBlacklist|nim.removeFromBlacklist}
	 * @see {@link NIM#getRelations|nim.getRelations}
	 *
	 * @example
	 * nim.markInBlacklist({
	 *     account: 'account',
	 *     // `true`表示加入黑名单, `false`表示从黑名单移除
	 *     isAdd: true,
	 *     done: markInBlacklistDone
	 * });
	 * function markInBlacklistDone(error, obj) {
	 *     console.log('将' + obj.account + (isAdd ? '加入黑名单' : '从黑名单移除') + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         onMarkInBlacklist(obj);
	 *     }
	 * }
	 */
	NIMFn.markInBlacklist = function (options) {
	  util.verifyOptions(options, 'account isAdd');
	  util.verifyParamType('isAdd', options.isAdd, 'boolean');
	  this.processCallback(options);
	  this.sendCmd('markInBlacklist', { account: options.account, isAdd: options.isAdd }, options.callback);
	};
	/**
	 * 加入黑名单
	 *
	 * - 如果一个用户被加入了黑名单, 那么就不再会收到此用户发送的消息
	 * - SDK内部调用{@link NIM#markInBlacklist|nim.markInBlacklist}来完成实际工作
	 *
	 * @method addToBlacklist
	 * @memberOf NIM#
	 *
	 * @param {Object}  options         配置参数
	 * @param {String}  options.account 要加入黑名单的账号
	 * @param {done}    options.done    结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#markInBlacklist|nim.markInBlacklist}
	 * @see {@link NIM#removeFromBlacklist|nim.removeFromBlacklist}
	 * @see {@link NIM#getRelations|nim.getRelations}
	 *
	 * @example
	 * nim.addToBlacklist({
	 *     account: 'account',
	 *     done: addToBlacklistDone
	 * });
	 * function addToBlacklistDone(error, obj) {
	 *     console.log('加入黑名单' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         addToBlacklist(obj);
	 *     }
	 * }
	 */
	NIMFn.addToBlacklist = function (options) {
	  options.isAdd = true;
	  return this.markInBlacklist(options);
	};
	/**
	 * 从黑名单移除
	 *
	 * - 如果一个用户被从黑名单移除, 那么会重新收到此用户发送的消息
	 * - SDK内部调用{@link NIM#markInBlacklist|nim.markInBlacklist}来完成实际工作
	 *
	 * @method removeFromBlacklist
	 * @memberOf NIM#
	 *
	 * @param {Object} options         配置参数
	 * @param {String} options.account 要从黑名单移除的账号
	 * @param {done}   options.done    结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#markInBlacklist|nim.markInBlacklist}
	 * @see {@link NIM#addToBlacklist|nim.addToBlacklist}
	 * @see {@link NIM#getRelations|nim.getRelations}
	 *
	 * @example
	 * nim.removeFromBlacklist({
	 *     account: 'account',
	 *     done: removeFromBlacklistDone
	 * });
	 * function removeFromBlacklistDone(error, obj) {
	 *     console.log('从黑名单移除' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         removeFromBlacklist(obj);
	 *     }
	 * }
	 */
	NIMFn.removeFromBlacklist = function (options) {
	  options.isAdd = false;
	  return this.markInBlacklist(options);
	};
	/**
	 * 加入静音列表/从静音列表移除
	 *
	 * - 此接口可以完成以下两个功能, 通过参数`isAdd`来决定实际的功能
	 *     - `isAdd`为`true`时, 会将`account`{@link NIM#addToMutelist|加入静音列表}
	 *     - `isAdd`为`false`时, 会将`account`{@link NIM#removeFromMutelist|从静音列表移除}
	 * - 每个功能SDK都提供了相应的独立接口
	 *
	 * @method markInMutelist
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options         配置参数
	 * @param  {String}     options.account 要加入静音列表/从静音列表移除的账号
	 * @param  {Boolean}    options.isAdd   `true`表示加入静音列表, `false`表示从静音列表移除
	 * @param  {done}       options.done    结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#addToMutelist|nim.addToMutelist}
	 * @see {@link NIM#removeFromMutelist|nim.removeFromMutelist}
	 * @see {@link NIM#getRelations|nim.getRelations}
	 *
	 * @example
	 * nim.markInMutelist({
	 *     account: 'account',
	 *     // `true`表示加入静音列表, `false`表示从静音列表移除
	 *     isAdd: 'true',
	 *     done: markInMutelistDone
	 * });
	 * function markInMutelistDone(error, obj) {
	 *     console.log('将' + obj.account + (isAdd ? '加入静音列表' : '从静音列表移除') + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         onMarkInMutelist(obj);
	 *     }
	 * }
	 */
	NIMFn.markInMutelist = function (options) {
	  util.verifyOptions(options, 'account');
	  util.verifyParamType('isAdd', options.isAdd, 'boolean');
	  this.processCallback(options);
	  this.sendCmd('markInMutelist', { account: options.account, isAdd: options.isAdd }, options.callback);
	};
	/**
	 * 加入静音列表
	 *
	 * - SDK只负责维护静音列表, 具体要根据静音列表进行的操作由开发者决定
	 * - SDK内部调用{@link NIM#markInMutelist|nim.markInMutelist}来完成实际工作
	 *
	 * @method addToMutelist
	 * @memberOf NIM#
	 *
	 * @param {Object}  options         配置参数
	 * @param {String}  options.account 要加入静音列表的账号
	 * @param {done}    options.done    结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#markInMutelist|nim.markInMutelist}
	 * @see {@link NIM#removeFromMutelist|nim.removeFromMutelist}
	 * @see {@link NIM#getRelations|nim.getRelations}
	 *
	 * @example
	 * nim.addToMutelist({
	 *     account: 'account',
	 *     done: addToMutelistDone
	 * });
	 * function addToMutelistDone(error, obj) {
	 *     console.log('加入静音列表' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         addToMutelist(obj);
	 *     }
	 * }
	 */
	NIMFn.addToMutelist = function (options) {
	  options.isAdd = true;
	  return this.markInMutelist(options);
	};
	/**
	 * 从静音列表移除
	 *
	 * - SDK只负责维护静音列表, 具体要根据静音列表进行的操作由开发者决定
	 * - SDK内部调用{@link NIM#markInMutelist|nim.markInMutelist}来完成实际工作
	 *
	 * @method removeFromMutelist
	 * @memberOf NIM#
	 *
	 * @param {Object} options         配置参数
	 * @param {String} options.account 要从静音列表移除的账号
	 * @param {done}   options.done    结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#markInMutelist|nim.markInMutelist}
	 * @see {@link NIM#addToMutelist|nim.addToMutelist}
	 * @see {@link NIM#getRelations|nim.getRelations}
	 *
	 * @example
	 * nim.removeFromMutelist({
	 *     account: 'account',
	 *     done: removeFromMutelistDone
	 * });
	 * function removeFromMutelistDone(error, obj) {
	 *     console.log('从静音列表移除' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         removeFromMutelist(obj);
	 *     }
	 * }
	 */
	NIMFn.removeFromMutelist = function (options) {
	  options.isAdd = false;
	  return this.markInMutelist(options);
	};
	/**
	 * 获取黑名单和静音列表
	 *
	 * - 如果开发者在{@link NIM|初始化SDK}的时候设置了`syncRelations`为`false`, 那么就收不到`onblacklist`和`onmutelist`回调, 可以调用此接口来获取黑名单和静音列表。
	 *
	 * @method getRelations
	 * @memberOf NIM#
	 *
	 * @param {Object} options         配置参数
	 * @param {done}   options.done    结果回调函数, 成功时会返回黑名单和静音列表
	 * @return {Void}
	 *
	 * @see {@link NIM#addToBlacklist|nim.addToBlacklist}
	 * @see {@link NIM#removeFromBlacklist|nim.removeFromBlacklist}
	 * @see {@link NIM#markInBlacklist|nim.markInBlacklist}
	 * @see {@link NIM#addToMutelist|nim.addToMutelist}
	 * @see {@link NIM#removeFromMutelist|nim.removeFromMutelist}
	 * @see {@link NIM#markInMutelist|nim.markInMutelist}
	 *
	 * @example
	 * nim.getRelations({
	 *     done: getRelationsDone
	 * });
	 * function getRelationsDone(error, obj) {
	 *     console.log('获取静音列表' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         onBlacklist(obj.blacklist);
	 *         onMutelist(obj.mutelist);
	 *     }
	 * }
	 */
	NIMFn.getRelations = function (options) {
	  var self = this;
	  var db = self.db;
	  var timetag = 0;
	  options = util.verifyOptions(options);
	  self.processCallback(options);
	  if (db.enable) {
	    db.getRelationsTimetag().then(function (t) {
	      timetag = t;
	      getRelationsFromServer();
	    }, getRelationsFromServer);
	  } else {
	    getRelationsFromServer();
	  }
	  function getRelationsFromServer() {
	    self.sendCmd('getRelations', { timetag: timetag, NOTSTORE: 'timetag' }, options.callback);
	  }
	  return;
	};

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIMFn = __webpack_require__(6).fn;

	/**
	  * 直接获取机器人列表
	  * nim.getRobots({
	  *     done: getRobotsDone
	  * });
	  * function getRobotsDone(error, obj) {
	  *     console.log('获取机器人列表' + (!error?'成功':'失败'), error, obj);
	  * }
	  */

	NIMFn.getRobots = function (options) {
	  options = options || {};
	  options.type = 'getRobots';
	  this.processCallback(options);
	  this.sendCmd('sync', {
	    sync: {
	      robots: 0
	    }
	  }, options.callback);
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIMFn = __webpack_require__(6).fn;
	var util = __webpack_require__(1);
	var undef = util.undef;
	var notundef = util.notundef;

	/**
	 * 设置当前会话
	 * - 设置后, 当前会话未读数会被置为 `0`, 同时开发者会收到 `onupdatesession` 回调
	 * - 之后此会话在收到消息之后不会更新未读数
	 * - 传空字符串的话, 重置当前会话为空
	 *
	 * @method setCurrSession
	 * @memberOf NIM#
	 *
	 * @param {String} sessionId 会话ID
	 * @return {Void}
	 *
	 * @example
	 * nim.setCurrSession('sessionId');
	 */
	NIMFn.setCurrSession = function (sessionId) {
	  var self = this;
	  self.resetSessionUnread(sessionId);
	  self.protocol.setCurrSession(sessionId);
	};

	NIMFn.resetAllSessionUnread = function () {
	  var self = this;
	  for (var sessionId in self.protocol.sessionSet) {
	    if (self.protocol.sessionSet[sessionId].unread > 0) {
	      self.resetSessionUnread(sessionId);
	    }
	  }
	};

	/**
	 * 重置某个会话的未读数
	 * - 如果是已经存在的会话记录, 会将此会话未读数置为 0, 那么会收到`onupdatesession`回调
	 * - 之后此会话在收到消息之后依然会更新未读数
	 *
	 * @method resetSessionUnread
	 * @memberOf NIM#
	 *
	 * @param {String} sessionId 会话ID
	 * @return {Void}
	 *
	 * @example
	 * nim.resetSessionUnread('sessionId');
	 */
	NIMFn.resetSessionUnread = function (sessionId) {
	  var self = this;
	  // 直接重置会话未读数, 这样不用等数据库操作, 否则 UI 上会有延时
	  self.protocol.resetSessionUnread(sessionId);
	  // 如果没有开启同步未读数, 那么直接返回
	  if (!self.options.syncSessionUnread) {
	    return;
	  }
	  var session = self.protocol.findSession(sessionId);
	  if (!session) {
	    self.logger.warn('no session, ' + sessionId);
	    return;
	  }
	  // 会话没有最后一条消息
	  if (!session.lastMsg) {
	    self.logger.warn('no session.lastMsg, session ' + sessionId);
	    return;
	  }
	  // 没有 scene 或者 to
	  if (!session.scene || !session.to) {
	    self.logger.warn('no scene or to, session ' + sessionId);
	    return;
	  }
	  // 如果被 ack 的 session 已经 ack 过了, 那么直接返回
	  var ack = session.lastMsg.time;
	  if (session && session.ack && session.ack >= ack) {
	    self.logger.warn('no need to ack, session ' + sessionId);
	    return;
	  }
	  var content = {
	    scene: session.scene === 'p2p' ? 0 : 1,
	    to: session.to,
	    timetag: ack
	  };
	  self.sendCmd('markSessionAck', content);
	};

	/**
	 * 重置当前会话
	 * - 重置当前会话后, 所有会话在收到消息之后会更新未读数
	 *
	 * @method resetCurrSession
	 * @memberOf NIM#
	 *
	 * @example
	 * nim.resetCurrSession();
	 */
	NIMFn.resetCurrSession = function () {
	  this.protocol.setCurrSession('');
	};

	/**
	 * 插入一条本地会话记录
	 *
	 * - 如果会话已存在, 那么会返回错误
	 * - 如果不{@link support.db|支持数据库}, 那么算成功
	 * - 如果有对应会话的本地历史消息, 那么会更新会话的 `lastMsg` 为最后一条消息
	 * - 插入成功后, 会触发`onupdatesession`回调
	 *
	 * @method insertLocalSession
	 * @memberOf NIM#
	 *
	 * @param  {Object} options 配置参数
	 * @param {String} options.scene {@link Session|会话}{@link IMMessage.scene|场景}
	 * @param {String} option.to {@link Session|会话}对象, 账号或群ID
	 * @param {Number} [options.updateTime] 可选, 会话更新的时间, 如果不填, SDK 会设置一个比当前所有会话更新时间大的一个时间
	 * @param {Function} options.done 结果回调函数, 如果成功会额外附上生成的会话对象
	 * @return {Void}
	 * @example
	 * nim.insertLocalSession({
	 *     scene: 'p2p',
	 *     to: 'account',
	 *     done: insertLocalSessionDone
	 * });
	 * function insertLocalSessionDone(error, obj) {
	 *     console.log('插入本地会话记录' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         onSessions(obj.session);
	 *     }
	 * }
	 */
	NIMFn.insertLocalSession = function (options) {
	  var self = this;
	  var error;
	  var session;
	  util.verifyOptions(options, 'scene to');
	  util.verifyParamValid('scene', options.scene, self.message.validScenes);
	  self.processCallback(options);
	  self.protocol.insertLocalSession(options).then(function (obj) {
	    session = obj;
	    bingo();
	  }, function (err) {
	    error = err;
	    bingo();
	  });
	  function bingo() {
	    options.session = session;
	    options.done(error, options);
	  }
	};

	/**
	 * 获取本地会话列表
	 * - 如果不{@link support.db|支持数据库}, 返回空数组
	 * - 会话列表按时间逆序排列, 即最近聊过天的放在列表的最前面
	 *
	 * @method getLocalSessions
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options                 配置参数
	 * @param  {Number}     [options.lastSessionId] 上次查询的最后一条会话的`id`, 第一次不填
	 * @param  {Number}     [options.limit]         本次查询的会话数量限制, 最多 100 条, 默认 100 条
	 * @param  {Boolean}    [options.reverse=false] 默认`false`表示从最近的会话开始往前查找本地会话；
	 *                                              `true`表示从第一条会话开始往后查找本地会话
	 * @param  {done}       options.done            结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.getLocalSessions({
	 *     lastSessionId: lastSessionId,
	 *     limit: 100,
	 *     done: getLocalSessionsDone
	 * });
	 * function getLocalSessionsDone(error, obj) {
	 *     console.log('获取本地会话列表' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         onSessions(obj.sessions);
	 *     }
	 * }
	 */
	NIMFn.getLocalSessions = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  var sessions = [];
	  util.verifyOptions(options);
	  if (undef(options.limit)) {
	    options.limit = 100;
	  }
	  util.verifyParamType('limit', options.limit, 'number');
	  util.verifyParamMax('limit', options.limit, 100);
	  if (notundef(options.reverse)) {
	    util.verifyParamType('reverse', options.reverse, 'boolean');
	  } else {
	    options.reverse = false;
	  }
	  self.processCallback(options);

	  if (db.enable) {
	    db.getSessions(options).then(function (records) {
	      sessions = records;
	      self.protocol.mergeSessions(sessions);
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    options.sessions = sessions;
	    options.done(error, options);
	  }
	};

	/**
	 * 更新本地会话
	 * - 更新 `id` 对应的本地会话
	 * - 如果不{@link support.db|支持数据库}, 算成功
	 * - 如果对应的会话不存在, 算成功, 返回 null
	 * - 这些字段只会被更新到本地数据库, 不会被更新到服务器上
	 * - 目前只允许更新 `localCustom`
	 *
	 * @method updateLocalSession
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options                 配置参数
	 * @param  {String}     options.id              id
	 * @param  {String}     [options.localCustom]   自定义字段
	 * @param  {Function}   options.done            结果回调函数, 成功时会额外附上{@link Session|会话}
	 * @return {Void}
	 *
	 * @example
	 * nim.updateLocalSession({
	 *     id: 'p2p-account',
	 *     localCustom: '{"key","value"}',
	 *     done: updateLocalSessionDone
	 * });
	 * function updateLocalSessionDone(error, obj) {
	 *     console.log('更新本地会话' + (!error?'成功':'失败'), error, obj);
	 * }
	 */

	NIMFn.updateLocalSession = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  util.verifyOptions(options, 'id');
	  self.processCallback(options);
	  var session = util.filterObj(options, 'id localCustom');
	  if (db.enable) {
	    db.updateSession(session).then(function (record) {
	      session = record;
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    self.protocol.onUpdateSession(session);
	    options.session = session;
	    options.done(error, options);
	  }
	};

	/**
	 * 删除本地会话
	 *
	 * - 在{@link support.db|支持数据库}时, 删了本地会话之后, 下次同步就同步不到对应的会话
	 * - 如果不{@link support.db|支持数据库}, 算成功
	 * - 如果对应的会话不存在, 算成功
	 *
	 * @method deleteLocalSession
	 * @memberOf NIM#
	 *
	 * @param  {Object}             options         配置参数
	 * @param  {String|String[]}    options.id      会话 id 或 id 数组
	 * @param  {Function}           options.done    结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.deleteLocalSession({
	 *     id: 'p2p-account',
	 *     done: deleteLocalSessionDone
	 * });
	 * function deleteLocalSessionDone(error, obj) {
	 *     console.log('删除本地会话' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.deleteLocalSession = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  util.verifyOptions(options, 'id');
	  self.processCallback(options);
	  if (db.enable) {
	    db.deleteSession(options.id).then(function () {
	      self.protocol.deleteLocalSession(options.id);
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    options.done(error, options);
	  }
	};

	/**
	 * 删除服务器上的会话
	 *
	 * - 删了服务器上的会话之后, 在不{@link support.db|支持数据库}时, 下次同步就同步不到对应的会话以及会话对应的漫游消息; 此外, 在新设备上也同步不到对应的会话以及会话对应的漫游消息
	 *
	 * @method deleteSession
	 * @memberOf NIM#
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.scene   {@link IMMessage.scene|场景}
	 * @param  {String} options.to      对方账号或群ID
	 * @param  {done}   options.done    结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.deleteSession({
	 *     scene: 'p2p',
	 *     to: 'account',
	 *     done: deleteSessionDone
	 * });
	 * function deleteSessionDone(error, obj) {
	 *     console.log('删除会话' + (!error?'成功':'失败'), error, obj);
	 * }
	 * @see {@link NIM#deleteSessions|批量删除服务器上的会话}
	 */
	NIMFn.deleteSession = function (options) {
	  util.verifyOptions(options, 'scene to');
	  this.processCallback(options);
	  options.sessions = [{
	    scene: options.scene,
	    to: options.to
	  }];
	  this.deleteSessions(options);
	};

	/**
	 * 批量删除服务器上的会话
	 *
	 * - 删了服务器上的会话之后, 在不{@link support.db|支持数据库}时, 下次同步就同步不到对应的会话以及会话对应的漫游消息; 此外, 在新设备上也同步不到对应的会话以及会话对应的漫游消息
	 *
	 * @method deleteSessions
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options             配置参数
	 * @param  {Session[]}  options.sessions    会话列表
	 * @param  {done}       options.done        结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.deleteSessions({
	 *     sessions: {[
	 *         scene: 'p2p',
	 *         to: 'account'
	 *     ], [
	 *         scene: 'p2p',
	 *         to: 'account1'
	 *     ]},
	 *     done: deleteSessionsDone
	 * });
	 * function deleteSessionsDone(error, obj) {
	 *     console.log('批量删除会话' + (!error?'成功':'失败'), error, obj);
	 * }
	 * @see {@link NIM#deleteSession|删除服务器上的会话}
	 */
	NIMFn.deleteSessions = function (options) {
	  util.verifyOptions(options, 'sessions');
	  util.verifyParamType('sessions', options.sessions, 'array');
	  options.sessions.forEach(function (session, index) {
	    util.verifyOptions(session, 'scene to', true, 'sessions[' + index + '].');
	  });
	  this.processCallback(options);
	  this.sendCmd('deleteSessions', {
	    sessions: options.sessions.map(function (session) {
	      return session.scene + '|' + session.to;
	    })
	  }, options.callback);
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var NIMFn = __webpack_require__(6).fn;
	var util = __webpack_require__(1);
	var undef = util.undef;
	var notundef = util.notundef;
	var SystemMessage = __webpack_require__(25);

	/**
	 * 标记系统通知为已收到
	 *
	 * - SDK 在收到系统通知后会更新系统通知未读数, 开发者需要调用此接口来通知 SDK 将某条系统通知标记为已读状态, 标记后会触发`onupdatesysmsgunread`回调
	 *
	 * @memberOf NIM#
	 * @method markSysMsgRead
	 *
	 * @param  {Object}     options                             配置参数
	 * @param  {SystemMessage|SystemMessage[]} options.sysMsgs  通过`onofflinesysmsgs`或者`onsysmsg`接收到的系统通知或者系统通知数组
	 * @param  {done}       options.done                        结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.markSysMsgRead({
	 *     sysMsgs: someSysMsg,
	 *     done: markSysMsgReadDone
	 * });
	 * function markSysMsgReadDone(error, obj) {
	 *     console.log(error);
	 *     console.log(obj);
	 *     console.log('标记系统通知为已收到' + (!error?'成功':'失败'));
	 * }
	 */
	NIMFn.markSysMsgRead = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  var promise = Promise.resolve();
	  var protocol = self.protocol;
	  util.verifyOptions(options, 'sysMsgs');
	  var sysMsgs = options.sysMsgs;
	  if (!util.isArray(sysMsgs)) {
	    sysMsgs = [sysMsgs];
	  }
	  // 如果支持数据库, 那么更新数据库记录;
	  // 如果不支持数据库, 那么直接修改字段即可
	  // - 如果不自动标记已读, 那么标记已读;
	  if (db.enable) {
	    promise = db.markSysMsgRead(sysMsgs).then(function (records) {
	      sysMsgs = records;
	      protocol.onUpdateSysMsg(records);
	    });
	  } else {
	    // 过滤掉已经标为已读的
	    sysMsgs = sysMsgs.filter(function (sysMsg) {
	      return !sysMsg.read;
	    });
	    if (sysMsgs.length) {
	      if (!protocol.options.autoMarkRead) {
	        protocol.markSysMsgRead(sysMsgs, true);
	      }
	      sysMsgs.forEach(function (sysMsg) {
	        sysMsg.read = true;
	      });
	      protocol.onUpdateSysMsg(sysMsgs);
	    }
	  }
	  // 更新系统通知未读数
	  promise.then(function () {
	    return protocol.reduceSysMsgUnread(sysMsgs);
	  }).then(bingo, function (event) {
	    error = event;
	    bingo();
	  });
	  function bingo() {
	    options.done(error, options);
	  }
	};

	/**
	 * 发送自定义系统通知
	 *
	 * - 开发者可以向其他用户或群发送自定义通知。
	 * - 自定义系统通知和自定义消息的区别如下
	 *     - 自定义消息属于{@link IMMessage|消息}, 会存储在云信的消息数据库中, 需要跟其他{@link IMMessage|消息}一同展现给用户。
	 *     - 自定义系统通知属于{@link SystemMessage|系统通知}, 用于第三方通知自己, 不会存储在云信的数据库中, SDK不会解析这些通知, SDK仅仅负责传递这些通知。
	 *
	 * @method sendCustomSysMsg
	 * @memberOf NIM#
	 *
	 * @param  {Object}         options                                 配置参数
	 * @param  {String}         options.scene                           场景跟{@link IMMessage.scene|消息场景}的一样, 分为`p2p(点对点)`和`team(群)`。
	 * @param  {String|Number}  options.to                              接收方, 帐号或者群id
	 * @param  {String}         options.content                         自定义系统通知的内容, 推荐使用JSON格式构建
	 * @param  {String}         [options.apnsText]                      apns推送文案, 仅对接收方为iOS设备有效
	 * @param  {String}         [options.pushPayload]                   自定义系统通知的推送属性
	 * - 推荐使用`JSON`格式构建, 非`JSON`格式的话, Web端会正常接收, 但是会被其它端丢弃
	 * @param  {Boolean}        [options.sendToOnlineUsersOnly=true]    是否只发送给在线用户。
	 *                                                                  true时只发送给在线用户, 如果接收方不在线, 这条通知将被丢弃。
	 *                                                                  适合发送即时通知, 比如正在输入。
	 *                                                                  false时假如接收方在线, 那么会立即收到该通知,
	 *                                                                  假如接收方不在线, 会在其上线后推送过去。
	 * @param  {Boolean}        [options.cc]                            是否抄送
	 * @param  {Boolean}        [options.isPushable=true]               是否需要推送
	 * @param  {Boolean}        [options.needPushNick=false]            是否需要推送昵称
	 * @param  {done}           options.done                            结果回调函数
	 * @return {String}         SDK生成的ID
	 *
	 * @see {@link NIM#sendCustomMsg|发送自定义消息}
	 *
	 * @example
	 * var content = {
	 *     type: 'type',
	 *     value: 'value'
	 * };
	 * content = JSON.stringify(content);
	 * var msgId = nim.sendCustomSysMsg({
	 *     scene: 'p2p',
	 *     to: 'account',
	 *     content: content,
	 *     sendToOnlineUsersOnly: false,
	 *     apnsText: content,
	 *     done: sendCustomSysMsgDone
	 * });
	 * console.log('正在发送p2p自定义系统通知, id=' + msgId);
	 * function sendCustomSysMsgDone(error, msg) {
	 *     console.log(error);
	 *     console.log(msg);
	 *     console.log('发送' + msg.scene + '自定义系统通知' + (!error?'成功':'失败') + ', id=' + msg.idClient);
	 * }
	 */
	NIMFn.sendCustomSysMsg = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'scene to content');
	  util.verifyParamValid('scene', options.scene, self.message.validScenes);
	  self.processCallback(options);
	  if (options.scene === 'p2p') {
	    options.type = 'customP2p';
	  } else {
	    options.type = 'customTeam';
	  }
	  options.sysMsg = new SystemMessage(options);
	  var cmd = 'sendCustomSysMsg';
	  // 是否是过滤消息
	  if (options.filter) {
	    cmd = 'sendFilterCustomSysMsg';
	  }
	  self.sendCmd(cmd, { sysMsg: options.sysMsg, single: true }, options.callback);
	  return self.formatReturnSysMsg(options.sysMsg);
	};

	NIMFn.formatReturnSysMsg = function (sysMsg) {
	  var self = this;
	  sysMsg = util.copy(sysMsg);
	  self.protocol.completeSysMsg(sysMsg);
	  sysMsg.status = 'sending';
	  sysMsg = SystemMessage.reverse(sysMsg);
	  return sysMsg;
	};

	/**
	 * 获取本地系统通知
	 * - 如果不{@link support.db|支持数据库}, 算成功, 返回空数组
	 *
	 * @method getLocalSysMsgs
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options                 配置参数
	 * @param  {String}     [options.category]      {@link SystemMessage.category|种类}
	 * @param  {String}     [options.type]          {@link SystemMessage.type|类型}
	 * @param {Boolean} [options.read] 可选
	 * - 如果不传, 默认获取所有已读和未读的系统通知
	 * - 如果传 `true`, 那么只获取已读的系统通知
	 * - 如果传 `false`, 那么只获取未读的系统通知
	 * @param  {String}     [options.lastIdServer]  上次查询的最后一条系统通知的`idServer`, 第一次不填
	 * @param  {Number}     [options.limit]         本次查询的消息数量限制, 最多 100 条, 默认 100 条
	 * @param  {Boolean}    [options.reverse=false] 默认`false`表示从最近的系统通知开始往前查找本地系统通知；
	 *                                              `true`表示从第一条系统通知开始往后查找本地系统通知
	 * @param  {done}       options.done            结果回调函数, 成功时会额外附上{@link SystemMessage|系统通知}列表
	 * @return {Void}
	 *
	 * @example
	 * nim.getLocalSysMsgs({
	 *     lastIdServer: 'lastIdServer',
	 *     limit: 100,
	 *     done: getLocalSysMsgsDone
	 * });
	 * function getLocalSysMsgsDone(error, obj) {
	 *     console.log(error);
	 *     console.log(obj);
	 *     console.log('获取本地系统通知' + (!error?'成功':'失败'));
	 *     if (!error) {
	 *         console.log(obj.sysMsgs);
	 *     }
	 * }
	 */
	NIMFn.getLocalSysMsgs = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  var sysMsgs = [];
	  util.verifyOptions(options);
	  if (options.category) {
	    util.verifyParamValid('category', options.category, SystemMessage.validCategories);
	  }
	  if (options.type) {
	    util.verifyParamValid('type', options.type, SystemMessage.validTypes);
	  }
	  if (undef(options.limit)) {
	    options.limit = 100;
	  }
	  util.verifyParamType('limit', options.limit, 'number');
	  util.verifyParamMax('limit', options.limit, 100);
	  if (notundef(options.reverse)) {
	    util.verifyParamType('reverse', options.reverse, 'boolean');
	  } else {
	    options.reverse = false;
	  }
	  self.processCallback(options);

	  if (db.enable) {
	    db.getSysMsgs(options).then(function (records) {
	      sysMsgs = records;
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    options.sysMsgs = sysMsgs;
	    options.done(error, options);
	  }
	};

	/**
	 * 更新本地系统通知
	 * - 更新 `idServer` 对应的本地系统通知
	 * - 如果不{@link support.db|支持数据库}, 算成功
	 * - 如果对应的系统通知不存在, 算成功, 返回 null
	 * - 这些字段只会被更新到本地数据库, 不会被更新到服务器上
	 *
	 * @method updateLocalSysMsg
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options                 配置参数
	 * @param  {String}     options.idServer        idServer
	 * @param  {String}     [options.status]        状态
	 * @param  {String}     [options.localCustom]   自定义字段
	 * @param  {Function}   options.done            结果回调函数, 成功时会额外附上{@link SystemMessage|系统通知}
	 * @return {Void}
	 *
	 * @example
	 * nim.updateLocalSysMsg({
	 *     idServer: '1234',
	 *     status: 'bingo',
	 *     localCustom: '{"key","value"}',
	 *     done: updateLocalSysMsgDone
	 * });
	 * function updateLocalSysMsgDone(error, obj) {
	 *     console.log(error);
	 *     console.log(obj);
	 *     console.log('更新本地系统通知' + (!error?'成功':'失败'));
	 * }
	 */
	NIMFn.updateLocalSysMsg = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  var sysMsg = null;
	  util.verifyOptions(options, 'idServer');
	  self.processCallback(options);
	  if (db.enable) {
	    var obj = util.filterObj(options, 'idServer state localCustom');
	    db.updateSysMsg(obj).then(function (reocrd) {
	      sysMsg = reocrd;
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    options.sysMsg = sysMsg;
	    options.done(error, options);
	  }
	};

	/**
	 * 删除本地系统通知
	 * - 删除 `idServer` 对应的本地系统通知
	 * - 如果不{@link support.db|支持数据库}, 算成功
	 * - 如果对应的系统通知不存在, 算成功
	 *
	 * @method deleteLocalSysMsg
	 * @memberOf NIM#
	 *
	 * @param  {Object}             options             配置参数
	 * @param  {String|String[]}    options.idServer    idServer 或 idServer 数组
	 * @param  {Function}           options.done        结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.deleteLocalSysMsg({
	 *     idServer: '1234',
	 *     done: deleteLocalSysMsgDone
	 * });
	 * function deleteLocalSysMsgDone(error, obj) {
	 *     console.log(error);
	 *     console.log(obj);
	 *     console.log('删除本地系统通知' + (!error?'成功':'失败'));
	 * }
	 */
	NIMFn.deleteLocalSysMsg = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  util.verifyOptions(options, 'idServer');
	  self.processCallback(options);
	  if (db.enable) {
	    db.deleteSysMsg(options.idServer).then(function () {
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    options.done(error, options);
	  }
	};

	/**
	 * 删除所有本地系统通知
	 * - 如果不{@link support.db|支持数据库}, 算成功
	 *
	 * @method deleteAllLocalSysMsgs
	 * @memberOf NIM#
	 *
	 * @param  {Object}             options             配置参数
	 * @param  {Function}           options.done        结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.deleteAllLocalSysMsgs({
	 *     done: deleteAllLocalSysMsgsDone
	 * });
	 * function deleteAllLocalSysMsgsDone(error, obj) {
	 *     console.log(error);
	 *     console.log(obj);
	 *     console.log('删除所有本地系统通知' + (!error?'成功':'失败'));
	 * }
	 */
	NIMFn.deleteAllLocalSysMsgs = function (options) {
	  var error;
	  var self = this;
	  var db = self.db;
	  self.processCallback(options);
	  if (db.enable) {
	    db.deleteAllSysMsgs().then(function () {
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  }
	  function bingo() {
	    self.protocol.onUpdateSysMsgUnread({});
	    options.done(error, options);
	  }
	};

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIMFn = __webpack_require__(6).fn;
	var util = __webpack_require__(1);
	var undef = util.undef;
	var Team = __webpack_require__(26);
	var TeamMember = __webpack_require__(20);

	/**
	 * 创建群
	 *
	 * - {@link Team.type|普通群}不可以设置{@link Team.joinMode|群加入方式}
	 * - {@link Team.type|高级群}的{@link Team.joinMode|群加入方式}默认为`'needVerify'`
	 * - {@link Team.type|高级群}的{@link Team.beInviteMode|群被邀请模式}默认为`'needVerify'`
	 * - {@link Team.type|高级群}的{@link Team.inviteMode|群邀请模式}默认为`'manager'`
	 * - {@link Team.type|高级群}的{@link Team.updateTeamMode|群信息修改权限}默认为`'manager'`
	 * - {@link Team.type|高级群}的{@link Team.updateCustomMode|群信息自定义字段修改权限}默认为`'manager'`
	 * - {@link Team.type|普通群}被邀请的{@link TeamMember|群成员}在有人说话之后才会看到该{@link Team|群}, 而且会先收到一条类型为{@link IMMessage.attach.type|'addTeamMembers'}的{@link IMMessage.type|群通知消息}, 然后会收到其它{@link IMMessage.scene|群消息}。
	 * - {@link Team.type|高级群}被邀请的{@link TeamMember|群成员}会收到一条类型为{@link SystemMessage.type|'teamInvite'}的{@link SystemMessage|系统通知}。
	 *     - 接受邀请后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|'acceptTeamInvite'}的{@link IMMessage.type|群通知消息}。
	 *     - 拒绝邀请后, `群主`会收到一条类型为{@link IMMessage.attach.type|'rejectTeamInvite'}的{@link SystemMessage|系统通知}。
	 *
	 * @method createTeam
	 * @memberOf NIM#
	 *
	 * @param  {Object}   options                   配置参数
	 * @param  {String}   options.type              {@link Team.type|群类型}
	 * @param  {String}   options.name              群名字
	 * @param  {String}   options.avatar            群头像
	 * @param  {String[]} options.accounts          要拉进群的成员的帐号列表
	 * @param  {String}   [options.intro]           群简介
	 * @param  {String}   [options.announcement]    群公告
	 * @param  {String}   [options.joinMode]        {@link Team.joinMode|群加入方式}
	 * @param  {String}   [options.beInviteMode]    {@link Team.beInviteMode|群被邀请模式}
	 * @param  {String}   [options.inviteMode]      {@link Team.inviteMode|群邀请模式}
	 * @param  {String}   [options.updateTeamMode]  {@link Team.updateTeamMode|群信息修改权限}
	 * @param  {String}   [options.updateCustomMode]{@link Team.updateCustomMode|群信息自定义字段修改权限}
	 * @param  {String}   [options.custom]          扩展字段
	 * @param  {String}   [options.ps]              附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
	 * @param  {done}     options.done              结果回调函数, 成功时会收到{@link Team|群资料}
	 * @return {Void}
	 *
	 * @see {@link NIM#addTeamMembers|拉人入群}
	 * @see {@link NIM#removeTeamMembers|踢人出群}
	 * @see {@link NIM#updateTeam|更新群}
	 *
	 * @example
	 * // 创建普通群
	 * nim.createTeam({
	 *     type: 'normal',
	 *     name: '普通群',
	 *     avatar: 'avatar',
	 *     accounts: ['a1', 'a2'],
	 *     ps: '我建了一个普通群',
	 *     done: createTeamDone
	 * });
	 * // 创建高级群
	 * nim.createTeam({
	 *     type: 'advanced',
	 *     name: '高级群',
	 *     avatar: 'avatar',
	 *     accounts: ['a1', 'a2'],
	 *     intro: '群简介',
	 *     announcement: '群公告',
	 *     // joinMode: 'needVerify',
	 *     // beInviteMode: 'needVerify',
	 *     // inviteMode: 'manager',
	 *     // updateTeamMode: 'manager',
	 *     // updateCustomMode: 'manager',
	 *     ps: '我建了一个高级群',
	 *     done: createTeamDone
	 * });
	 * function createTeamDone(error, obj) {
	 *     console.log('创建' + obj.team.type + '群' + (!error?'成功':'失败'), error, obj);
	 *     if (!error) {
	 *         onCreateTeam(obj.team, obj.owner);
	 *     }
	 * }
	 */
	NIMFn.createTeam = function (options) {
	  util.verifyOptions(options, 'type name');
	  if (undef(options.accounts)) {
	    options.accounts = [];
	  } else {
	    util.verifyParamType('accounts', options.accounts, 'array');
	  }
	  options.action = 'create';
	  this.processPs(options);
	  this.processCallback(options);
	  options.team = new Team(options);
	  var content = {
	    team: options.team,
	    accounts: options.accounts.slice(0),
	    ps: options.ps
	  };
	  this.sendCmd('createTeam', content, options.callback);
	};

	/**
	 * 更新群
	 *
	 * - {@link Team.type|普通群}不可以更新
	 *     - {@link Team.joinMode|群加入方式}
	 *     - {@link Team.beInviteMode|群被邀请模式}
	 *     - {@link Team.inviteMode|群邀请模式}
	 *     - {@link Team.updateTeamMode|群信息修改权限}
	 *     - {@link Team.updateCustomMode|群信息自定义字段修改权限}
	 * - {@link NIM#updateTeam|更新群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'updateTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为更新群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为被更新的{@link Team|群信息}。
	 *
	 * @method updateTeam
	 * @memberOf NIM#
	 *
	 * @param  {Object}   options                   配置参数
	 * @param  {String}   options.teamId            群id
	 * @param  {String}   [options.name]            群名字
	 * @param  {String}   [options.avatar]          群头像
	 * @param  {String}   [options.intro]           群简介
	 * @param  {String}   [options.announcement]    群公告
	 * @param  {String}   [options.joinMode]        {@link Team.joinMode|群加入方式}
	 * @param  {String}   [options.beInviteMode]    {@link Team.beInviteMode|群被邀请模式}
	 * @param  {String}   [options.inviteMode]      {@link Team.inviteMode|群邀请模式}
	 * @param  {String}   [options.updateTeamMode]  {@link Team.updateTeamMode|群信息修改权限}
	 * @param  {String}   [options.updateCustomMode]{@link Team.updateCustomMode|群信息自定义字段修改权限}
	 * @param  {String}   [options.custom]          扩展字段
	 * @param  {done}     options.done              结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.updateTeam({
	 *     teamId: '123',
	 *     name: '群名字',
	 *     avatar: 'avatar',
	 *     intro: '群简介',
	 *     announcement: '群公告',
	 *     custom: '自定义字段',
	 *     done: updateTeamDone
	 * });
	 * function updateTeamDone(error, team) {
	 *     console.log('更新群' + (!error?'成功':'失败'), error, team);
	 * }
	 */
	NIMFn.updateTeam = function (options) {
	  util.verifyOptions(options, 'teamId');
	  options.action = 'update';
	  this.processCallback(options);
	  options.team = new Team(options);
	  this.sendCmd('updateTeam', { team: options.team, single: true }, options.callback);
	};

	/**
	 * 拉人入群
	 *
	 * - 普通群, {@link NIM#addTeamMembers|拉人入群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|``'addTeamMembers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为拉人的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的[群对象](#群对象), `attach`有一个字段`accounts`的值为被拉的人的帐号列表, `attach`有一个字段`members`的值为被拉的群成员列表。
	 *     - 被邀请的群成员在有人说话后才能看到该{@link Team|群}, 而且会先收到一条类型为{@link IMMessage.attach.type|`'addTeamMembers'`}的{@link IMMessage.type|群通知消息}, 然后会收到其它{@link Message|群消息}。
	 * - 高级群的群主和管理员在邀请成员加入群（通过操作{@link NIM#createTeam|创建群}或{@link NIM#addTeamMembers|拉人入群}）之后, 被邀请的人会收到一条类型为`'teamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为邀请方的帐号, `to`字段的值为对应的群ID, 此类系统通知的`attach`有一个字段`team`的值为被邀请进入的{@link Team|群}, 被邀请的人可以选择接受邀请或者拒绝邀请。
	 *     - 如果{@link NIM#acceptTeamInvite|接受入群邀请}, 那么该群的所有群成员会收到一条类型为`'acceptTeamInvite'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为接受入群邀请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`members`的值为接收入群邀请的群成员列表。
	 *     - 如果{@link NIM#rejectTeamInvite|拒绝入群邀请}, 那么邀请你的人会收到一条类型为`'rejectTeamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝入群邀请的人的帐号, `to`字段的值为对应的群ID。
	 *
	 * @method addTeamMembers
	 * @memberOf NIM#
	 *
	 * @param  {Object}   options             配置参数
	 * @param  {String}   options.teamId      群id
	 * @param  {String[]} options.accounts    要拉进群的成员的帐号列表
	 * @param  {String}   [options.ps]        附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
	 * @param  {done}     options.done        结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#acceptTeamInvite|接受入群邀请}
	 * @see {@link NIM#rejectTeamInvite|拒绝入群邀请}
	 * @see {@link NIM#removeTeamMembers|踢人出群}
	 *
	 * @example
	 * nim.addTeamMembers({
	 *     teamId: '123',
	 *     accounts: ['a3', 'a4'],
	 *     ps: '加入我们的群吧',
	 *     done: addTeamMembersDone
	 * });
	 * function addTeamMembersDone(error, obj) {
	 *     console.log('入群邀请发送' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.addTeamMembers = function (options) {
	  util.verifyOptions(options, 'teamId accounts');
	  util.verifyParamType('accounts', options.accounts, 'array');
	  this.processPs(options);
	  this.processCallback(options);
	  var content = {
	    teamId: options.teamId,
	    accounts: options.accounts.slice(0),
	    ps: options.ps
	  };
	  this.sendCmd('addTeamMembers', content, options.callback);
	};

	/**
	 * 踢人出群
	 *
	 * - {@link NIM#removeTeamMembers|踢人出群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'removeTeamMembers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为踢人的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`accounts`的值为被踢的人的帐号列表。
	 *
	 * @method removeTeamMembers
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options             配置参数
	 * @param  {String}     options.teamId      群id
	 * @param  {String[]}   options.accounts    要移除的成员帐号列表
	 * @param  {done}       options.done        结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#addTeamMembers|拉人入群}
	 *
	 * @example
	 * nim.removeTeamMembers({
	 *     teamId: '123',
	 *     accounts: ['a3', 'a4'],
	 *     done: removeTeamMembersDone
	 * });
	 * function removeTeamMembersDone(error, obj) {
	 *     console.log('踢人出群' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.removeTeamMembers = function (options) {
	  util.verifyOptions(options, 'teamId accounts');
	  util.verifyParamType('accounts', options.accounts, 'array');
	  this.processCallback(options);
	  var content = {
	    teamId: options.teamId,
	    accounts: options.accounts.slice(0)
	  };
	  this.sendCmd('removeTeamMembers', content, options.callback);
	};

	/**
	 * 接受入群邀请
	 *
	 * - 高级群的群主和管理员在邀请成员加入群（通过操作{@link NIM#createTeam|创建群}或{@link NIM#addTeamMembers|拉人入群}）之后, 被邀请的人会收到一条类型为`'teamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为邀请方的帐号, `to`字段的值为对应的群ID, 此类系统通知的`attach`有一个字段`team`的值为被邀请进入的{@link Team|群}, 被邀请的人可以选择接受邀请或者拒绝邀请。
	 *     - 如果{@link NIM#acceptTeamInvite|接受入群邀请}, 那么该群的所有群成员会收到一条类型为`'acceptTeamInvite'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为接受入群邀请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`members`的值为接收入群邀请的群成员列表。
	 *     - 如果{@link NIM#rejectTeamInvite|拒绝入群邀请}, 那么邀请你的人会收到一条类型为`'rejectTeamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝入群邀请的人的帐号, `to`字段的值为对应的群ID。
	 *
	 * @method acceptTeamInvite
	 * @memberOf NIM#
	 *
	 * @param  {Object}   options           配置参数
	 * @param  {String}   options.idServer  对应的系统通知的 `idServer`
	 * @param  {String}   options.teamId    群id
	 * @param  {String}   options.from      邀请方的帐号
	 * @param  {done}     options.done      结果回调函数, 成功时会收到{@link Team|群资料}
	 * @return {Void}
	 *
	 * @see {@link NIM#rejectTeamInvite|拒绝入群邀请}
	 * @see {@link NIM#addTeamMembers|拉人入群}
	 * @see {@link NIM#getTeamMembers|获取群成员}
	 *
	 * @example
	 * // 假设 sysMsg 是通过回调 `onsysmsg` 收到的系统通知
	 * nim.acceptTeamInvite({
	 *     idServer: sysMsg.idServer,
	 *     teamId: '123',
	 *     from: 'zyy1',
	 *     done: acceptTeamInviteDone
	 * });
	 * function acceptTeamInviteDone(error, obj) {
	 *     console.log('接受入群邀请' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.acceptTeamInvite = function (options) {
	  util.verifyOptions(options, 'idServer teamId from');
	  this.processCallback(options);
	  var content = {
	    idServer: options.idServer,
	    teamId: options.teamId,
	    from: options.from
	  };
	  this.sendCmd('acceptTeamInvite', content, options.callback);
	};

	/**
	 * 拒绝入群邀请
	 *
	 * - 高级群的群主和管理员在邀请成员加入群（通过操作{@link NIM#createTeam|创建群}或{@link NIM#addTeamMembers|拉人入群}）之后, 被邀请的人会收到一条类型为`'teamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为邀请方的帐号, `to`字段的值为对应的群ID, 此类系统通知的`attach`有一个字段`team`的值为被邀请进入的{@link Team|群}, 被邀请的人可以选择接受邀请或者拒绝邀请。
	 *     - 如果{@link NIM#acceptTeamInvite|接受入群邀请}, 那么该群的所有群成员会收到一条类型为`'acceptTeamInvite'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为接受入群邀请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`members`的值为接收入群邀请的群成员列表。
	 *     - 如果{@link NIM#rejectTeamInvite|拒绝入群邀请}, 那么邀请你的人会收到一条类型为`'rejectTeamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝入群邀请的人的帐号, `to`字段的值为对应的群ID。
	 *
	 * @method rejectTeamInvite
	 * @memberOf NIM#
	 *
	 * @param  {Object}   options           配置参数
	 * @param  {String}   options.idServer  对应的系统通知的 `idServer`
	 * @param  {String}   options.teamId    群id
	 * @param  {String}   options.from      邀请方的帐号
	 * @param  {String}   [options.ps]      附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
	 * @param  {done}     options.done      结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#acceptTeamInvite|接受入群邀请}
	 * @see {@link NIM#addTeamMembers|拉人入群}
	 *
	 * @example
	 * // 假设 sysMsg 是通过回调 `onsysmsg` 收到的系统通知
	 * nim.rejectTeamInvite({
	 *     idServer: sysMsg.idServer,
	 *     teamId: '123',
	 *     from: 'zyy1',
	 *     ps: '就不',
	 *     done: rejectTeamInviteDone
	 * });
	 * function rejectTeamInviteDone(error, obj) {
	 *     console.log('拒绝入群邀请' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.rejectTeamInvite = function (options) {
	  util.verifyOptions(options, 'idServer teamId from');
	  this.processPs(options);
	  this.processCallback(options);
	  var content = {
	    idServer: options.idServer,
	    teamId: options.teamId,
	    from: options.from,
	    ps: options.ps
	  };
	  this.sendCmd('rejectTeamInvite', content, options.callback);
	};

	/**
	 * 申请入群
	 *
	 * - 用户可以主动{@link NIM#applyTeam|申请加入高级群}, 目标群的群主和管理员会收到一条类型为`'applyTeam'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为对应的群ID, 高级群的群主和管理员在收到入群申请后, 可以选择通过或者拒绝入群申请。
	 *     - 如果{@link NIM#passTeamApply|通过入群申请}, 那么该群的所有群成员会收到一条类型为`'passTeamApply'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为通过入群申请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`包含了申请方的帐号, `attach`有一个字段`members`的值为被通过申请的群成员列表。
	 *     - 如果{@link NIM#rejectTeamApply|拒绝入群申请}, 那么申请人会收到一条类型为`'rejectTeamApply'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群}。
	 *
	 * @method applyTeam
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options         配置参数
	 * @param  {String}     options.teamId  群id
	 * @param  {String}     [options.ps]    附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
	 * @param  {done}       options.done    结果回调函数, 成功时会收到{@link Team|群资料}
	 * @return {Void}
	 *
	 * @see {@link NIM#passTeamApply|通过入群申请}
	 * @see {@link NIM#rejectTeamApply|拒绝入群申请}
	 *
	 * @example
	 * nim.applyTeam({
	 *     teamId: '123',
	 *     ps: '请加',
	 *     done: applyTeamDone
	 * });
	 * function applyTeamDone(error, obj) {
	 *     console.log('申请入群' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.applyTeam = function (options) {
	  util.verifyOptions(options, 'teamId');
	  this.processPs(options);
	  this.processCallback(options);
	  var content = {
	    teamId: options.teamId,
	    ps: options.ps
	  };
	  this.sendCmd('applyTeam', content, options.callback);
	};

	/**
	 * 通过入群申请
	 *
	 * - 用户可以主动{@link NIM#applyTeam|申请加入高级群}, 目标群的群主和管理员会收到一条类型为`'applyTeam'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为对应的群ID, 高级群的群主和管理员在收到入群申请后, 可以选择通过或者拒绝入群申请。
	 *     - 如果{@link NIM#passTeamApply|通过入群申请}, 那么该群的所有群成员会收到一条类型为`'passTeamApply'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为通过入群申请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`包含了申请方的帐号, `attach`有一个字段`members`的值为被通过申请的群成员列表。
	 *     - 如果{@link NIM#rejectTeamApply|拒绝入群申请}, 那么申请人会收到一条类型为`'rejectTeamApply'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群}。
	 *
	 * @method passTeamApply
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options             配置参数
	 * @param  {String}     options.idServer    对应的系统通知的 `idServer`
	 * @param  {String}     options.teamId      群ID
	 * @param  {String}     options.from        申请方的帐号
	 * @param  {done}       options.done        结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#applyTeam|申请入群}
	 * @see {@link NIM#rejectTeamApply|拒绝入群申请}
	 *
	 * @example
	 * // 假设 sysMsg 是通过回调 `onsysmsg` 收到的系统通知
	 * nim.passTeamApply({
	 *     idServer: sysMsg.idServer,
	 *     teamId: '123',
	 *     from: 'a2',
	 *     done: passTeamApplyDone
	 * });
	 * function passTeamApplyDone(error, obj) {
	 *     console.log('通过入群申请' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.passTeamApply = function (options) {
	  util.verifyOptions(options, 'idServer teamId from');
	  this.processCallback(options);
	  var content = {
	    idServer: options.idServer,
	    teamId: options.teamId,
	    from: options.from
	  };
	  this.sendCmd('passTeamApply', content, options.callback);
	};

	/**
	 * 拒绝入群申请
	 *
	 * - 用户可以主动{@link NIM#applyTeam|申请加入高级群}, 目标群的群主和管理员会收到一条类型为`'applyTeam'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为对应的群ID, 高级群的群主和管理员在收到入群申请后, 可以选择通过或者拒绝入群申请。
	 *     - 如果{@link NIM#passTeamApply|通过入群申请}, 那么该群的所有群成员会收到一条类型为`'passTeamApply'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为通过入群申请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`包含了申请方的帐号, `attach`有一个字段`members`的值为被通过申请的群成员列表。
	 *     - 如果{@link NIM#rejectTeamApply|拒绝入群申请}, 那么申请人会收到一条类型为`'rejectTeamApply'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群}。
	 *
	 * @method rejectTeamApply
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options             配置参数
	 * @param  {String}     options.idServer    对应的系统通知的 `idServer`
	 * @param  {String}     options.teamId      群ID
	 * @param  {String}     options.from        申请方的帐号
	 * @param  {String}     [options.ps]        附言, 选填, 开发者也可以使用JSON格式的字符串来扩展此内容
	 * @param  {done}       options.done        结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#applyTeam|申请入群}
	 * @see {@link NIM#passTeamApply|通过入群申请}
	 *
	 * @example
	 * // 假设 sysMsg 是通过回调 `onsysmsg` 收到的系统通知
	 * nim.rejectTeamApply({
	 *     idServer: sysMsg.idServer,
	 *     teamId: '123',
	 *     from: 'a2',
	 *     ps: '就不',
	 *     done: rejectTeamApplyDone
	 * });
	 * function rejectTeamApplyDone(error, obj) {
	 *     console.log('拒绝入群申请' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.rejectTeamApply = function (options) {
	  util.verifyOptions(options, 'idServer teamId from');
	  this.processPs(options);
	  this.processCallback(options);
	  var content = {
	    idServer: options.idServer,
	    teamId: options.teamId,
	    from: options.from,
	    ps: options.ps
	  };
	  this.sendCmd('rejectTeamApply', content, options.callback);
	};

	/**
	 * 添加群管理员
	 *
	 * - {@link NIM#addTeamManagers|添加群管理员}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'addTeamManagers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为添加群管理员的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`accounts`的值为被加为管理员的帐号列表, `attach`有一个字段`members`的值为被加为管理员的群成员列表。
	 *
	 * @method addTeamManagers
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options             配置参数
	 * @param  {String}     options.teamId      群id
	 * @param  {String[]}   options.accounts    要添加的管理员帐号列表
	 * @param  {done}       options.done        结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#removeTeamManagers|移除群管理员}
	 *
	 * @example
	 * nim.addTeamManagers({
	 *     teamId: '123',
	 *     accounts: ['a2', 'a3'],
	 *     done: addTeamManagersDone
	 * });
	 * function addTeamManagersDone(error, obj) {
	 *     console.log('添加群管理员' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.addTeamManagers = function (options) {
	  util.verifyOptions(options, 'teamId accounts');
	  util.verifyParamType('accounts', options.accounts, 'array');
	  this.processCallback(options);
	  var content = {
	    teamId: options.teamId,
	    accounts: options.accounts.slice(0)
	  };
	  this.sendCmd('addTeamManagers', content, options.callback);
	};

	/**
	 * 移除群管理员
	 *
	 * - {@link NIM#removeTeamManagers|移除群管理员}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'removeTeamManagers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为移除群管理员的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`accounts`的值为被移除的管理员的帐号列表, `attach`有一个字段`members`的值为被移除管理员的群成员列表。
	 *
	 * @method removeTeamManagers
	 * @memberOf NIM#
	 *
	 * @param  {Object}   options             配置参数
	 * @param  {String}   options.teamId      群id
	 * @param  {String[]} options.accounts    要移除的管理员帐号列表
	 * @param  {done}     options.done        结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#addTeamManagers|添加群管理员}
	 *
	 * @example
	 * nim.removeTeamManagers({
	 *     teamId: '123',
	 *     accounts: ['a2', 'a3'],
	 *     done: removeTeamManagersDone
	 * });
	 * function removeTeamManagersDone(error, obj) {
	 *     console.log('移除群管理员' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.removeTeamManagers = function (options) {
	  util.verifyOptions(options, 'teamId accounts');
	  util.verifyParamType('accounts', options.accounts, 'array');
	  this.processCallback(options);
	  var content = {
	    teamId: options.teamId,
	    accounts: options.accounts.slice(0)
	  };
	  this.sendCmd('removeTeamManagers', content, options.callback);
	};

	/**
	 * 修改自己的群属性
	 *
	 * 目前支持修改的属性有这些
	 * - `nickInTeam`: 自己在群里面的群昵称
	 *     - 更新昵称后, 所有其它在线的{@link TeamMember|群成员}会收到{@link NIM|初始化SDK}时传入的`onupdateteammember`回调。
	 * - `muteTeam`: 是否关闭此群的消息提醒, `true`表示关闭提醒, 但是SDK仍然会收到这个群的消息, SDK只是记录这个设置, 具体根据这个设置要执行的操作由第三方APP决定, 设置之后可以调用接口{@link NIM#notifyForNewTeamMsg}来查询是否需要群消息通知
	 * - `custom`: 第三方扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
	 *
	 * @method updateInfoInTeam
	 * @memberOf NIM#
	 *
	 * @param  {Object}   options               配置参数
	 * @param  {String}   options.teamId        群id
	 * @param  {String}   [options.nickInTeam]  在群里面的昵称
	 * @param  {Boolean}  [options.muteTeam]    是否关闭此群的消息提醒, `true`表示关闭提醒, 但是SDK仍然会收到这个群的消息, SDK只是记录这个设置, 具体根据这个设置要执行的操作由第三方APP决定
	 * @param {Boolean} [options.custom] 第三方扩展字段, 开发者可以自行扩展, 建议封装成JSON格式字符串
	 * @param  {done}     options.done          结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#updateNickInTeam|修改别人的群昵称}
	 *
	 * @example
	 * nim.updateInfoInTeam({
	 *     teamId: '123',
	 *     // 此参数为可选参数
	 *     // nickInTeam: '群昵称',
	 *     // 静音群, 此参数为可选参数
	 *     // muteTeam: true,
	 *     // 第三方扩展字段
	 *     // custom: '{}'
	 *     done: updateInfoInTeamDone
	 * });
	 * function updateInfoInTeamDone(error, obj) {
	 *     console.log('修改自己的群属性' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.updateInfoInTeam = function (options) {
	  // 注意, 这里以后如果开放了更多的参数, 要在 TeamMember 里面加上相应的验证 verifyParamAtLeastPresentOne
	  util.verifyOptions(options, 'teamId');
	  this.processCallback(options);
	  this.sendCmd('updateInfoInTeam', { teamMember: new TeamMember(options), single: true }, options.callback);
	};

	/**
	 * 修改别人的群昵称
	 *
	 * - 所有其它在线的{@link TeamMember|群成员}会收到{@link NIM|初始化SDK}时传入的`onupdateteammember`回调
	 *
	 * @method updateNickInTeam
	 * @memberOf NIM#
	 *
	 * @param  {Object}   options             配置参数
	 * @param  {String}   options.teamId      群id
	 * @param  {String}   options.account     要修改昵称的{@link TeamMember|群成员}的帐号
	 * @param  {String}   options.nickInTeam  群昵称
	 * @param  {done}     options.done        结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#updateInfoInTeam|修改自己的群属性}
	 *
	 * @example
	 * nim.updateNickInTeam({
	 *     teamId: '123',
	 *     account: 'a2',
	 *     nickInTeam: '群昵称',
	 *     done: updateNickInTeamDone
	 * });
	 * function updateNickInTeamDone(error, obj) {
	 *     console.log('修改自己的群属性' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.updateNickInTeam = function (options) {
	  util.verifyOptions(options, 'teamId account');
	  this.processCallback(options);
	  this.sendCmd('updateNickInTeam', { teamMember: new TeamMember(options), single: true }, options.callback);
	};

	/**
	 * 更新群成员禁言状态
	 *
	 * - {@link NIM#updateMuteStateInTeam|更新群成员禁言状态}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'updateTeamMute'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为操作方, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`的值为被禁言的帐号, `attach`有一个字段`members`的值为被禁言的群成员列表。
	 *
	 * @method updateMuteStateInTeam
	 * @memberOf NIM#
	 *
	 * @param  {Object} options 配置参数
	 * @param  {String}   options.teamId      群id
	 * @param  {String}   options.account     要修改昵称的{@link TeamMember|群成员}的帐号
	 * @param  {Boolean}  options.mute        是否要禁言
	 * @param  {done}     options.done        结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.updateMuteStateInTeam({
	 *     teamId: '123',
	 *     account: 'a',
	 *     mute: true,
	 *     done: updateMuteStateInTeamDone
	 * })
	 * function updateMuteStateInTeamDone(error, obj) {
	 *     console.log('更新群成员禁言状态' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.updateMuteStateInTeam = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'teamId account mute');
	  self.processCallback(options);
	  options.mute = options.mute ? 1 : 0;
	  self.sendCmd('updateMuteStateInTeam', options);
	};

	/**
	 * 获取群禁言成员列表
	 *
	 * @method getMutedTeamMembers
	 * @memberOf NIM#
	 *
	 * @param  {Object} options 配置参数
	 * @param {String[]} options.teamId 群 ID
	 * @return {Void}
	 *
	 * @example
	 * nim.getMutedTeamMembers({
	 *   teamId: 'teamId',
	 *   done: getMutedTeamMembersDone
	 * })
	 * function getMutedTeamMembersDone (error, obj) {
	 *   console.log('获取群禁言成员列表' + (!error?'成功':'失败'));
	 * }
	 */
	NIMFn.getMutedTeamMembers = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'teamId');
	  self.processCallback(options);
	  self.sendCmd('getMutedTeamMembers', options);
	};

	/**
	 * 主动退群
	 *
	 * - {@link NIM#leaveTeam|主动退群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'leaveTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为退群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}。
	 *
	 * @method leaveTeam
	 * @memberOf NIM#
	 *
	 * @param  {Object}   options           配置参数
	 * @param  {String}   options.teamId    群id
	 * @param  {done}     options.done      结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.leaveTeam({
	 *     teamId: '123',
	 *     done: leaveTeamDone
	 * });
	 * function leaveTeamDone(error, obj) {
	 *     console.log('主动退群' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.leaveTeam = function (options) {
	  util.verifyOptions(options, 'teamId');
	  this.processCallback(options);
	  var content = {
	    teamId: options.teamId
	  };
	  this.sendCmd('leaveTeam', content, options.callback);
	};

	/**
	 * 转让群
	 *
	 * - {@link NIM#transferTeam|转让群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'transferTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为转让群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`的值为为新群主的帐号, `attach`有一个字段`members`的值为包含新旧群主的群成员列表。
	 * - 如果转让群的同时离开群, 那么相当于调用{@link NIM#leaveTeam|主动退群}来离开群, 所有{@link TeamMember|群成员}会再收到一条类型为{@link IMMessage.attach.type|`'leaveTeam'`}的{@link IMMessage.type|群通知消息}。
	 *
	 * @method transferTeam
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options         配置参数
	 * @param  {String}     options.teamId  群id
	 * @param  {String}     options.account 新群主的帐号
	 * @param  {Boolean}    options.leave   转让群的同时是否离开群
	 * @param  {done}       options.done    结果回调函数
	 * @return {Void}
	 *
	 * @see {@link NIM#leaveTeam|离开群}
	 *
	 * @example
	 * nim.transferTeam({
	 *     teamId: '123',
	 *     account: 'zyy2',
	 *     leave: false,
	 *     done: transferOwnerDone
	 * });
	 * function transferOwnerDone(error, obj) {
	 *     console.log('转让群' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.transferTeam = function (options) {
	  util.verifyOptions(options, 'teamId account leave');
	  util.verifyParamType('leave', options.leave, 'boolean');
	  this.processCallback(options);
	  var content = {
	    teamId: options.teamId,
	    account: options.account,
	    leave: options.leave
	  };
	  this.sendCmd('transferTeam', content, options.callback);
	};

	/**
	 * 解散群
	 *
	 * - {@link NIM#dismissTeam|解散群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'dismissTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段为解散群的人的帐号, `to`字段的值为被对应的群ID。
	 *
	 * @method dismissTeam
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options         配置参数
	 * @param  {String}     options.teamId  群id
	 * @param  {done}       options.done    结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.dismissTeam({
	 *     teamId: '123',
	 *     done: dismissTeamDone
	 * });
	 * function dismissTeamDone(error, obj) {
	 *     console.log('解散群' + (!error?'成功':'失败'), error, obj);
	 * }
	 */
	NIMFn.dismissTeam = function (options) {
	  util.verifyOptions(options, 'teamId');
	  this.processCallback(options);
	  var content = {
	    teamId: options.teamId
	  };
	  this.sendCmd('dismissTeam', content, options.callback);
	};

	/**
	 * 获取群
	 *
	 * - 开发者可以调用此接口获取群资料
	 *
	 * @method getTeam
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options         配置参数
	 * @param  {String}     options.teamId  群id
	 * @param  {done}       options.done    结果回调函数, 成功时会收到{@link Team|群资料}
	 * @return {Void}
	 *
	 * @see {@link NIM#getTeams|获取群列表}
	 * @see {@link NIM#getTeamMembers|获取群成员}
	 *
	 * @example
	 * nim.getTeam({
	 *     teamId: '123',
	 *     done: getTeamDone
	 * });
	 * function getTeamDone(error, obj) {
	 *     console.log(error);
	 *     console.log(obj);
	 *     console.log('获取群' + (!error?'成功':'失败'));
	 * }
	 */
	NIMFn.getTeam = function (options) {
	  var self = this;
	  var db = self.db;
	  var teamId;
	  util.verifyOptions(options, 'teamId');
	  self.processCallback(options);

	  options.cbaop = function (error, obj) {
	    if (!error) {
	      log(obj);
	    }
	  };

	  teamId = options.teamId;
	  if (db.enable && !options.sync) {
	    db.getTeam(teamId).then(function (team) {
	      if (team) {
	        log(team);
	        options.done(null, team);
	      } else {
	        getTeamFromServer();
	      }
	    }, getTeamFromServer);
	  } else {
	    getTeamFromServer();
	  }
	  function getTeamFromServer() {
	    self.sendCmd('getTeam', { teamId: options.teamId }, options.callback);
	  }
	  function log(team) {
	    self.logger.warn('get team', teamId, team);
	  }
	};

	/**
	 * 获取群列表
	 *
	 * - 如果开发者在{@link NIM|初始化SDK}的时候设置了`syncTeams`为`false`, 那么就收不到`onteams`回调, 可以调用此接口来获取{@link Team|群}列表
	 *
	 * @method getTeams
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options         配置参数
	 * @param  {done}       options.done    结果回调函数, 成功时会收到{@link Team|群}列表
	 * @return {Void}
	 *
	 * @see {@link NIM#getTeam|获取群资料}
	 * @see {@link NIM#getTeamMembers|获取群成员}
	 *
	 * @example
	 * nim.getTeams({
	 *     done: getTeamsDone
	 * });
	 * function getTeamsDone(error, teams) {
	 *     console.log(error);
	 *     console.log(teams);
	 *     console.log('获取群列表' + (!error?'成功':'失败'));
	 * }
	 */
	NIMFn.getTeams = function (options) {
	  var self = this;
	  var db = self.db;
	  var timetag = 0;
	  util.verifyOptions(options);
	  self.processCallback(options);
	  if (db.enable) {
	    db.getTeamsTimetag().then(function (t) {
	      timetag = t;
	      getTeamsFromServer();
	    }, getTeamsFromServer);
	  } else {
	    getTeamsFromServer();
	  }
	  function getTeamsFromServer() {
	    self.sendCmd('getTeams', { timetag: timetag, NOTSTORE: 'timetag' }, options.callback);
	  }
	};

	/**
	 * 获取群成员
	 *
	 * - 如果开发者在{@link NIM|初始化SDK}时选择设置了`syncTeamMembers`为`false`, 那么就收不到`onteammembers`回调, 可以调用此方法来获取{@link TeamMember|群成员}列表
	 * - 接受入群邀请之后调用此方法来获取{@link TeamMember|群成员}列表
	 *
	 * @method getTeamMembers
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options         配置参数
	 * @param  {String}     options.teamId  群id
	 * @param  {done}       options.done    结果回调函数, 成功时会额外附上{@link TeamMember|群成员}列表
	 * @return {Void}
	 *
	 * @see {@link NIM#getTeam|获取群资料}
	 * @see {@link NIM#getTeams|获取群列表}
	 *
	 * @example
	 * nim.getTeamMembers({
	 *     teamId: '123',
	 *     done: getTeamMembersDone
	 * });
	 * function getTeamMembersDone(error, obj) {
	 *     console.log(error);
	 *     console.log(obj);
	 *     console.log('获取群成员' + (!error?'成功':'失败'));
	 *     if (!error) {
	 *         onTeamMembers(obj);
	 *     }
	 * }
	 */
	NIMFn.getTeamMembers = function (options) {
	  var self = this;
	  var timetag = 0;
	  util.verifyOptions(options, 'teamId');
	  self.processCallback(options);
	  // var db = self.db
	  // if (db.enable && !options.sync) {
	  //   db.getTeam(options.teamId).then(function (team) {
	  //     if (team) {
	  //       var serverTimetag = team.memberUpdateTime
	  //       db.getTeamMembersTimetag(options.teamId).then(function (localTimetag) {
	  //           // 如果服务器的时间戳比本地的小, 说明最近同步过, 那么直接从本地获取群成员
	  //         if (!isNaN(serverTimetag) && !isNaN(localTimetag) && serverTimetag <= localTimetag) {
	  //             db.getTeamMembers(options.teamId).then(function (members) {
	  //               options.done(null, {
	  //                 teamId: options.teamId,
	  //                 members: members
	  //               })
	  //             }, getTeamMembersFromServer)
	  //           } else {
	  //             timetag = localTimetag
	  //             getTeamMembersFromServer()
	  //           }
	  //       }, getTeamMembersFromServer)
	  //     } else {
	  //       getTeamMembersFromServer()
	  //     }
	  //   }, getTeamMembersFromServer)
	  // } else {
	  //   getTeamMembersFromServer()
	  // }
	  // 群成员数据一律从服务器同步
	  getTeamMembersFromServer();
	  function getTeamMembersFromServer() {
	    self.sendCmd('getTeamMembers', { teamId: options.teamId, timetag: timetag, NOTSTORE: 'timetag' }, options.callback);
	  }
	};

	/**
	 * 是否需要群消息通知
	 *
	 * @method notifyForNewTeamMsg
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options  配置参数
	 * @param {String[]}    options.teamIds 群列表
	 * @param  {done}       options.done    结果回调函数, 成功时会附上一个 map, key 是群 ID, value 是一个布尔值, 表示该群是否需要群消息通知
	 * @return {Void}
	 *
	 * @example
	 * nim.notifyForNewTeamMsg({
	 *     teamIds: ['123'],
	 *     done: notifyForNewTeamMsgDone
	 * })
	 * function notifyForNewTeamMsgDone(error, map) {
	 *     console.log(error);
	 *     console.log(map);
	 *     console.log('查询是否需要群消息通知' + (!error?'成功':'失败'));
	 * }
	 */
	NIMFn.notifyForNewTeamMsg = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'teamIds');
	  var promise = self.protocol.notifyForNewTeamMsg(options.teamIds);
	  // if (self.usePromise(options)) {
	  //     return promise
	  // } else {
	  //   promise.then(function (map) {
	  //     options.done(null, map)
	  //   }, function (error) {
	  //     options.done(error)
	  //   })
	  // }
	  promise.then(function (map) {
	    options.done(null, map);
	  }, function (error) {
	    options.done(error);
	  });
	};

	/**
	 * 获取我所在的群对应的群成员
	 * @private
	 * @param  {Object} options 配置参数
	 * @param {String[]} options.teamIds 群 ID 数组
	 * @return {Void}
	 */
	NIMFn.getMyTeamMembers = function (options) {
	  var self = this;
	  util.verifyOptions(options, 'teamIds');
	  var promise = self.processCallbackPromise(options);
	  self.sendCmd('getMyTeamMembers', options);
	  return promise;
	};

	/**
	 * 获取`teamIds`对应的本地群
	 * - 如果不{@link support.db|支持数据库}, 算成功
	 *
	 * @method getLocalTeams
	 * @memberOf NIM#
	 *
	 * @param  {Object}      options         配置参数
	 * @param  {String[]}    options.teamIds teamId 数组
	 * @param  {Function}    options.done    结果回调函数, 成功时会额外附上群列表
	 * @return {Void}
	 *
	 * @example
	 * nim.getLocalTeams({
	 *     teamIds: teamIds
	 *     done: getLocalTeamsDone
	 * });
	 * function getLocalTeamsDone(error, obj) {
	 *     console.log('获取本地群' + (!error?'成功':'失败'));
	 *     console.log(error);
	 *     console.log(obj);
	 * }
	 */
	NIMFn.getLocalTeams = function (options) {
	  var self = this;
	  var db = self.db;
	  var error,
	      teams = [];
	  util.verifyOptions(options, 'teamIds');
	  util.verifyParamType('teamIds', options.teamIds, 'array');
	  self.processCallback(options);
	  if (db.enable) {
	    db.getTeamsByTeamIds(options.teamIds).then(function (records) {
	      teams = records.filter(function (record) {
	        return !!record;
	      });
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    options.teams = teams;
	    options.done(error, options);
	  }
	};

	NIMFn.getLocalTeamMembers = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  var members = [];
	  util.verifyOptions(options, 'teamId accounts');
	  util.verifyParamType('accounts', options.accounts, 'array');
	  self.processCallback(options);
	  if (db.enable) {
	    db.getInvalidTeamMembers(options.teamId, options.accounts).then(function (records) {
	      members = records.filter(function (record) {
	        return !!record;
	      });
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    options.members = members;
	    options.done(error, options);
	  }
	};

	/**
	 * 删除 `teamId` 对应的本地群
	 * - 如果不{@link support.db|支持数据库}, 算成功
	 * - 如果当前用户还在群里面, 那么会失败
	 * - 如果对应的群不存在, 算成功
	 * - 如果传了多个 teamId, 但是当前用户还在某个群里面, 那么会失败, 但是所有用户不在的群都会被删掉
	 *
	 * @method deleteLocalTeam
	 * @memberOf NIM#
	 *
	 * @param  {Object}             options         配置参数
	 * @param  {String|String[]}    options.teamId  teamId 或者 teamId 数组
	 * @param  {Function}           options.done    结果回调函数
	 * @return {Void}
	 *
	 * @example
	 * nim.deleteLocalTeam({
	 *     teamId: '1234',
	 *     done: deleteLocalTeamDone
	 * });
	 * function deleteLocalTeamDone(error, obj) {
	 *     console.log('删除本地群' + (!error?'成功':'失败'));
	 *     console.log(error);
	 *     console.log(obj);
	 * }
	 */
	NIMFn.deleteLocalTeam = function (options) {
	  var self = this;
	  var db = self.db;
	  var error;
	  util.verifyOptions(options, 'teamId');
	  self.processCallback(options);
	  if (db.enable) {
	    db.deleteTeam(options.teamId).then(function () {
	      bingo();
	    }, function (event) {
	      error = event;
	      bingo();
	    });
	  } else {
	    bingo();
	  }
	  function bingo() {
	    options.done(error, options);
	  }
	};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIMFn = __webpack_require__(6).fn;
	var util = __webpack_require__(1);
	var objs2accounts = util.objs2accounts;
	var User = __webpack_require__(32);

	/**
	 * 更新我的名片
	 *
	 * @method updateMyInfo
	 * @memberOf NIM#
	 *
	 * @param  {Object} options         配置参数
	 * @param  {String} options.nick    昵称
	 * @param  {String} options.avatar  头像
	 * @param  {String} options.sign    签名
	 * @param  {String} options.gender  {@link User.gender|性别}
	 * @param  {String} options.email   邮箱
	 * @param  {String} options.birth   生日
	 * @param  {String} options.tel     手机号
	 * @param  {String} options.custom  扩展字段
	 * @return {Void}
	 *
	 * @see {@link NIM#getUser|获取用户名片}
	 * @see {@link NIM#getUsers|获取用户名片数组}
	 * @see {@link NIM#updateMyInfo|更新登录用户的名片}
	 *
	 * @example
	 * nim.updateMyInfo({
	 *     nick: 'newNick',
	 *     avatar: 'http://newAvatar',
	 *     sign: 'newSign',
	 *     gender: 'male',
	 *     email: 'new@email.com',
	 *     birth: '1900-01-01',
	 *     tel: '13523578129',
	 *     custom: '{type: "newCustom", value: "new"}',
	 *     done: updateMyInfoDone
	 * });
	 * function updateMyInfoDone(error, user) {
	 *     console.log('更新登录用户的名片' + (!error?'成功':'失败'), error, user);
	 *     if (!error) {
	 *         onUpdateMyInfo(user);
	 *     }
	 * }
	 */
	NIMFn.updateMyInfo = function (options) {
	    util.verifyOptions(options);
	    this.processCallback(options);
	    options.user = new User(options);
	    // 更新自己的名片不用传 account
	    delete options.user.account;
	    this.sendCmd('updateMyInfo', { user: options.user, single: true }, options.callback);
	};

	/**
	 * 获取我的名片
	 * @private
	 * @param  {Object} options 配置参数
	 * @return {Void}
	 */
	NIMFn.getMyInfo = function (options) {
	    var self = this;
	    options = options || {};
	    options.account = self.account;
	    return self.getUser(options);
	};

	/**
	 * 获取用户名片
	 *
	 * @method getUser
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options         配置参数
	 * @param  {String}     options.account 账号
	 * @param  {Function}   options.done    结果回调函数, 成功时会返回用户名片
	 * @return {Void}
	 *
	 * @see {@link NIM#getUser|获取用户名片}
	 * @see {@link NIM#getUsers|获取用户名片数组}
	 * @see {@link NIM#updateMyInfo|更新登录用户的名片}
	 *
	 * @example
	 * nim.getUser({
	 *     account: 'account',
	 *     done: getUserDone
	 * });
	 * function getUserDone(error, user) {
	 *     console.log('获取用户名片' + (!error?'成功':'失败'), error, obj);
	 *     if (!error && user) {
	 *         onUsers(user);
	 *     }
	 * }
	 */
	NIMFn.getUser = function (options) {
	    var self = this,
	        db = self.db,
	        account;
	    util.verifyOptions(options, 'account');
	    self.processCallback(options);

	    options.cbaop = function (error, obj) {
	        if (!error) {
	            obj = obj[0] || null;
	            log(obj);
	            return obj;
	        }
	    };

	    account = options.account;
	    if (options.sync) {
	        getUserFromServer();
	    } else {
	        if (db.enable) {
	            db.getUser(account).then(function (user) {
	                if (!!user) {
	                    log(user);
	                    options.done(null, user);
	                } else {
	                    getUserFromServer();
	                }
	            }, getUserFromServer);
	        } else {
	            getUserFromServer();
	        }
	    }
	    function getUserFromServer() {
	        self.sendCmd('getUsers', { accounts: [account], single: true }, options.callback);
	    }
	    function log(user) {
	        self.logger.warn('get user', account, user);
	    }
	};

	/**
	 * 获取用户名片数组
	 *
	 * - 每次最多 150 个
	 *
	 * @method getUsers
	 * @memberOf NIM#
	 *
	 * @param  {Object}     options             配置参数
	 * @param  {String[]}   options.accounts    账号数组
	 * @param  {Function}   options.done        结果回调函数, 成功时会返回用户名片列表
	 * @return {Void}
	 *
	 * @see {@link NIM#getUser|获取用户名片}
	 * @see {@link NIM#getUsers|获取用户名片数组}
	 * @see {@link NIM#updateMyInfo|更新登录用户的名片}
	 *
	 * @example
	 * nim.getUsers({
	 *     accounts: ['account1', 'account2'],
	 *     done: getUsersDone
	 * });
	 * function getUsersDone(error, users) {
	 *     console.log('获取用户名片数组' + (!error?'成功':'失败'), error, users);
	 *     if (!error && users.length) {
	 *         onUsers(users);
	 *     }
	 * }
	 */
	NIMFn.getUsers = function (options) {
	    var self = this,
	        db = self.db,
	        accounts,
	        usersLocal = [];
	    util.verifyOptions(options, 'accounts');
	    util.verifyParamType('accounts', options.accounts, 'array');
	    self.processCallback(options);

	    options.cbaop = function (error, obj) {
	        if (!error) {
	            obj = obj.concat(usersLocal);
	            log(obj);
	            return obj;
	        }
	    };

	    // 去重后校验长度
	    accounts = util.deduplicate(options.accounts);
	    util.verifyArrayMax('accounts', options.accounts, 150);

	    if (options.sync) {
	        getUsersFromServer();
	    } else {
	        if (db.enable) {
	            db.getUsers(accounts).then(function (users) {
	                if (!!users && users.length === accounts.length) {
	                    log(users);
	                    options.done(null, users);
	                } else {
	                    usersLocal = users;
	                    // 如果从数据库只拿到了部分用户名片, 那么从服务器获取剩下的用户名片
	                    var accountsLocal = objs2accounts(users);
	                    var accountsServer = [];
	                    accounts.forEach(function (account) {
	                        if (accountsLocal.indexOf(account) === -1) {
	                            accountsServer.push(account);
	                        }
	                    });
	                    accounts = accountsServer;
	                    getUsersFromServer();
	                }
	            }, getUsersFromServer);
	        } else {
	            getUsersFromServer();
	        }
	    }
	    function getUsersFromServer() {
	        self.sendCmd('getUsers', { accounts: accounts, single: true }, options.callback);
	    }
	    function log(users) {
	        self.logger.warn('get users', objs2accounts(users), users);
	    }
	};

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var DBFn = __webpack_require__(10).fn;
	var util = __webpack_require__(1);
	var notundef = util.notundef;
	var TableBroadcastMsg = 'broadcastMsg';

	DBFn.putBroadcastMsg = function (broadcastMsgs) {
	  var self = this;
	  return new Promise(function (resolve) {
	    if (!util.isArray(broadcastMsgs)) {
	      broadcastMsgs = [broadcastMsgs];
	    }
	    var array = [];
	    var counter = broadcastMsgs.length;
	    broadcastMsgs.forEach(function (broadcastMsg) {
	      broadcastMsg = util.copy(broadcastMsg);
	      self.put(TableBroadcastMsg, broadcastMsg).then(function (record) {
	        array.push(record[0]);
	        bingo();
	      }, bingo);
	    });
	    // 就算有失败, 也算完成, 最终返回所有存储成功的记录
	    function bingo() {
	      counter--;
	      if (counter === 0) {
	        resolve(array);
	      }
	    }
	  });
	};

	DBFn.getBroadcastMsgs = function (options) {
	  var self = this;
	  options = options || {};
	  return self.getAll(TableBroadcastMsg, options);
	};

/***/ },
/* 110 */
/***/ function(module, exports) {

	'use strict';

	var config = {
	  version: 8
	};

	var schema = {
	  kv: {
	    key: {
	      keyPath: 'key'
	    }
	  },
	  timetag: {
	    key: {
	      keyPath: 'name'
	    }
	  },
	  blacklist: {
	    key: {
	      keyPath: 'account'
	    }
	  },
	  mutelist: {
	    key: {
	      keyPath: 'account'
	    }
	  },
	  friend: {
	    key: {
	      keyPath: 'account'
	    }
	  },
	  user: {
	    key: {
	      keyPath: 'account'
	    }
	  },
	  team: {
	    key: {
	      keyPath: 'teamId'
	    }
	  },
	  teamMember: {
	    key: {
	      keyPath: 'id'
	    },
	    indexes: {
	      teamId: { unique: false },
	      account: { unique: false }
	    }
	  },
	  msg: {
	    key: {
	      // 用自增的 key, 这样存储顺序就是聊天的顺序
	      // 不指定 keyPath 这样取出来的数据不带 id 字段
	      // keyPath: 'id',
	      autoIncrement: true
	    },
	    indexes: {
	      idClient: { unique: true },
	      sessionId: { unique: false },
	      time: { unique: false },
	      type: { unique: false },
	      sessionType: { unique: false },
	      status: { unique: false },
	      sessionTime: {
	        key: ['sessionId', 'time'],
	        unique: false
	      }
	    }
	  },
	  msg1: {
	    key: {
	      keyPath: 'idClient'
	    },
	    indexes: {
	      sessionId: { unique: false },
	      time: { unique: false },
	      status: { unique: false },
	      sessionTime: {
	        key: ['sessionId', 'time'],
	        unique: false
	      }
	    }
	  },
	  broadcastMsg: {
	    key: {
	      keyPath: 'broadcastId'
	    },
	    indexes: {
	      time: {
	        unique: false
	      }
	    }
	  },
	  sysMsg: {
	    key: {
	      // 用自增的 key, 这样存储顺序就是聊天的顺序
	      // 不指定 keyPath 这样取出来的数据不带 id 字段
	      // keyPath: 'id',
	      autoIncrement: true
	    },
	    indexes: {
	      idServer: { unique: true },
	      category: { unique: false },
	      type: { unique: false }
	    }
	  },
	  sysMsgUnread: {
	    key: {
	      keyPath: 'type'
	    }
	  },
	  session: {
	    key: {
	      keyPath: 'id'
	    },
	    indexes: {
	      updateTime: { unique: false }
	    }
	  }
	};

	config.keyPath = function (objectStore) {
	  return schema[objectStore].key.keyPath;
	};

	config.schema = function () {
	  // 每次升级时, 强制全量同步群一次, 保证数据一致性, 某些数据不同步的话永远拿不下来了
	  // 比如说使用老版本的时候禁言了群, 对应的字段没有存储下来, 那么升级的时候如果不同步这个字段就没有
	  window._nimForceSyncIM = true;
	  return schema;
	};

	module.exports = config;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var DBFn = __webpack_require__(10).fn;
	var util = __webpack_require__(1);
	var TableFriend = 'friend';

	/*
	 * 更新好友、删除好友
	 * - 成功后更新对应的好友时间戳
	 */
	DBFn.mergeFriends = function (friends, friends2delete, timetag) {
	    var self = this;
	    return self.updateAndDelete(TableFriend, friends, friends2delete).then(function () {
	        self.logger.warn('merge friends');
	        // 此时间戳不一定有
	        if (timetag) {
	            self.updateFriendTimetag(timetag);
	        }
	        return [friends, friends2delete, timetag];
	    });
	};

	DBFn.putFriend = function (friend) {
	    return this.put(TableFriend, friend);
	};

	/*
	 * 更新好友, 加好友都走这里
	 */
	DBFn.updateFriend = function (friend) {
	    var self = this;
	    // 先复制, 不受外界干扰
	    friend = util.copy(friend);
	    var account = friend.account;
	    return this.getOne(TableFriend, null, account, {
	        modifyObj: friend
	    }).then(function (record) {
	        if (record) {
	            self.logger.warn('update friend', account, friend);
	        } else {
	            self.logger.warn('update friend no', account);
	        }
	        return record;
	    });
	};

	DBFn.deleteFriend = function (account) {
	    var self = this;
	    var p1 = self.remove(TableFriend, account);
	    var p2 = self.deleteUser(account);
	    return Promise.all([p1, p2]);
	};

	DBFn.getFriends = function () {
	    var filter = function filter(friend) {
	        return friend.valid;
	    };
	    return this.getAll(TableFriend, {
	        filter: filter
	    });
	};

	DBFn.getFriend = function (account) {
	    return this.getOne(TableFriend, null, account);
	};

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var DBFn = __webpack_require__(10).fn;
	var TableKV = 'kv';

	DBFn.setKey = function (key, value) {
	  return this.put(TableKV, {
	    key: key,
	    value: value
	  });
	};

	DBFn.getKey = function (key) {
	  return this.get(TableKV, key).then(function (record) {
	    return record && record.value;
	  });
	};

	DBFn.setDonnop = function (config) {
	  return this.setKey('donnop', config);
	};

	DBFn.getDonnop = function () {
	  return this.getKey('donnop');
	};

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var DBFn = __webpack_require__(10).fn;
	var util = __webpack_require__(1);
	var TableSession = 'session';
	var TableMsg = 'msg1';
	var IndexSession = 'sessionId';
	var IndexTime = 'time';
	var IndexStatus = 'status';
	var IndexSessionTime = 'sessionTime';

	/*
	 * 存储消息
	 */
	DBFn.putMsg = function (msgs) {
	  var self = this;
	  if (!util.isArray(msgs)) {
	    msgs = [msgs];
	  }
	  // 如果没有消息或者是过滤（云商服专用）, 直接返回
	  if (!msgs.length || msgs[0].filter) {
	    return Promise.resolve();
	  }
	  msgs = msgs.filter(function (msg) {
	    return !msg.ignore;
	  });
	  return self.put(TableMsg, msgs);
	};

	/*
	 * 更新消息
	 * 只允许更新 localCustom
	 */
	DBFn.updateMsg = function (msg) {
	  var self = this;
	  // 如果是过滤（云商服专用）, 直接返回
	  if (msg.filter) {
	    return;
	  }
	  var idClient = msg.idClient;
	  var modifyObj = util.filterObj(msg, 'resend status idServer time localCustom');
	  return self.getOne(TableMsg, null, idClient, {
	    modifyObj: modifyObj
	  }).then(function (record) {
	    if (record) {
	      self.logger.warn('update msg', idClient, modifyObj);
	    } else {
	      self.logger.warn('udpate msg no', idClient);
	    }
	    return record;
	  });
	};

	/**
	 *  获取消息列表
	 *
	 *  @private
	 *  @param  {Object} options  查询参数
	 *  @param {String} [options.sessionId] 如果提供该参数, 那么查询该会话的消息
	 *  @param {String[]} [options.sessionIds] 如果提供该参数, 那么查询这几个会话的消息
	 *  @param {Number} [options.start=0] 开始时间
	 *  @param {Number} [options.end=Infinity] 结束时间
	 *  @param {Boolean} [options.desc=true] true 表示从 end 开始查, false 表示从 begin 开始查
	 *  @param {Number} [options.limit=100] limit 数量限制
	 *  @param {String} [options.type] 如果提供该参数, 那么查询该类型的消息
	 *  @param {String[]} [options.types] 如果提供该参数, 那么查询这几种类型的消息
	 *  @param {String} [options.keyword] 如果提供参数, 那么查询匹配该关键词的消息
	 *  @param {Function} [options.filterFunc] 可选参数, 过滤函数, 接收消息对象, 返回 true 表示结果保留该消息
	 *  @return {Promise}
	 */
	DBFn.getMsgs = function (options) {
	  var self = this;
	  self.checkDB();

	  options = options || {};
	  var index = IndexTime;
	  // 检测是否按照会话过滤, 同时如果是单会话, 切换索引
	  var filterSession = false;
	  var multiSession = false;
	  var sessionId = options.sessionId;
	  var sessionIds = options.sessionIds;
	  if (util.exist(sessionId)) {
	    filterSession = true;
	    index = IndexSessionTime;
	  } else if (util.exist(sessionIds)) {
	    filterSession = true;
	    if (util.isString(sessionIds)) {
	      index = IndexSessionTime;
	      sessionId = sessionIds;
	    } else if (Array.isArray(sessionIds)) {
	      if (sessionIds.length === 1) {
	        index = IndexSessionTime;
	        sessionId = sessionIds[0];
	      } else {
	        multiSession = true;
	      }
	    }
	  }

	  // bound
	  var start = options.start || 0;
	  var end = options.end || Infinity;
	  var lowerBound = start;
	  var upperBound = end;
	  // 如果是搜索单个会话, 那么 bound 的值是不一样的
	  if (filterSession && !multiSession) {
	    lowerBound = [sessionId, start];
	    upperBound = [sessionId, end];
	  }

	  // order & limit
	  var desc = options.desc !== false;
	  var limit = options.limit || 100;

	  // 单类型还是多类型
	  var filterType = false;
	  var multiType = false;
	  var type = options.type;
	  var types = options.types;
	  if (util.exist(type)) {
	    filterType = true;
	  } else if (util.exist(types)) {
	    filterType = true;
	    if (util.isString(types)) {
	      type = types;
	    } else if (Array.isArray(types)) {
	      if (types.length === 1) {
	        type = types[0];
	      } else {
	        multiType = true;
	      }
	    }
	  }

	  var keyword = options.keyword || '';
	  var filterFunc = options.filterFunc;

	  var filter = void 0;
	  if (multiSession || filterType || keyword || util.isFunction(filterFunc)) {
	    filter = function filter(record) {
	      if (multiSession && sessionIds.indexOf(record.sessionId) === -1) {
	        return false;
	      }
	      if (filterType) {
	        if (multiType) {
	          if (types.indexOf(record.type) === -1) {
	            return false;
	          }
	        } else {
	          if (type !== record.type) {
	            return false;
	          }
	        }
	      }
	      if (keyword) {
	        var text = record.text || record.tip || '';
	        if (text.indexOf(keyword) === -1) {
	          return false;
	        }
	      }
	      if (filterFunc) {
	        return filterFunc(record);
	      }
	      return true;
	    };
	  }

	  return self.server.query(TableMsg, index).bound(lowerBound, upperBound, true, true).desc(desc).limit(limit).filter(filter).execute();
	};

	// 开启同步会话未读数时，计算未读数
	DBFn.getMsgCountAfterAck = function (options) {
	  var self = this;
	  options = options || {};
	  var _options = options,
	      sessionId = _options.sessionId;

	  self.checkDB();
	  return self.server.query(TableMsg, IndexSessionTime).bound([sessionId, options.ack], [sessionId, Infinity], true, true) // 不包含ack
	  // .count()
	  .execute().then(function (msgs) {
	    // 自己发的消息不算未读数，dbjs.filter函数有问题，手动算了
	    var returnMsgs = msgs.filter(function (msg) {
	      if (msg.flow === 'out') {
	        return false;
	      } else if (msg.type === 'notification') {
	        if (options.shouldCountNotifyUnread(msg)) {
	          return true;
	        } else {
	          return false;
	        }
	      }
	      return true;
	    });
	    return Promise.resolve(returnMsgs.length);
	  });
	};

	// 不返回给开发者某些属性，以及加一些额外的属性
	DBFn.amendMsg = function (msg) {
	  if (msg) {
	    // 如果没有 text 字段，补一个空的
	    if (util.notexist(msg.text)) {
	      msg.text = '';
	    }
	    return msg;
	  } else {
	    return null;
	  }
	};

	DBFn.getMsgByIdClient = function (idClient) {
	  var self = this;
	  return self.getOne(TableMsg, null, idClient).then(function (record) {
	    return self.amendMsg(record);
	  });
	};

	DBFn.getMsgsByIdClients = function (idClients) {
	  var self = this;
	  var array = [];
	  var promise;
	  idClients.forEach(function (idClient) {
	    promise = self.getMsgByIdClient(idClient);
	    array.push(promise);
	  });
	  return Promise.all(array);
	};

	DBFn.clearSendingMsgs = function () {
	  var self = this;
	  return self.getOnly(TableMsg, IndexStatus, 'sending', {
	    modifyObj: {
	      status: 'fail'
	    }
	  }).then(function (results) {
	    self.logger.warn('fail msgs', results);
	  });
	};

	// idClients 单个或数组
	DBFn.deleteMsg = function (idClients) {
	  var self = this;
	  var array = [];
	  var promise;
	  if (!util.isArray(idClients)) {
	    idClients = [idClients];
	  }
	  idClients.forEach(function (idClient) {
	    promise = self.getOne(TableMsg, null, idClient, {
	      remove: true
	    }).then(function (msg) {
	      self.logger.warn('delete msg', msg);
	      return msg;
	    });
	    array.push(promise);
	  });
	  return array.length === 1 ? array[0] : Promise.all(array);
	};

	DBFn.deleteMsgsBySessionId = function (sessionId) {
	  var self = this;
	  return self.getOnly(TableMsg, IndexSession, sessionId, {
	    remove: true
	  });
	};

	// 删除所有消息和会话
	DBFn.deleteAllMsgs = function () {
	  var self = this;
	  var p1 = self.clearTable(TableMsg);
	  var p2 = self.clearTable(TableSession);
	  return Promise.all([p1, p2]);
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var DBFn = __webpack_require__(10).fn;
	var util = __webpack_require__(1);
	var TableBlacklist = 'blacklist';
	var TableMutelist = 'mutelist';

	/*
	 * 更新、删除
	 * - 成功后更新时间戳
	 */
	DBFn.mergeRelations = function (blacklist, blacklist2delete, mutelist, mutelist2delete, timetag) {
	    var self = this;
	    var p1 = self.updateAndDelete(TableBlacklist, blacklist, blacklist2delete);
	    var p2 = self.updateAndDelete(TableMutelist, mutelist, mutelist2delete);
	    return Promise.all([p1, p2]).then(function () {
	        self.logger.warn('merge relations');
	        self.updateRelationTimetag(timetag);
	        return [blacklist, blacklist2delete, mutelist, mutelist2delete, timetag];
	    });
	};

	DBFn.getRelations = function () {
	    var self = this;
	    var p1 = self.getAll(TableBlacklist);
	    var p2 = self.getAll(TableMutelist);
	    return Promise.all([p1, p2]);
	};

	DBFn.markInBlacklist = function (obj) {
	    var self = this;
	    // 先复制, 不受外界干扰
	    obj = util.copy(obj);
	    if (obj.isAdd) {
	        var record = obj.record;
	        return self.put(TableBlacklist, record);
	    } else {
	        var account = obj.account;
	        return self.remove(TableBlacklist, account);
	    }
	};

	DBFn.markInMutelist = function (obj) {
	    var self = this;
	    // 先复制, 不受外界干扰
	    obj = util.copy(obj);
	    if (obj.isAdd) {
	        var record = obj.record;
	        return self.put(TableMutelist, record);
	    } else {
	        var account = obj.account;
	        return self.remove(TableMutelist, account);
	    }
	};

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var DBFn = __webpack_require__(10).fn;
	var util = __webpack_require__(1);
	var notundef = util.notundef;
	var TableSession = 'session';
	var IndexUpdateTime = 'updateTime';

	/*
	 * 存储会话, 如果没有记录, 那么创建新的纪录
	 */
	DBFn.putSession = function (session) {
	    session = util.merge({}, session);
	    delete session.unread;
	    return this.modifyOrPut({
	        table: TableSession,
	        obj: session,
	        key: 'id',
	        modifyObjWhenPut: {
	            unread: 0
	        }
	    });
	};

	// params sessionId 或 lastSessionId
	DBFn.getSessions = function (options) {
	    options = options || {};
	    var desc = !options.reverse;
	    var limit = options.limit || 100;
	    // 如果没有提供 lastSessionId, 那么匹配所有的记录
	    // 如果提供了 lastSessionId, 那么匹配从 lastSessionId 的下一条开始的所有记录
	    var lastSessionId = options.lastSessionId;
	    var sessionId = options.sessionId;
	    var findLastRecord = false;
	    var filter;
	    if (notundef(lastSessionId)) {
	        filter = function filter(session) {
	            if (findLastRecord) {
	                return true;
	            } else {
	                if (session.id === lastSessionId) {
	                    findLastRecord = true;
	                }
	                return false;
	            }
	        };
	    } else if (notundef(sessionId)) {
	        return this.get(TableSession, sessionId);
	    }
	    return this.getAll(TableSession, {
	        index: IndexUpdateTime,
	        desc: desc,
	        limit: limit,
	        filter: filter
	    });
	};

	DBFn.getSession = function (sessionId) {
	    return this.get(TableSession, sessionId);
	};

	/*
	 * 修改已有的会话
	 * 只允许更新部分字段
	 */
	DBFn.updateSession = function (session) {
	    var self = this;
	    var sessionId = session.id;
	    var modifyObj = util.filterObj(session, 'ack unread lastMsg localCustom msgReceiptTime msgReceiptServerTime');
	    Object.keys(session).forEach(function (key) {
	        if (key.indexOf('last') === 0) {
	            modifyObj[key] = session[key];
	        }
	    });
	    return this.getOne(TableSession, null, sessionId, {
	        modifyObj: modifyObj
	    }).then(function (record) {
	        if (record) {
	            self.logger.warn('update session', sessionId, modifyObj);
	        } else {
	            self.logger.warn('update session no', sessionId);
	        }
	        return record;
	    });
	};

	DBFn.resetSessionUnread = function (sessionId) {
	    return this.updateSession({
	        id: sessionId,
	        unread: 0
	    });
	};

	/**
	 * 删除会话
	 * @private
	 * @param  {String|String[]} id     id 或者 id 数组
	 */
	DBFn.deleteSession = function (id) {
	    return this.remove(TableSession, id);
	};

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var DBFn = __webpack_require__(10).fn;
	var util = __webpack_require__(1);
	var notundef = util.notundef;
	var TableSysMsg = 'sysMsg';
	var IndexIdServer = 'idServer';
	var IndexType = 'type';
	var IndexCategory = 'category';
	var TableSysMsgUnread = 'sysMsgUnread';

	/*
	 * 存储系统通知（不存自定义系统通知）
	 * - 收到离线系统通知
	 * - 收到系统通知
	 * 策略为只管存, 并且保存存储成功的系统通知,
	 * 如果失败, 说明对应的系统通知已经存在, 那么刚好过滤掉,
	 * 最终返回所有存储成功的系统通知
	 */
	DBFn.putSysMsg = function (sysMsgs) {
	    var self = this;
	    return new Promise(function (resolve) {
	        if (!util.isArray(sysMsgs)) {
	            sysMsgs = [sysMsgs];
	        }
	        // 如果是过滤（云商服专用）, 直接返回
	        if (sysMsgs[0].filter) {
	            return;
	        }
	        var array = [];
	        var counter = sysMsgs.length;
	        sysMsgs.forEach(function (sysMsg) {
	            sysMsg = util.copy(sysMsg);
	            self.put(TableSysMsg, sysMsg).then(function (record) {
	                array.push(record[0]);
	                bingo();
	            }, bingo);
	        });
	        // 就算有失败, 也算完成, 最终返回所有存储成功的记录
	        function bingo() {
	            counter--;
	            if (counter === 0) {
	                resolve(array);
	            }
	        }
	    });
	};

	/*
	 * 获取系统通知
	 */
	DBFn.getSysMsgs = function (options) {
	    var self = this;
	    options = options || {};
	    var desc = !options.reverse;
	    var limit = options.limit || 100;
	    var index = null;
	    var matchValue = null;
	    // 如果有种类, 更换索引
	    if (options.category) {
	        index = IndexCategory;
	        matchValue = options.category;
	    }
	    // 如果有类型, 更换索引
	    if (options.type) {
	        index = IndexType;
	        matchValue = options.type;
	    }
	    // 如果没有提供 lastIdServer 和 read, 那么匹配所有的记录
	    // 如果提供了 lastIdServer, 那么匹配从 lastIdServer 的下一条开始的所有记录
	    // 如果提供了 read, 那么匹配该属性
	    var lastIdServer = options.lastIdServer;
	    var findLastRecord = false;
	    var read = options.read;
	    var filter;
	    if (notundef(lastIdServer) || notundef(read)) {
	        filter = function filter(sysMsg) {
	            if (notundef(lastIdServer)) {
	                lastIdServer = '' + lastIdServer;
	                if (findLastRecord) {
	                    return bingo();
	                } else {
	                    if (sysMsg.idServer === lastIdServer) {
	                        findLastRecord = true;
	                    }
	                    return false;
	                }
	            }
	            return bingo();
	            function bingo() {
	                if (notundef(read)) {
	                    return sysMsg.read === read;
	                }
	                return true;
	            }
	        };
	    }
	    options = {
	        filter: filter,
	        desc: desc,
	        limit: limit
	    };
	    if (!index) {
	        return self.getAll(TableSysMsg, options);
	    } else {
	        return self.getOnly(TableSysMsg, index, matchValue, options);
	    }
	};

	DBFn.getSysMsgByIdServer = function (idServer) {
	    return this.getOne(TableSysMsg, IndexIdServer, idServer);
	};

	/*
	 * 更新系统通知
	 * 只允许更新 read, state, localCustom
	 */
	DBFn.updateSysMsg = function (sysMsg) {
	    var self = this;
	    if (sysMsg.filter) {
	        return;
	    }
	    var idServer = '' + sysMsg.idServer;
	    var modifyObj = util.filterObj(sysMsg, 'read state error localCustom');
	    return this.getOne(TableSysMsg, IndexIdServer, idServer, {
	        modifyObj: modifyObj
	    }).then(function (record) {
	        if (record) {
	            self.logger.warn('update sysMsg', idServer, modifyObj);
	        } else {
	            self.logger.warn('update sysMsg no', idServer);
	        }
	        return record;
	    });
	};

	/*
	 * 标记系统通知为已读
	 * sysMsgs 可以为数组或者单个
	 */
	DBFn.markSysMsgRead = function (sysMsgs) {
	    var self = this;
	    return new Promise(function (resolve, reject) {
	        if (!util.isArray(sysMsgs)) {
	            sysMsgs = [sysMsgs];
	        }
	        var checkArray = [];
	        var checkPromise;
	        var markArray = [];
	        var markPromise;
	        sysMsgs.forEach(function (sysMsg) {
	            checkPromise = self.getSysMsgByIdServer(sysMsg.idServer).then(function (sysMsg) {
	                if (!!sysMsg && !sysMsg.read) {
	                    markPromise = self.updateSysMsg({
	                        idServer: sysMsg.idServer,
	                        read: true
	                    });
	                    markArray.push(markPromise);
	                }
	            }, reject);
	            checkArray.push(checkPromise);
	        });
	        Promise.all(checkArray).then(function () {
	            Promise.all(markArray).then(function (records) {
	                resolve(records);
	            }, reject);
	        }, reject);
	    });
	};

	/*
	 * 删除系统通知
	 * idServers 可以为数组或者单个
	 */
	DBFn.deleteSysMsg = function (idServers) {
	    var self = this;
	    var array = [];
	    var promise;
	    if (!util.isArray(idServers)) {
	        idServers = [idServers];
	    }
	    idServers.forEach(function (idServer) {
	        idServer = '' + idServer;
	        promise = self.getOne(TableSysMsg, IndexIdServer, idServer, {
	            remove: true
	        });
	        array.push(promise);
	    });
	    return array.length === 1 ? array[0] : Promise.all(array);
	};

	DBFn.deleteAllSysMsgs = function () {
	    var self = this;
	    var p1 = self.clearTable(TableSysMsg);
	    var p2 = self.clearTable(TableSysMsgUnread);
	    return Promise.all([p1, p2]);
	};

	/*
	 * 获取系统通知未读数
	 */
	DBFn.getSysMsgUnread = function () {
	    return this.getAll(TableSysMsgUnread).then(function (records) {
	        var obj = {};
	        records.forEach(function (record) {
	            obj[record.type] = record.num;
	        });
	        return obj;
	    });
	};

	/*
	 * 更新系统通知未读数
	 */
	DBFn.updateSysMsgUnread = function (sysMsgUnread) {
	    var self = this;
	    // 先复制, 不受外界干扰
	    sysMsgUnread = util.copy(sysMsgUnread);
	    var records = [];
	    Object.keys(sysMsgUnread).forEach(function (type) {
	        records.push({
	            type: type,
	            num: sysMsgUnread[type]
	        });
	    });
	    return this.put(TableSysMsgUnread, records).then(function () {
	        self.logger.warn('update sysMsg unread', sysMsgUnread);
	        return sysMsgUnread;
	    });
	};

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var DBFn = __webpack_require__(10).fn;
	var util = __webpack_require__(1);
	var NIMError = __webpack_require__(4);
	var Team = __webpack_require__(26);
	var TeamMember = __webpack_require__(20);
	var TableTeam = 'team';
	var IndexTeamId = 'teamId';
	var IndexAccount = 'account';
	var TableTeamMember = 'teamMember';

	/*
	 * 更新群和解散群
	 * - 成功后更新对应的群时间戳
	 */
	DBFn.mergeTeams = function (teams, teams2delete, timetag) {
	    var self = this;
	    var p1 = self.put(TableTeam, teams);
	    var p2 = self.leaveTeams(teams2delete, timetag);
	    return Promise.all([p1, p2]).then(function () {
	        self.logger.warn('merge teams');
	        self.updateTeamTimetag(timetag);
	        return [teams, teams2delete, timetag];
	    });
	};

	/*
	 * 添加群
	 */
	DBFn.putTeam = function (teams) {
	    if (!teams) {
	        return;
	    }
	    if (!util.isArray(teams)) {
	        teams = [teams];
	    }
	    teams.forEach(function (team) {
	        // 创建群时服务器并没有返回这个字段
	        team.validToCurrentUser = true;
	    });
	    return this.put(TableTeam, teams);
	};

	DBFn.updateTeam = function (team) {
	    var self = this;
	    // 先复制, 不受外界干扰
	    team = util.copy(team);
	    var teamId = team.teamId;
	    return self.getOne(TableTeam, null, teamId, {
	        modifyObj: team
	    }).then(function (record) {
	        if (record) {
	            self.logger.warn('update team', teamId, team);
	        } else {
	            self.logger.warn('update team no', teamId);
	            return self.putTeam(team);
	        }
	        return record;
	    });
	};

	/*
	 * 转让群
	 * - 更新两个的群成员
	 * - 成功后更新群
	 */
	DBFn.transferTeam = function (team, from, to) {
	    var self = this;
	    var teamId = team.teamId;
	    var memberUpdateTime = team.memberUpdateTime;
	    var m1 = {
	        teamId: teamId,
	        account: from,
	        type: 'normal',
	        updateTime: memberUpdateTime
	    };
	    var m2 = {
	        teamId: teamId,
	        account: to,
	        type: 'owner',
	        updateTime: memberUpdateTime
	    };
	    return self.updateTeamMembers([m1, m2]).then(function () {
	        return self.putTeam(team).then(function () {
	            self.logger.warn('transfer team', team.teamId, from, to);
	            return [team, from, to];
	        });
	    });
	};

	/*
	 * 离开群
	 * - 标记该群（成功后更新对应的群时间戳）
	 * - 成功后移除该群的所有群成员（成功后移除对应的群成员时间戳）
	 */
	DBFn.leaveTeam = function (teamId) {
	    var self = this;
	    return self.updateTeam({
	        teamId: teamId,
	        validToCurrentUser: false
	    }).then(function () {
	        return self.removeAllTeamMembers(teamId);
	    });
	};

	/*
	 * 解散群
	 * - 标记该群
	 * - 成功后移除该群的所有群成员（成功后移除对应的群成员时间戳）
	 */
	DBFn.dismissTeam = function (teamId, timetag) {
	    var self = this;
	    var modifyObj = {
	        teamId: teamId,
	        valid: false,
	        validToCurrentUser: false,
	        updateTime: timetag
	    };
	    return self.updateTeam(modifyObj).then(function () {
	        return self.removeAllTeamMembers(teamId);
	    });
	};

	DBFn.leaveTeams = function (teams, timetag) {
	    var self = this;
	    var array = [];
	    var promise;
	    teams.forEach(function (team) {
	        promise = self.leaveTeam(team.teamId, timetag);
	        array.push(promise);
	    });
	    return Promise.all(array);
	};

	DBFn.getTeamsByTeamIds = function (teamIds) {
	    var self = this;
	    var array = [];
	    var promise;
	    teamIds.forEach(function (teamId) {
	        promise = self.getTeam(teamId);
	        array.push(promise);
	    });
	    return Promise.all(array);
	};

	DBFn.getTeam = function (teamId) {
	    teamId = '' + teamId;
	    var self = this;
	    return self.getOne(TableTeam, null, teamId).then(function (team) {
	        self.updateTeamProperties([team]);
	        return team;
	    });
	};

	/**
	 * 同步过程中会调用这个方法, 在这里要对升级过程中缺失的字段进行补充
	 */
	DBFn.getTeams = function () {
	    var self = this;
	    return self.getAll(TableTeam, {
	        filter: isValidTeamToCurrentUser
	    }).then(function (teams) {
	        self.updateTeamProperties(teams);
	        return teams;
	    });
	};

	function isValidTeamToCurrentUser(team) {
	    return team.valid && team.validToCurrentUser;
	}

	/**
	 * 升级数据库后, 有些字段老的记录是没有的, 此方法用于补全这些字段
	 */
	DBFn.updateTeamProperties = function (teams) {
	    teams.forEach(function (team) {
	        Team.fillProperties(team);
	    });
	};

	DBFn.mergeTeamMembers = function (teamId, members, members2delete, timetag) {
	    var self = this;
	    var p1 = self.putTeamMembers(members);
	    var p2 = self.updateTeamMembers(members2delete);
	    return Promise.all([p1, p2]).then(function () {
	        self.logger.warn('merge members', teamId);
	        return self.updateTeamMemberTimetag(teamId, timetag);
	    });
	};

	/*
	 * 群成员
	 */

	DBFn.putTeamMembers = function (members) {
	    return this.put(TableTeamMember, members);
	};

	function teamMemberIsValid(teamMember) {
	    return teamMember && teamMember.valid;
	}

	function amendTeamMember(teamMember) {
	    if (teamMember) {
	        util.fillUndef(teamMember, {
	            mute: false,
	            custom: ''
	        });
	    }
	    return teamMember;
	}

	DBFn.getTeamMembersByAccount = function (account) {
	    var self = this;
	    return self.getOnly(TableTeamMember, IndexAccount, account, {
	        filter: teamMemberIsValid,
	        mapper: amendTeamMember
	    }).then();
	};

	/**
	 * 同步过程中会调用这个方法, 在这里要对升级过程中缺失的字段进行补充
	 */
	DBFn.getTeamMembers = function (teamId) {
	    var self = this;
	    teamId = '' + teamId;
	    var filter = function filter(teamMember) {
	        return teamMember.valid;
	    };
	    return self.getOnly(TableTeamMember, IndexTeamId, teamId, {
	        filter: filter,
	        mapper: amendTeamMember
	    }).then(function (members) {
	        return self.updateTeamMemberProperties(members).then(function () {
	            return members;
	        });
	    });
	};

	/**
	 * 升级数据库后, 有些字段老的记录是没有的, 此方法用于补全这些字段
	 * 不再使用, 统一使用 amendTeamMember
	 */
	DBFn.updateTeamMemberProperties = function (members) {
	    var self = this;
	    var array = [];
	    var p;
	    members.forEach(function (member) {
	        if (TeamMember.fillProperties(member)) {
	            p = self.updateTeamMember(member);
	            array.push(p);
	        }
	    });
	    return Promise.all(array);
	};

	DBFn.getInvalidTeamMembers = function (teamId, accounts) {
	    var self = this;
	    teamId = '' + teamId;
	    var array = [];
	    var promise;
	    accounts.forEach(function (account) {
	        promise = self.getOne(TableTeamMember, null, TeamMember.genId(teamId, account)).then(function (member) {
	            return amendTeamMember(member);
	        });
	        array.push(promise);
	    });
	    return Promise.all(array);
	};

	/*
	 * 更新群成员
	 */
	DBFn.updateTeamMember = function (member) {
	    var self = this;
	    var teamId = member.teamId;
	    var account = member.account;
	    var id = TeamMember.genId(teamId, account);
	    // member 包含 account id 等不需要更新的属性, 所以先过滤一下
	    var modifyObj = util.filterObj(member, 'nickInTeam muteTeam mute custom updateTime type valid');
	    return this.getOne(TableTeamMember, null, id, {
	        modifyObj: modifyObj,
	        mapper: amendTeamMember
	    }).then(function (m) {
	        if (m) {
	            self.logger.warn('update member', teamId, account, modifyObj);
	        } else {
	            self.logger.warn('update member no', teamId, account);
	        }
	        return m;
	    });
	};

	/*
	 * 更新群成员
	 */
	DBFn.updateTeamMembers = function (members) {
	    var self = this;
	    if (!members.length) {
	        return Promise.resolve();
	    }
	    var array = [];
	    var promise;
	    members.forEach(function (member) {
	        promise = self.updateTeamMember(member);
	        array.push(promise);
	    });
	    return Promise.all(array);
	};

	/*
	 * 更新群的管理员
	 * - 后续性能如果有问题的话, 增加一个索引, idType = id + type
	 */
	DBFn.updateTeamManagers = function (teamId, accounts, isManager, timetag) {
	    var members = accounts.map(function (account) {
	        return {
	            teamId: teamId,
	            account: account,
	            type: isManager ? 'manager' : 'normal',
	            updateTime: timetag
	        };
	    });
	    return this.updateTeamMembers(members);
	};

	DBFn.removeTeamMembersByAccounts = function (teamId, accounts) {
	    var members = accounts.map(function (account) {
	        return {
	            teamId: teamId,
	            account: account,
	            valid: false
	        };
	    });
	    return this.updateTeamMembers(members);
	};

	/*
	 * 移除群的所有群成员, 成功后移除对应的群成员时间戳
	 */
	DBFn.removeAllTeamMembers = function (teamId) {
	    var self = this;
	    var modifyObj = {
	        valid: false
	    };
	    return self.getOnly(TableTeamMember, IndexTeamId, teamId, {
	        modifyObj: modifyObj
	    }).then(function () {
	        self.logger.warn('invalid all teamMembers', teamId);
	        return self.deleteTeamMemberTimetag(teamId);
	    });
	};

	DBFn.deleteTeamMembers = function (teamId) {
	    var self = this;
	    return self.getOnly(TableTeamMember, IndexTeamId, teamId, {
	        remove: true
	    }).then(function () {
	        self.logger.warn('delete all teamMembers', teamId);
	        self.deleteTeamMemberTimetag(teamId);
	    });
	};

	/*
	 * 删除群 单个或者数组
	 * - 如果还在群里面, 那么不删除
	 */
	DBFn.deleteTeam = function (teamIds) {
	    var self = this;
	    var array = [];
	    var promise;
	    if (!util.isArray(teamIds)) {
	        teamIds = [teamIds];
	    }
	    teamIds.forEach(function (teamId) {
	        teamId = '' + teamId;
	        promise = self.get(TableTeam, teamId).then(function (team) {
	            if (!!team && isValidTeamToCurrentUser(team)) {
	                throw NIMError.stillInTeamError();
	            } else {
	                var p1 = self.remove(TableTeam, teamId);
	                var p2 = self.deleteTeamMembers(teamId);
	                return Promise.all([p1, p2]);
	            }
	        });
	        array.push(promise);
	    });
	    return array.length === 1 ? array[0] : Promise.all(array);
	};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var DBFn = __webpack_require__(10).fn;

	DBFn.getTimetags = function (filter) {
	  var timetags = {};
	  var mapper = function mapper(record) {
	    if (record.name.indexOf('team-') !== -1) {
	      // 群成员全部为全量同步
	      timetags[record.name] = 0;
	    } else {
	      timetags[record.name] = record.value;
	    }
	    return record;
	  };
	  return this.getAll('timetag', {
	    filter: filter,
	    mapper: mapper
	  }).then(function () {
	    return timetags;
	  });
	};

	DBFn.getTeamMemberTimetags = function () {
	  return this.getTimetags(function (record) {
	    return record.name.indexOf('team-') !== -1;
	  });
	};

	DBFn.getTimetag = function (name) {
	  return this.getOne('timetag', null, name).then(function (obj) {
	    obj = obj || { value: 0 };
	    return obj.value;
	  });
	};

	DBFn.getTeamMemberTimetag = function (teamId) {
	  return 0; // this.getTimetag('team-' + teamId)
	};

	DBFn.updateTimetag = function (name, timetag) {
	  var record = { name: name, value: timetag };
	  return this.put('timetag', record);
	};

	DBFn.updateMyInfoTimetag = function (timetag) {
	  return this.updateTimetag('myInfo', timetag);
	};

	DBFn.updateRelationTimetag = function (timetag) {
	  return this.updateTimetag('relations', timetag);
	};

	DBFn.getRelationsTimetag = function () {
	  return this.getTimetag('relations');
	};

	DBFn.updateFriendTimetag = function (timetag) {
	  return this.updateTimetag('friends', timetag);
	};

	DBFn.getFriendsTimetag = function () {
	  return this.getTimetag('friends');
	};

	DBFn.updateFriendUserTimetag = function (timetag) {
	  return this.updateTimetag('friendUsers', timetag);
	};

	DBFn.updateTeamTimetag = function (timetag) {
	  return this.updateTimetag('teams', timetag);
	};

	DBFn.getTeamsTimetag = function () {
	  return this.getTimetag('teams');
	};

	DBFn.updateTeamMemberTimetag = function (teamId, timetag) {
	  return this.updateTimetag('team-' + teamId, timetag);
	};

	DBFn.getTeamMembersTimetag = function (teamId) {
	  return this.getTimetag('team-' + teamId);
	};

	DBFn.updateMyTeamMembersTimetag = function (timetag) {
	  return this.updateTimetag('myTeamMembers', timetag);
	};

	DBFn.getBroadcastMsgTimetag = function (timetag) {
	  return this.getTimetag('broadcastMsg');
	};

	DBFn.updateBroadcastMsgTimetag = function (timetag) {
	  return this.updateTimetag('broadcastMsg', parseInt(timetag));
	};

	/*
	 * 什么时候更新漫游消息时间戳
	 * - 收到漫游消息和离线消息后, 拿到最后一条消息的时间戳, 再更新漫游消息时间戳
	 * - 发消息成功后更新漫游消息时间戳
	 * - 收到消息后更新漫游消息时间戳
	 */
	DBFn.updateRoamingMsgTimetag = function (timetag) {
	  return this.updateTimetag('roamingMsgs', timetag);
	};

	DBFn.updateMsgReceiptsTimetag = function (timetag) {
	  return this.updateTimetag('msgReceipts', timetag);
	};

	DBFn.updateDonnopTimetag = function (timetag) {
	  return this.updateTimetag('donnop', timetag);
	};

	DBFn.updateDeleteMsgTimetag = function (timetag) {
	  return this.updateTimetag('deleteMsg', timetag);
	};

	DBFn.updateSessionAck = function (timetag) {
	  return this.updateTimetag('sessionAck', timetag);
	};

	DBFn.deleteTimetag = function (name) {
	  return this.remove('timetag', name);
	};

	DBFn.deleteTeamMemberTimetag = function (teamId) {
	  return this.deleteTimetag('team-' + teamId);
	};

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var DBFn = __webpack_require__(10).fn;
	var util = __webpack_require__(1);
	var TableUser = 'user';

	/**
	 * 处理我的信息
	 * @private
	 * @param  {Boolean} shouldUpdateTimetag 是否更新时间戳
	 */
	DBFn.mergeMyInfo = function (user, shouldUpdateTimetag) {
	    var self = this;
	    return self.put(TableUser, user).then(function () {
	        if (shouldUpdateTimetag) {
	            return self.updateMyInfoTimetag(user.updateTime);
	        }
	        return user;
	    });
	};

	DBFn.mergeFriendUsers = function (users, timetag) {
	    var self = this;
	    return self.putUsers(users).then(function () {
	        self.updateFriendUserTimetag(timetag);
	    });
	};

	DBFn.putUsers = function (users) {
	    return this.put(TableUser, users);
	};

	DBFn.putUser = function (user) {
	    return this.put(TableUser, user);
	};

	DBFn.updateUser = function (user) {
	    var self = this;
	    // 先复制, 不受外界干扰
	    user = util.copy(user);
	    var account = user.account;
	    return this.getOne(TableUser, null, account, {
	        modifyObj: user
	    }).then(function (record) {
	        if (record) {
	            self.logger.warn('update user', account, user);
	        } else {
	            self.logger.warn('update user no', account);
	        }
	        return record;
	    });
	};

	// 如果是好友, 更新其用户信息
	DBFn.putUsersIfIsFriend = function (users) {
	    var self = this;
	    var waitArray = [];
	    var updateArray = [];
	    var promise;
	    users.forEach(function (user) {
	        promise = self.getFriend(user.account).then(function (record) {
	            if (!!record) {
	                promise = self.putUser(user);
	                updateArray.push(promise);
	            }
	            return record;
	        });
	        waitArray.push(promise);
	    });
	    return Promise.all(waitArray).then(function () {
	        return Promise.all(updateArray).then(function (updateResult) {
	            return updateResult;
	        });
	    });
	};

	DBFn.deleteUser = function (account) {
	    return this.remove(TableUser, account);
	};

	DBFn.getUser = function (account) {
	    return this.getOne(TableUser, null, account);
	};

	DBFn.getUsers = function (accounts) {
	    function filter(user) {
	        return accounts.indexOf(user.account) !== -1;
	    }
	    return this.getAll(TableUser, {
	        filter: filter
	    });
	};

	DBFn.getAllUsers = function () {
	    return this.getAll(TableUser);
	};

/***/ },
/* 120 */,
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var NIM = __webpack_require__(6);

	var mixin = __webpack_require__(40);
	mixin(NIM);

	module.exports = NIM;

	/**
	 * SDK 使用 {@link https://github.com/bestiejs/platform.js/|platform.js} 来检测浏览器平台, 通过 `NIM.platform` 来获取此库的引用
	 * @name platform
	 * @memberOf NIM
	 * @type {Object}
	 */

	/**
	 * SDK 使用 {@link https://github.com/Raynos/xhr|xhr} 来发送 Ajax 请求, 通过 `NIM.xhr` 来获取此库的引用
	 * @memberOf NIM
	 * @name xhr
	 * @type {Function}
	 */

	/**
	 * SDK 使用 {@link https://github.com/socketio/socket.io-client/tree/0.9|socket.io-client 0.9} 来建立 Socket 连接, 通过 `NIM.io` 来获取此库的引用
	 * @name io
	 * @memberOf NIM
	 * @type {Object}
	 */

	/**
	 * SDK 使用 {@link https://github.com/Bill4Time/javascript-natural-sort|natural sort} 来对数组进行排序, 通过 `NIM.naturalSort` 来获取此库的引用
	 * @name naturalSort
	 * @memberOf NIM
	 * @type {Function}
	 */

	/**
	 * SDK 使用 {@link https://github.com/juliangruber/deep-access|deep access} 来获取对象的属性值, 通过 `NIM.deepAccess` 来获取此库的引用
	 * @name deepAccess
	 * @type {Function}
	 */

/***/ },
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var FileMessage = __webpack_require__(31);
	var util = __webpack_require__(1);

	function AudioMessage() {}
	AudioMessage.prototype = Object.create(FileMessage.prototype);

	AudioMessage.verifyFile = function (file) {
	    util.verifyOptions(file, 'dur', true, 'file.');
	};

	module.exports = AudioMessage;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Message = __webpack_require__(16);
	var util = __webpack_require__(1);

	/**
	 * 自定义消息
	 * @private
	 */
	function CustomMessage(options) {
	    util.verifyOptions(options, 'content');
	    options.type = 'custom';
	    Message.call(this, options);
	    this.attach = options.content;
	}

	CustomMessage.prototype = Object.create(Message.prototype);

	CustomMessage.reverse = function (msg) {
	    var obj = Message.reverse(msg);
	    obj.content = msg.attach;
	    return obj;
	};

	module.exports = CustomMessage;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Message = __webpack_require__(16);
	var util = __webpack_require__(1);

	function GeoMessage(options) {
	    options.type = 'geo';
	    util.verifyOptions(options, 'geo');
	    util.verifyOptions(options.geo, 'lng lat title', true, 'geo.');
	    util.verifyParamType('geo.lng', options.geo.lng, 'number');
	    util.verifyParamType('geo.lat', options.geo.lat, 'number');
	    util.verifyParamType('geo.title', options.geo.title, 'string');
	    Message.call(this, options);
	    this.attach = JSON.stringify(options.geo);
	}

	GeoMessage.prototype = Object.create(Message.prototype);

	GeoMessage.reverse = function (msg) {
	    var obj = Message.reverse(msg);
	    msg.attach = !!msg.attach ? '' + msg.attach : '';
	    obj.geo = !!msg.attach ? JSON.parse(msg.attach) : {};
	    return obj;
	};

	module.exports = GeoMessage;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);
	var FileMessage = __webpack_require__(31);

	function ImageMessage() {}
	ImageMessage.prototype = Object.create(FileMessage.prototype);

	ImageMessage.verifyFile = function (file) {
	    util.verifyOptions(file, 'w h', true, 'file.');
	};

	module.exports = ImageMessage;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);

	var Index = function Index(options) {
	  this.account = options.account;
	  this.enabledHttpsForMessage = options.enabledHttpsForMessage || false;
	};

	var pro = Index.prototype;

	var Message = pro.Message = __webpack_require__(16);
	var TextMessage = pro.TextMessage = __webpack_require__(139);
	var FileMessage = pro.FileMessage = __webpack_require__(31);
	var GeoMessage = pro.GeoMessage = __webpack_require__(134);
	var NotificationMessage = pro.NotificationMessage = __webpack_require__(137);
	var CustomMessage = pro.CustomMessage = __webpack_require__(133);
	var TipMessage = pro.TipMessage = __webpack_require__(140);
	var RobotMessage = pro.RobotMessage = __webpack_require__(138);

	pro.validScenes = Message.validScenes;
	pro.validTypes = Message.validTypes;

	pro.reverse = function (msg) {
	  var obj;
	  var type = Message.getType(msg);
	  switch (type) {
	    case 'text':
	      obj = TextMessage.reverse(msg);
	      break;
	    case 'image':
	    case 'audio':
	    case 'video':
	    case 'file':
	      msg.enabledHttpsForMessage = this.enabledHttpsForMessage;
	      obj = FileMessage.reverse(msg);
	      break;
	    case 'geo':
	      obj = GeoMessage.reverse(msg);
	      break;
	    case 'notification':
	      obj = NotificationMessage.reverse(msg);
	      break;
	    case 'custom':
	      obj = CustomMessage.reverse(msg);
	      break;
	    case 'tip':
	      obj = TipMessage.reverse(msg);
	      break;
	    case 'robot':
	      // robotIn
	      obj = RobotMessage.reverse(msg);
	      break;
	    // case 'robotOut':
	    //   obj = RobotMessage.reverse(msg)
	    //   break
	    default:
	      obj = Message.reverse(msg);
	      break;
	  }
	  Message.setExtra(obj, this.account);
	  return obj;
	};

	pro.reverseMsgs = function (msgs, options) {
	  var self = this;
	  var modifyObj;
	  var mapper;
	  return msgs.map(function (msg) {
	    msg = self.reverse(msg);
	    if (options) {
	      modifyObj = options.modifyObj;
	      if (modifyObj) {
	        msg = util.merge(msg, modifyObj);
	      }
	      mapper = options.mapper;
	      if (util.isFunction(mapper)) {
	        msg = mapper(msg);
	      }
	    }
	    return msg;
	  });
	};

	module.exports = Index;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/* exported notificationTypes */

	var util = __webpack_require__(1);
	var notundef = util.notundef;
	var Message = __webpack_require__(16);
	var parser = __webpack_require__(18).getInstance('IM');
	var team = __webpack_require__(26);
	var User = __webpack_require__(32);

	/**
	 * 群通知消息的类型
	 *
	 * - 群通知消息是{@link IMMessage|消息}的一种, 请参考{@link IMMessage.type|消息类型}, 某些群操作后所有群成员会收到一条相应的群通知消息
	 * - 群通知消息有一个字段`attach`包含了额外的信息, `attach`有一个字段`type`来标识群通知消息的类型
	 *     - `'updateTeam'` (更新群)
	 *         - {@link NIM#updateTeam|更新群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'updateTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为更新群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为被更新的{@link Team|群信息}。
	 *     - `'addTeamMembers'` (拉人入群)
	 *         - 普通群, {@link NIM#addTeamMembers|拉人入群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|``'addTeamMembers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为拉人的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的[群对象](#群对象), `attach`有一个字段`accounts`的值为被拉的人的帐号列表, `attach`有一个字段`members`的值为被拉的群成员列表。
	 *         - 被邀请的群成员在有人说话后才能看到该{@link Team|群}, 而且会先收到一条类型为{@link IMMessage.attach.type|`'addTeamMembers'`}的{@link IMMessage.type|群通知消息}, 然后会收到其它{@link Message|群消息}。
	 *     - `'removeTeamMembers'` (踢人出群)
	 *         - {@link NIM#removeTeamMembers|踢人出群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'removeTeamMembers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为踢人的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`accounts`的值为被踢的人的帐号列表。
	 *     - `'acceptTeamInvite'` (接受入群邀请)
	 *         - 高级群的群主和管理员在邀请成员加入群（通过操作{@link NIM#createTeam|创建群}或{@link NIM#addTeamMembers|拉人入群}）之后, 被邀请的人会收到一条类型为`'teamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为邀请方的帐号, `to`字段的值为对应的群ID, 此类系统通知的`attach`有一个字段`team`的值为被邀请进入的{@link Team|群}, 被邀请的人可以选择接受邀请或者拒绝邀请。
	 *             - 如果{@link NIM#acceptTeamInvite|接受入群邀请}, 那么该群的所有群成员会收到一条类型为`'acceptTeamInvite'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为接受入群邀请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`members`的值为接收入群邀请的群成员列表。
	 *             - 如果{@link NIM#rejectTeamInvite|拒绝入群邀请}, 那么邀请你的人会收到一条类型为`'rejectTeamInvite'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝入群邀请的人的帐号, `to`字段的值为对应的群ID。
	 *     - `'passTeamApply'` (通过入群申请)
	 *         - 用户可以主动{@link NIM#applyTeam|申请加入高级群}, 目标群的群主和管理员会收到一条类型为`'applyTeam'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为申请方的帐号, `to`字段的值为对应的群ID, 高级群的群主和管理员在收到入群申请后, 可以选择通过或者拒绝入群申请。
	 *             - 如果{@link NIM#passTeamApply|通过入群申请}, 那么该群的所有群成员会收到一条类型为`'passTeamApply'`的{@link IMMessage.type|群通知消息}, 此类群通知消息的`from`字段的值为通过入群申请的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`包含了申请方的帐号, `attach`有一个字段`members`的值为被通过申请的群成员列表。
	 *             - 如果{@link NIM#rejectTeamApply|拒绝入群申请}, 那么申请人会收到一条类型为`'rejectTeamApply'`的{@link SystemMessage|系统通知}, 此类系统通知的`from`字段的值为拒绝方的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群}。
	 *     - `'addTeamManagers'` (添加群管理员)
	 *         - {@link NIM#addTeamManagers|添加群管理员}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'addTeamManagers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为添加群管理员的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`accounts`的值为被加为管理员的帐号列表, `attach`有一个字段`members`的值为被加为管理员的群成员列表。
	 *     - `'removeTeamManagers'` (移除群管理员)。
	 *         - {@link NIM#removeTeamManagers|移除群管理员}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'removeTeamManagers'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为移除群管理员的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`accounts`的值为被移除的管理员的帐号列表, `attach`有一个字段`members`的值为被移除管理员的群成员列表。
	 *     - `'leaveTeam'` (主动退群)
	 *         - {@link NIM#leaveTeam|主动退群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'leaveTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为退群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}。
	 *     - `'dismissTeam'` (解散群)
	 *         - {@link NIM#dismissTeam|解散群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'dismissTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段为解散群的人的帐号, `to`字段的值为被对应的群ID。
	 *     - `'transferTeam'` (转让群)
	 *         - {@link NIM#transferTeam|转让群}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'transferTeam'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为转让群的人的帐号, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`的值为为新群主的帐号, `attach`有一个字段`members`的值为包含新旧群主的群成员列表。
	 *     - `'updateTeamMute'` (更新群成员禁言状态)
	 *         - {@link NIM#updateMuteStateInTeam|更新群成员禁言状态}后, 所有{@link TeamMember|群成员}会收到一条类型为{@link IMMessage.attach.type|`'updateTeamMute'`}的{@link IMMessage.type|群通知消息}。此类群通知消息的`from`字段的值为操作方, `to`字段的值为对应的群ID, `attach`有一个字段`team`的值为对应的{@link Team|群对象}, `attach`有一个字段`account`的值为被禁言的帐号, `attach`有一个字段`members`的值为被禁言的群成员列表。
	 * - 如果`attach`有`account`或者`accounts`字段, 那么`attach`的字段`users`包含这些账号对应的用户名片
	 * - 更新群昵称不会收到群通知消息, 所有其它在线的{@link TeamMember|群成员}会收到{@link NIM|初始化SDK}时传入的`onupdateteammember`回调, 请参考{@link NIM#updateInfoInTeam|修改自己的群属性}和{@link NIM#updateNickInTeam|修改别人的群昵称}
	 *
	 * @memberOf IMMessage
	 * @readOnly
	 * @enum {String}
	 * @alias attach.type
	 */
	var notificationTypes = {};

	var notificationTypeReverseMap = {
	    0: 'addTeamMembers',
	    1: 'removeTeamMembers',
	    2: 'leaveTeam',
	    3: 'updateTeam',
	    4: 'dismissTeam',
	    5: 'passTeamApply',
	    6: 'transferTeam',
	    7: 'addTeamManagers',
	    8: 'removeTeamManagers',
	    9: 'acceptTeamInvite',
	    10: 'updateTeamMute',
	    101: 'netcallMiss',
	    102: 'netcallBill'
	};

	// 群通知消息
	function NotificationMessage() {}

	NotificationMessage.prototype = Object.create(Message.prototype);

	NotificationMessage.reverse = function (msg) {
	    var obj = Message.reverse(msg);
	    // 如果是通知, 那么可能会有附加信息, 如果有, 解析之
	    msg.attach = !!msg.attach ? '' + msg.attach : '';
	    if (!!msg.attach) {
	        var attach = JSON.parse(msg.attach);
	        obj.attach = {
	            type: notificationTypeReverseMap[attach.id] || attach.id
	        };
	        if (notundef(attach.data)) {
	            var data = attach.data;
	            if (notundef(data.tinfo)) {
	                obj.attach.team = team.reverse(parser.unserialize(data.tinfo, 'team'), true);
	            }
	            if (notundef(data.ids)) {
	                obj.attach.accounts = data.ids;
	            }
	            if (notundef(data.id)) {
	                obj.attach.account = data.id;
	            }
	            if (notundef(data.uinfos)) {
	                obj.attach.users = data.uinfos.map(function (uinfo) {
	                    return User.reverse(parser.unserialize(uinfo, 'user'));
	                });
	            }
	            if (notundef(data.mute)) {
	                obj.attach.mute = +data.mute === 1;
	            }
	            if (notundef(data.attach)) {
	                obj.attach.custom = data.attach;
	            }
	            if (notundef(data.channel)) {
	                obj.attach.channelId = data.channel;
	            }
	            if (notundef(data.calltype)) {
	                obj.attach.netcallType = data.calltype;
	            }
	            if (notundef(data.duration)) {
	                obj.attach.duration = data.duration;
	            }
	            if (notundef(data.time)) {
	                obj.attach.time = data.time;
	            }
	            // 音视频话单详情调整 to 为被呼叫方
	            if (obj.attach.accounts && obj.attach.accounts.length <= 2 && obj.from === obj.to) {
	                obj.attach.accounts.some(function (account) {
	                    if (account !== obj.to) {
	                        obj.to = account;
	                        return true;
	                    }
	                });
	            }
	        }
	    } else {
	        obj.attach = {};
	    }
	    return obj;
	};

	module.exports = NotificationMessage;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Message = __webpack_require__(16);
	var util = __webpack_require__(1);

	var botType = {
	  'welcome': '00',
	  'text': '01',
	  'link': '03'
	};

	var botReverseType = {
	  '01': 'text',
	  '02': 'image',
	  '03': 'answer',
	  '11': 'template'
	};

	// attach 格式：
	// type	00/01/03	String	00欢迎消息 01 文本 03 模块跳转	N
	// content	文本	String	说话内容	type为01时，不允许为N
	// target	target	String	返回消息类型为BOT时出现的link元素类型block中的target	type为03时，不允许为N
	// params	params	String	返回消息类型为BOT时出现的link元素类型block中的params	Y

	function RobotMessage(options) {
	  util.verifyOptions(options, 'content');
	  // 如果没有填写robotAccid，则认为to为机器人
	  if (util.undef(options.robotAccid)) {
	    options.robotAccid = options.to;
	  }
	  var attach = options.content;
	  switch (attach.type) {
	    case 'welcome':
	      if (util.undef(options.body)) {
	        this.body = '欢迎消息';
	      }
	      break;
	    case 'text':
	      util.verifyOptions(attach, 'content');
	      if (util.undef(options.body)) {
	        this.body = attach.content;
	      }
	      break;
	    case 'link':
	      util.verifyOptions(attach, 'target');
	      // util.verifyOptions(attach, 'params')
	      break;
	  }
	  if (attach.type) {
	    attach.type = botType[attach.type];
	  }
	  attach = {
	    param: attach,
	    robotAccid: options.robotAccid
	  };
	  this.attach = JSON.stringify(attach);
	  options.type = 'robot';
	  Message.call(this, options);
	}

	RobotMessage.prototype = Object.create(Message.prototype);

	RobotMessage.reverse = function (msg) {
	  var obj = Message.reverse(msg);
	  if (obj.type === 'robot') {
	    var content = JSON.parse(msg.attach);
	    if (content.param) {
	      content.param.type = botReverseType[content.param.type] || 'unknown';
	    }
	    if (content.robotMsg) {
	      content = util.merge(content, content.robotMsg);
	      var tempMsg = content.message;
	      if (content.flag === 'bot') {
	        content.message = tempMsg.map(function (item) {
	          item.type = botReverseType[item.type] || 'unknown';
	          return item;
	        });
	      } else if (content.flag === 'faq') {
	        // ...
	      }
	      delete content.robotMsg;
	    }
	    obj.content = content;
	  }
	  // 重新生成一个idClient
	  // obj.idClient = util.guid()
	  return obj;
	};

	module.exports = RobotMessage;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Message = __webpack_require__(16);
	var util = __webpack_require__(1);

	function TextMessage(options) {
	    util.verifyOptions(options, 'text');
	    options.type = 'text';
	    Message.call(this, options);
	}
	TextMessage.prototype = Object.create(Message.prototype);

	TextMessage.reverse = function (msg) {
	    var obj = Message.reverse(msg);
	    return obj;
	};

	module.exports = TextMessage;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Message = __webpack_require__(16);
	var util = __webpack_require__(1);

	/**
	 * 提醒消息
	 * @private
	 */
	function TipMessage(options) {
	    util.verifyOptions(options, 'tip');
	    options.type = 'tip';
	    Message.call(this, options);
	    this.body = options.tip;
	}

	TipMessage.prototype = Object.create(Message.prototype);

	TipMessage.reverse = function (msg) {
	    var obj = Message.reverse(msg);
	    obj.text = '';
	    obj.tip = msg.body;
	    if (msg.attach) {
	        obj.attach = msg.attach;
	    }
	    return obj;
	};

	module.exports = TipMessage;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var FileMessage = __webpack_require__(31);
	var util = __webpack_require__(1);

	function VideoMessage() {}
	VideoMessage.prototype = Object.create(FileMessage.prototype);

	VideoMessage.verifyFile = function (file) {
	    util.verifyOptions(file, 'dur w h', true, 'file.');
	};

	module.exports = VideoMessage;

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * 事件信息
	   public enum MsgEventTag {
	    //客户端填写的事件基本信息
	    event_type(1),          //integer 事件类型，服务器保留1～99999
	    event_value(2),        //integer 事件状态
	    msgid_client(3),        //string 客户端生成的消息id
	    config(4),              //string 用户自定义事件扩展属性，最长256字节
	    ttl(5),                 //long 事件有效期，单位：秒，时间范围：60s到7天
	    broadcast_type(6),      //integer 事件广播类型：1:仅在线 2:在线和离线
	    sync_self(7),            //integer 0:不同步给自己，1：同步给自己
	    //服务器预留字段，客户端不填写
	    ttl_type(8),           //integer TtlType枚举值
	    durable(9),            //integer 是否需要持久化(可选字段)，默认为需要持久化,0:不需要持久化，1：需要持久化
	    event_time(10),          //long 事件发布的时间戳，服务器补充
	    msgid_server(11),       //string, 服务端生成的消息id
	    //服务器补充的事件发布人相关信息
	    appid(101),               //long 应用ID
	    publisher_uid(102),      //long 事件发布者的uid
	    publisher_accid(103),    //string 事件发布者的accid
	    client_type(105),        //integer 发送客户端类型(可选,客户端不填)
	    consid(106),           //string 发送设备id(可选,客户端不填)
	  }
	*/
	var util = __webpack_require__(1);
	var notundef = util.notundef;
	var NIMError = __webpack_require__(4);

	function MsgEvent(options) {
	  util.verifyOptions(options, 'type value');
	  util.verifyParamType('type', options.type, 'number');
	  util.verifyParamMin('type', options.type, 100000);
	  util.verifyParamType('value', options.value, 'number');
	  this.type = options.type;
	  this.value = options.value;
	  this.idClient = util.guid();

	  if (notundef(options.custom)) {
	    // util.verifyArrayMax('custom', '' + options.custom, 256)
	    this.custom = '' + options.custom;
	  }

	  // 默认有效时间7天, 60 - 604800
	  this.validTime = options.validTime || 604800;
	  util.verifyParamType('validTime', this.validTime, 'number');
	  util.verifyParamMin('validTime', this.validTime, 60);
	  util.verifyParamMax('validTime', this.validTime, 3600 * 24 * 7);

	  if (notundef(options.broadcastType)) {
	    util.verifyParamType('broadcastType', options.broadcastType, 'number');
	    if ([1, 2].indexOf(options.broadcastType) < 0) {
	      throw new NIMError('参数错误"broadcastType":只能为1或2');
	    }
	    this.broadcastType = options.broadcastType;
	  } else {
	    this.broadcastType = 2;
	  }
	  if (notundef(options.sync)) {
	    util.verifyParamType('sync', options.sync, 'boolean');
	    this.sync = options.sync;
	  } else {
	    this.sync = false;
	  }
	}

	MsgEvent.prototype.assembleEvent = function () {
	  return {
	    type: this.type,
	    value: this.value,
	    idClient: this.idClient,
	    custom: this.custom || '',
	    validTime: this.validTime,
	    broadcastType: this.broadcastType,
	    sync: this.sync === true ? 1 : 0
	  };
	};

	module.exports = MsgEvent;

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * public enum MsgEventSubscribeTag {
	    //客户端填写
	    event_type(1),      //integer 事件类型
	    ttl(2),             //long 订阅有效期，单位：秒，范围：60s到30天
	    sync_event(3),      //integer 订阅后是否立即同步最新事件，1:同步，0:不同步
	    //服务器内部填写
	    publisher_uid(101),   //long 被订阅人（事件发布人）的uid
	    publisher_accid(102), //String 被订阅人（事件发布人）的accid
	    subscribe_uid(103),   //long 订阅人的uid
	    subscribe_accid(104), //string 订阅人的accid
	    subscribe_time(105),  //long 订阅时间戳
	    ;
	 }
	*/
	var util = __webpack_require__(1);
	var notundef = util.notundef;

	function MsgEventSubscribe(options) {
	  util.verifyOptions(options, 'type');
	  util.verifyParamType('type', options.type, 'number');
	  if (util.findObjIndexInArray([1, 2, 3], options.type) < 0) {
	    util.verifyParamMin('type', options.type, 100000);
	  }
	  this.type = options.type;

	  if (notundef(options.subscribeTime)) {
	    util.verifyParamType('subscribeTime', options.subscribeTime, 'number');
	    util.verifyParamMin('subscribeTime', options.subscribeTime, 60);
	    util.verifyParamMax('subscribeTime', options.subscribeTime, 3600 * 24 * 30);
	    this.subscribeTime = options.subscribeTime;
	  } else {
	    this.subscribeTime = 3600 * 24 * 30;
	  }
	  if (notundef(options.sync)) {
	    util.verifyParamType('sync', options.sync, 'boolean');
	    this.sync = options.sync;
	  } else {
	    this.sync = true;
	  }
	}

	MsgEventSubscribe.prototype.assembleEvent = function (options) {
	  return {
	    type: this.type,
	    subscribeTime: this.subscribeTime,
	    sync: this.sync === true ? 1 : 0
	  };
	};

	module.exports = MsgEventSubscribe;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(1);

	/**
	 * 黑名单/静音名单
	 * @constructor
	 * @name Relation
	 * @property {String}   account     账号
	 * @property {Long}     updateTime  更新时间
	 */
	function SpecialRelation() {}

	SpecialRelation.parse = function (sr) {
	  var obj = util.copy(sr);
	  obj.isBlacked = obj.isBlacked === '1';
	  obj.isMuted = obj.isMuted === '1';
	  obj.createTime = +obj.createTime;
	  obj.updateTime = +obj.updateTime;
	  return obj;
	};

	module.exports = SpecialRelation;

/***/ },
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var IMProtocolFn = __webpack_require__(5).fn;
	var LoginPort = __webpack_require__(23);

	IMProtocolFn.assembleLogin = function () {
	  return {
	    login: this.assembleIMLogin()
	  };
	};

	// 登录之后打开数据库
	IMProtocolFn.afterLogin = function () {
	  var self = this;
	  var db = self.db;
	  if (db.enable) {
	    var name = self.account;
	    if (self.options.appendAppKeyForDBName) {
	      name += '-' + self.options.appKey;
	    }
	    self.db.init(name).then(function () {
	      self.syncData();
	    }, function (error) {
	      self.logger.warn('no db', error);
	      db.reset(false);
	      self.syncData();
	    });
	  } else {
	    self.logger.warn('no db');
	    self.syncData();
	  }
	};

	// 处理认证协议
	IMProtocolFn.processAuth = function (packet) {
	  var self = this;
	  switch (packet.cmd) {
	    // 登录回报
	    case 'login':
	      if (!packet.error) {
	        packet.obj = packet.content.loginRes;
	        self.connectionId = packet.content.loginRes.connectionId;
	        self.onLoginPortsChange(packet, 2);
	      }
	      break;
	    // 被踢通知
	    case 'kicked':
	      self.onKicked(packet);
	      return;
	    // 多端登陆通知
	    case 'multiPortLogin':
	      self.onLoginPortsChange(packet, packet.content.state);
	      break;
	    // 踢其它端
	    case 'kick':
	      if (!packet.error) {
	        packet.obj.deviceIds = packet.content.deviceIds;
	      }
	      break;
	    default:
	      break;
	  }
	};

	IMProtocolFn.onLoginPortsChange = function (packet, state) {
	  var self = this;
	  var loginPorts = packet.content.loginPorts;
	  if (!!loginPorts && !!loginPorts.length) {
	    var online = true;
	    switch (state) {
	      // 在线
	      case 2:
	        online = true;
	        break;
	      // 离线
	      case 3:
	        online = false;
	        break;
	      default:
	        break;
	    }
	    loginPorts.forEach(function (p) {
	      p.type = LoginPort.reverseType(p.type);
	      p.time = +p.time;
	      p.online = online;
	    });
	    // 后端返回的结果有时候会带上当前的连接号对应的端, 那么进行去重
	    loginPorts = loginPorts.filter(function (p) {
	      return p.connectionId !== self.connectionId;
	    });
	    if (loginPorts.length) {
	      self.logger.info('on login ports', loginPorts);
	      self.options.onloginportschange(loginPorts);
	    }
	  }
	};

	IMProtocolFn.kickedReasons = ['', 'samePlatformKick', 'serverKick', 'otherPlatformKick', 'silentlyKick'];

	IMProtocolFn.kickedMessages = ['', '不允许同一个帐号在多个地方同时登录', '被服务器踢了', '被其它端踢了', '悄悄被踢'];

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var IMProtocolFn = __webpack_require__(5).fn;

	IMProtocolFn.processChatroom = function (packet) {
	  var self = this;
	  switch (packet.cmd) {
	    case 'getChatroomAddress':
	      self.onChatroomAddress(packet);
	      break;
	  }
	};

	IMProtocolFn.onChatroomAddress = function (packet) {
	  if (!packet.error) {
	    packet.obj.address = packet.content.address;
	  }
	};

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var IMProtocolFn = __webpack_require__(5).fn;
	// var xhr = require('xhr')
	var config = __webpack_require__(3);
	var util = __webpack_require__(1);
	var ajax = __webpack_require__(21);

	IMProtocolFn.refreshSocketUrl = function () {
	  var self = this;
	  var options = self.options;
	  var info = config.info;
	  var lbsUrl = options.lbsUrl;
	  lbsUrl = lbsUrl + util.genUrlSep(lbsUrl) + 'k=' + options.appKey + '&id=' + options.account + '&sv=' + info.sdkVersion + '&pv=' + info.protocolVersion;
	  self.logger.log('refresh lbs', lbsUrl);

	  function onload(body) {
	    self.socketUrls = [];
	    body = JSON.parse(body);
	    body.common.link.forEach(function (url) {
	      self.socketUrls.push(config.formatSocketUrl({
	        url: url,
	        secure: self.options.secure
	      }));
	    });
	    body.common['link.default'].forEach(function (url) {
	      url = config.formatSocketUrl({
	        url: url,
	        secure: self.options.secure
	      });
	      if (self.socketUrls.indexOf(url) === -1) {
	        self.socketUrls.push(url);
	      }
	    });
	    self.logger.log('got socket urls', self.socketUrls);
	    self.connectToUrl(self.getNextSocketUrl());
	  }

	  function onerror(err) {
	    console && console.error(err);
	    self.onDisconnect();
	  }

	  ajax(lbsUrl, {
	    proxyUrl: util.url2origin(lbsUrl) + '/lbs/res/cors/nej_proxy_frame.html',
	    timeout: config.xhrTimeout,
	    onload: onload,
	    onerror: onerror
	  });

	  // xhr({
	  //   method: 'GET',
	  //   cors: true,
	  //   url: lbsUrl,
	  //   timeout: config.xhrTimeout
	  // }, function (error, response, body) {
	  //   if (!error) {
	  //     onload(body)
	  //   } else {
	  //     onerror(error)
	  //   }
	  // })
	};

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _device = __webpack_require__(12);

	var _device2 = _interopRequireDefault(_device);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var IMProtocolFn = __webpack_require__(5).fn;
	var util = __webpack_require__(1);

	var clientTypeMap = _device2['default'].clientTypeMap;

	function formatMsgEvent(msgEvent) {
	  msgEvent = msgEvent || {};
	  var result = util.copy(msgEvent);
	  if (result.clientType) {
	    result.clientType = clientTypeMap[result.clientType] || '';
	  }
	  if (result.serverCustom) {
	    result.custom = JSON.parse(result.serverCustom);
	    if (typeof result.custom[0] === 'string') {
	      result.custom = result.custom[0];
	    }
	    delete result.serverCustom;
	  }
	  return result;
	}

	IMProtocolFn.processEventService = function (packet) {
	  var self = this;
	  var content = packet.content;
	  var error = packet.error;
	  var options = self.options || {};
	  if (error) {
	    this.logger.error(error);
	  }

	  switch (packet.cmd) {
	    // 服务器下推事件，在线记录
	    case 'pushEvent':
	      if (util.isFunction(options.onpushevents)) {
	        var msgEvents = { msgEvents: [formatMsgEvent(content.msgEvent)] };
	        options.onpushevents(msgEvents);
	      }
	      break;
	    // 服务器批量下推事件，离线记录
	    case 'pushEvents':
	      if (util.isFunction(options.onpushevents)) {
	        var _msgEvents = content.msgEvents;
	        var result = _msgEvents.map(function (item) {
	          return formatMsgEvent(item);
	        });
	        _msgEvents = { msgEvents: result };
	        options.onpushevents(_msgEvents);
	      }
	      break;
	  }
	};

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var IMProtocolFn = __webpack_require__(5).fn;

	/**
	 * 目前用于云商服的特殊协议, 服务器端会拦截相关的消息, 然后将这些消息转发到第三方服务器上
	 * 第三方服务器进行处理后, 可以选择回传给服务器处理后的消息（也有可能是重新生成的新的消息）, 服务器会下发这些消息
	 */
	IMProtocolFn.processFilter = function (packet) {
	    // filter表示此消息是过滤消息, 目前这个字段只用于云商服, 不用在文档中列出
	    var self = this;
	    switch (packet.cmd) {
	        // 发送过滤消息
	        case 'sendFilterMsg':
	            self.onSendMsg(packet, true);
	            break;
	        // 过滤消息通知
	        case 'filterMsg':
	            self.onMsg(packet, true);
	            break;
	        // 过滤系统通知通知
	        case 'filterSysMsg':
	            self.onSysMsg(packet, true);
	            break;
	        // 发送过滤自定义系统通知
	        case 'sendFilterCustomSysMsg':
	            self.onSendSysMsg(packet, true);
	            break;
	    }
	};

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var IMProtocolFn = __webpack_require__(5).fn;
	var util = __webpack_require__(1);
	var objs2accounts = util.objs2accounts;
	var Friend = __webpack_require__(57);
	var User = __webpack_require__(32);

	/**
	 * 处理好友协议回包
	 */
	IMProtocolFn.processFriend = function (packet) {
	    var self = this,
	        obj = packet.obj,
	        content = packet.content,
	        error = packet.error;
	    switch (packet.cmd) {
	        // 添加好友
	        case 'friendRequest':
	            self.updateFriendSysMsg(packet);
	            if (!error) {
	                self.onFriendRequest(obj);
	            }
	            break;
	        // 添加好友多端同步
	        case 'syncFriendRequest':
	            self.onFriendRequest(content, true);
	            break;
	        // 删除好友
	        case 'deleteFriend':
	            if (!error) {
	                self.onDeleteFriend(obj);
	            }
	            break;
	        // 删除好友多端同步
	        case 'syncDeleteFriend':
	            self.onDeleteFriend(content, true);
	            break;
	        // 更新好友
	        case 'updateFriend':
	            if (!error) {
	                self.onUpdateFriend(obj);
	            }
	            break;
	        // 更新好友多端同步
	        case 'syncUpdateFriend':
	            self.onUpdateFriend(content.friend, true);
	            break;
	        // 获取好友列表
	        case 'getFriends':
	            self.onFriends(packet);
	            break;
	        // 同步好友列表
	        case 'syncFriends':
	            self.onFriends(packet);
	            break;
	        case 'syncFriendUsers':
	            self.onFriendUsers(packet);
	            break;
	        default:
	            break;
	    }
	};

	/*
	 * 处理好友, 同步和主动获取都会走这个逻辑
	 */
	IMProtocolFn.onFriends = function (packet) {
	    var self = this,
	        db = self.db,
	        error = packet.error,

	    // 有同步和主动获取两种情况
	    isSync = self.packetFromSync(packet),
	        rawFriends = packet.content.friends,
	        hasChange = true,
	        timetag,
	        friends = [],
	        invalidFriends = [];

	    // 用于同步的Promise
	    var promise = new Promise(function (resolve, reject) {
	        if (!error) {
	            // 处理数据
	            parseData();
	            // 如果支持数据库, 那么合并数据, 否则直接 bingo
	            if (db.enable) {
	                mergeData(resolve, reject);
	            } else {
	                bingo();
	                resolve();
	            }
	        } else if (isSync) {
	            // 同步时应该没有error, 所以这里应该走不到
	            reject(error);
	        }
	    });
	    if (isSync) {
	        promise.cmd = 'friends';
	        self.syncPromiseArray.push(promise);
	    }

	    function parseData() {
	        if (hasChange) {
	            rawFriends.forEach(function (friend) {
	                friend = Friend.reverse(friend);
	                if (friend.valid) {
	                    friends.push(friend);
	                } else {
	                    invalidFriends.push(friend);
	                }
	            });
	        }
	        self.logger.warn('parse friends', objs2accounts(friends), friends, 'delete', objs2accounts(invalidFriends), invalidFriends);
	        if (!rawFriends.length) {
	            hasChange = false;
	        } else {
	            hasChange = true;
	            timetag = packet.content.timetag;
	        }
	    }

	    function mergeData(resolveSync, rejectSync) {
	        // 设置用于主动获取的 Promise, 在 callPacketAckCallback 里面使用
	        packet.promise = new Promise(function (resolve, reject) {
	            if (hasChange) {
	                // 增量更新数据库
	                db.mergeFriends(friends, invalidFriends, timetag).then(function () {
	                    afterMergeData();
	                }).then(undefined, function (event) {
	                    event._msg = 'merge friends error';
	                    reject(event);
	                    rejectSync(event);
	                });
	            } else {
	                self.logger.warn('no merge friends');
	                afterMergeData();
	            }
	            function afterMergeData() {
	                // 如果不是同步, 那么需要获取完整的列表
	                if (!isSync) {
	                    db.getFriends().then(function (records) {
	                        friends = records;
	                        bingo();
	                        resolve();
	                        resolveSync();
	                    }).then(undefined, function (event) {
	                        event._msg = 'get friends error';
	                        reject(event);
	                        rejectSync(event);
	                    });
	                } else {
	                    bingo();
	                    resolve();
	                    resolveSync();
	                }
	            }
	        }).then(undefined, function (event) {
	            event._msg = 'merge friends data error';
	            rejectSync(event);
	            throw event;
	        });
	    }

	    function bingo() {
	        self.timetags.friends = timetag;
	        friends.invalid = invalidFriends;
	        // 返回数据
	        if (isSync) {
	            // 如果是同步, 那么统一在 onSyncDone 里面通知开发者
	            self.syncResult.friends = friends;
	            self.syncResult.invalidFriends = invalidFriends;
	        } else {
	            self.logger.warn('get friends', objs2accounts(friends), friends);
	            packet.obj = friends;
	        }
	    }
	};

	/**
	 * 处理好友请求
	 * - 主动发起的好友请求
	 * - 多端同步添加好友
	 * - 收到相关的系统通知
	 * @private
	 * @param  {Object}  obj      请求对象
	 * @param  {Boolean} isSynced 是否是多端同步
	 * @return {Void}
	 */
	IMProtocolFn.onFriendRequest = function (obj, isSynced) {
	    var promise = Promise.resolve();
	    var self = this;
	    var db = self.db;
	    var type = obj.type;
	    type = obj.type = Friend.getTypeFromByte(type) || type;
	    var isAdd = type === 'addFriend' || type === 'passFriendApply';
	    if (isAdd) {
	        // 如果是加好友, 将拼好的对象传给开发者
	        var friend = obj.friend = Friend.assembleFriend(obj.account);
	        // 那么存数据库
	        if (db.enable) {
	            promise = db.putFriend(friend);
	        }
	    }
	    // 如果是多端同步, 那么通知开发者
	    if (isSynced) {
	        self.onSyncFriendAction(obj);
	    }
	    return promise;
	};

	IMProtocolFn.onSyncFriendAction = function (obj) {
	    var self = this;
	    self.logger.info('on sync friendAction', obj);
	    self.options.onsyncfriendaction(obj);
	};

	/**
	 * 删除好友
	 * - 主动删除
	 * - 多端同步删除
	 * - 被删除, 收到系统通知
	 * @private
	 * @param  {Object}  obj      请求对象
	 * @param  {Boolean} isSynced 是否是多端同步
	 * @return {Void}
	 */
	IMProtocolFn.onDeleteFriend = function (obj, isSynced) {
	    var promise = Promise.resolve();
	    var self = this;
	    var db = self.db;
	    if (db.enable) {
	        promise = db.deleteFriend(obj.account);
	    }
	    // 如果是多端同步, 那么通知开发者
	    if (isSynced) {
	        obj.type = 'deleteFriend';
	        self.onSyncFriendAction(obj);
	    }
	    return promise;
	};

	/**
	 * 更新好友
	 * @private
	 * @param  {Object}  obj      请求对象
	 * @param  {Boolean} isSynced 是否是多端同步
	 * @return {Void}
	 */
	IMProtocolFn.onUpdateFriend = function (obj, isSynced) {
	    var self = this;
	    var db = self.db;
	    var friend = Friend.reverse(obj);
	    if (db.enable) {
	        db.updateFriend(friend);
	    }
	    // 如果是多端同步, 那么通知开发者
	    if (isSynced) {
	        self.onSyncFriendAction({
	            type: 'updateFriend',
	            friend: friend
	        });
	    }
	};

	// 只有在启用数据库的时候才同步好友对应的用户名片
	IMProtocolFn.onFriendUsers = function (packet) {
	    var self = this;
	    var db = self.db;
	    var content = packet.content;
	    var users = content.users.map(function (user) {
	        return User.reverse(user);
	    });
	    self.logger.warn('parse users', objs2accounts(users), users);
	    var timetag = content.timetag;
	    var promise = Promise.resolve();
	    if (db.enable) {
	        promise = db.mergeFriendUsers(users, timetag);
	    }
	    self.timetags.friendUsers = timetag;
	    promise.cmd = 'friendUsers';
	    self.syncPromiseArray.push(promise);
	    self.syncResult.users = users;
	};

	/*
	 * 更新系统通知状态
	 */
	IMProtocolFn.updateFriendSysMsg = function (packet) {
	    var obj = packet.obj;
	    var state;
	    var error = packet.error;
	    var sysMsg;

	    if (!packet.obj.idServer) {
	        return;
	    }

	    if (!error) {
	        var type = obj.type;
	        type = Friend.getTypeFromByte(type) || type;
	        switch (type) {
	            case 'passFriendApply':
	                state = 'passed';
	                break;
	            case 'rejectFriendApply':
	                state = 'rejected';
	                break;
	        }
	    } else {
	        state = 'error';
	        error = util.filterObj(error, 'code message');
	    }

	    sysMsg = {
	        idServer: obj.idServer,
	        state: state
	    };
	    if (error) {
	        sysMsg.error = error;
	    }
	    this.updateSysMsg(sysMsg);
	};

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var IMProtocolFn = __webpack_require__(5).fn;
	var util = __webpack_require__(1);
	var undef = util.undef;
	var device = __webpack_require__(12);
	var TeamMember = __webpack_require__(20);
	var Session = __webpack_require__(24);
	var configMap = __webpack_require__(43);

	/**
	 * 处理消息协议
	 */
	IMProtocolFn.processMsg = function (packet) {
	  var self = this;
	  switch (packet.cmd) {
	    // 发送消息
	    case 'sendMsg':
	      self.onSendMsg(packet);
	      break;
	    // 消息通知
	    case 'msg':
	      self.onMsg(packet);
	      break;
	    // 系统通知通知（包括自定义系统通知）
	    case 'sysMsg':
	      self.onSysMsg(packet);
	      break;
	    case 'broadcastMsg':
	      self.onBroadcastMsg(packet);
	      break;
	    // 发送自定义系统通知
	    case 'sendCustomSysMsg':
	      self.onSendSysMsg(packet);
	      break;
	    // 获取单人历史消息
	    case 'getHistoryMsgs':
	    case 'searchHistoryMsgs':
	      self.onHistoryMsgs(packet);
	      break;
	    // 发送消息后发送方的多端同步通知
	    case 'syncSendMsg':
	      self.onMsg(packet);
	      break;
	    case 'deleteSessions':
	      self.onDeleteSessions(packet);
	      break;
	    case 'sendMsgReceipt':
	      self.onSendMsgReceipt(packet);
	      break;
	    case 'msgReceipt':
	      self.onMsgReceipt(packet);
	      break;
	    case 'onDeleteMsg':
	      self.onDeleteMsg(packet);
	      break;
	    case 'onMsgDeleted':
	      self.onMsgDeleted(packet);
	      break;
	    case 'onDeleteMsgOfflineRoaming':
	      self.onDeleteMsgOfflineRoaming(packet);
	      break;
	    case 'onMarkSessionAck':
	      self.onMarkSessionAck(packet);
	      break;
	    case 'syncMarkSessionAck':
	      self.syncMarkSessionAck(packet);
	      break;
	    default:
	      break;
	  }
	};

	IMProtocolFn.checkIgnore = function (msgs) {
	  var self = this;
	  // 询问开发者, 是否要忽略某条通知消息, 如果忽略, 那么不会将其存储到数据库, 并且不会通知给开发者
	  msgs.forEach(function (msg) {
	    if (msg.type === 'notification' && !msg.ignore && self.options.shouldIgnoreNotification(msg)) {
	      msg.ignore = true;
	    }
	  });
	};

	IMProtocolFn.filterIgnore = function (msgs) {
	  return msgs.filter(function (msg) {
	    return !msg.ignore;
	  });
	};

	IMProtocolFn.genSessionByMsgs = function (msgs) {
	  var self = this;
	  self.checkIgnore(msgs);
	  return Session.genSessionByMsgs(self.message.Message, msgs);
	};

	// 收到漫游消息, 需去重
	IMProtocolFn.onRoamingMsgs = function (packet) {
	  var self = this;
	  var message = self.message;
	  var Message = message.Message;
	  var getMaxTimetag = Message.getMaxTimetag;
	  var msgs = message.reverseMsgs(packet.content.msgs);
	  var timetag = getMaxTimetag(msgs);
	  // 服务器返回的数据是按照时间从晚到早排序的, 但是一般UI上都是按照时间从早到晚排序的
	  msgs = Message.sortMsgs(msgs);
	  msgs = Message.deduplication(msgs);
	  var msg = msgs[0];
	  var sessionId = msg.sessionId;
	  // 缓存对应的会话, 这样在同步已读回执时保证内存有数据
	  var session = self.genSessionByMsgs(msgs);
	  self.cacheSyncedSession(session);
	  // 存储漫游消息
	  var promise = self.putMsg(msgs, 'roamingMsgs').then(function (records) {
	    // debugger;
	    // 这里返回的是过滤后的消息, 有可能为空数组
	    msgs = records;
	    // 过滤掉被忽略的消息, 如果没有消息, 那么直接返回
	    msgs = self.filterIgnore(msgs);
	    if (!msgs.length) {
	      return;
	    }
	    // 记录同步结果
	    self.logger.warn('sync roamingMsgs', sessionId, msgs.length, msgs);
	    self.syncResult.roamingMsgs = self.syncResult.roamingMsgs || [];
	    self.syncResult.roamingMsgs.push({
	      sessionId: sessionId,
	      scene: msg.scene,
	      to: msg.target,
	      msgs: msgs,
	      timetag: timetag
	    });
	  });
	  promise.cmd = 'roamingMsgs-' + sessionId;
	  self.syncPromiseArray.push(promise);
	};

	// 收到离线消息, 需去重
	// 不用调用 handleMsg, 因为同步的时候已经同步到这些变更了
	IMProtocolFn.onOfflineMsgs = function (packet, isFilter) {
	  var self = this;
	  var message = self.message;
	  var Message = message.Message;
	  // 处理过滤消息
	  var modifyObj = null;
	  if (isFilter) {
	    modifyObj = {
	      filter: true
	    };
	  }
	  var msgs = message.reverseMsgs(packet.content.msgs, {
	    modifyObj: modifyObj
	  });
	  // 将离线消息按会话分开, 一个会话一个回包
	  var currMsgs = [];
	  var currSessionId = '';
	  var sessionId;
	  var promise;
	  var property = isFilter ? 'offlineFilterMsgs' : 'offlineMsgs';

	  msgs.forEach(function (msg) {
	    sessionId = msg.sessionId;
	    // 如果是新的会话
	    if (sessionId !== currSessionId) {
	      // 存储上一个会话
	      storeLastSession(currSessionId);
	      // 开始新的会话
	      currMsgs = [];
	      currMsgs.push(msg);
	      currSessionId = sessionId;
	    } else {
	      currMsgs.push(msg);
	    }
	  });
	  storeLastSession(currSessionId);
	  // currSessionId 在闭包中被使用，需要分离出来
	  function storeLastSession(currSessionId) {
	    // 第一次 currMsgs 为空
	    if (currMsgs.length) {
	      var timetag = Message.getMaxTimetag(currMsgs);
	      var scene = currMsgs[0].scene;
	      var to = currMsgs[0].target;
	      // 标记消息已读, 要标记所有的消息
	      self.markMsgRead(currMsgs);
	      // 服务器返回的数据是按照时间从晚到早排序的, 但是一般UI上都是按照时间从早到晚排序的
	      currMsgs = Message.sortMsgs(currMsgs);
	      // 去重
	      currMsgs = Message.deduplication(currMsgs);
	      // 缓存对应的会话, 这样在同步已读回执时保证内存有数据
	      var session = self.genSessionByMsgs(currMsgs);
	      self.cacheSyncedSession(session);
	      // 存储离线消息
	      // 存储离线消息的时候会存储会话
	      promise = self.putMsg(currMsgs, 'offlineMsgs').then(function (records) {
	        // debugger;
	        // 这里返回的是过滤后的消息, 有可能为空数组
	        currMsgs = records;
	        // 过滤掉被忽略的消息, 如果没有消息, 那么直接返回
	        currMsgs = self.filterIgnore(currMsgs);
	        if (!currMsgs.length) {
	          return;
	        }
	        // 记录同步结果
	        self.logger.warn('sync', property, currSessionId, currMsgs.length, currMsgs);
	        self.syncResult[property] = self.syncResult[property] || [];
	        self.syncResult[property].push({
	          sessionId: currSessionId,
	          scene: scene,
	          to: to,
	          msgs: currMsgs,
	          timetag: timetag
	        });
	      });
	      promise.cmd = 'offlineMsgs-' + currSessionId;
	      self.syncPromiseArray.push(promise);
	    }
	  }
	};

	// 用于离线消息及漫游消息同步会话未读数
	IMProtocolFn.markUnreadByMsgsPromise = function (sessionId) {
	  var self = this;
	  var db = self.db;
	  if (db.enable) {
	    db.getSession(sessionId).then(function (record) {
	      if (record.ack) {
	        self.markUnreadBySessionAck({ sessionId: sessionId, ack: record.ack });
	      }
	    });
	  }
	};

	/*
	 * 补全消息, 加上某些字段
	 */
	IMProtocolFn.completeMsg = function (msg) {
	  var self = this;
	  msg.from = self.account;
	  msg.fromNick = self.myInfo && self.myInfo.nick;
	  msg.fromClientType = 'Web';
	  msg.fromDeviceId = device.deviceId;
	  if (!msg.time) {
	    msg.time = +new Date();
	  }
	  return msg;
	};

	/*
	 * 收到多条群消息
	 * - 普通群被拉进群并且有人在群里说话了
	 */
	IMProtocolFn.onMsgs = function (packet) {
	  var self = this;
	  self.message.reverseMsgs(packet.content.msgs, {
	    mapper: function mapper(msg) {
	      self.handleMsg(msg);
	    }
	  });
	};

	/*
	 * 收到消息
	 * - 收到一条点对点消息
	 * - 收到一条在其它端发送的点对点消息
	 * - 收到一条群消息
	 * - 收到一条在其它端发送的群消息
	 * - 收到一条过滤消息
	 */
	IMProtocolFn.onMsg = function (packet, isFilter) {
	  var self = this;
	  var msg = self.message.reverse(packet.content.msg);
	  if (isFilter) {
	    msg.filter = true;
	  }
	  // 如果正在同步中, 那么先不处理消息, 等到同步完成之后再处理消息
	  if (self.syncing) {
	    self.unhandledMsgs.push({
	      type: 'onMsg',
	      msg: msg
	    });
	  } else {
	    self.handleMsg(msg);
	  }
	};

	IMProtocolFn.onBroadcastMsgs = function (packet) {
	  var self = this;
	  var broadcastMsgs = packet.content.broadcastMsgs;
	  broadcastMsgs = broadcastMsgs.sort(function (a, b) {
	    return a.broadcastId - b.broadcastId;
	  });
	  self.putBroadcastMsgs(broadcastMsgs);
	};

	IMProtocolFn.onBroadcastMsg = function (packet) {
	  var self = this;
	  var broadcastMsg = packet.content.broadcastMsg;
	  broadcastMsg.time = broadcastMsg.timestamp;
	  if (self.syncing) {
	    self.unhandledMsgs.push({
	      type: 'onBroadcastMsg',
	      msg: broadcastMsg
	    });
	  } else if (broadcastMsg) {
	    self.putBroadcastMsg(broadcastMsg);
	  }
	};

	IMProtocolFn.pushMsgTask = function (task) {
	  var self = this;
	  self.msgPromise = self.msgPromise.then(function () {
	    return task();
	  });
	};

	/*
	 * - 存储并过滤消息
	 * - 更新漫游消息时间戳
	 * - 分类型处理消息
	 * - 通知消息
	 */
	IMProtocolFn.handleMsg = function (msg) {
	  var self = this;
	  var timetag = msg.time;
	  // 标记已读
	  self.markMsgRead(msg);
	  // 处理消息
	  self.msgPromise = self.msgPromise.then(function () {
	    // 存储消息
	    return self.putMsg(msg, 'onMsg');
	  }).then(function (records) {
	    // 这里返回的是过滤后的消息, 有可能为空数组
	    msg = records[0];
	    // 就算过滤后的消息数组为空, 时间戳还是要更新, 防止下次再同步下来
	    return self.updateRoamingMsgTimetag(timetag);
	  }).then(function () {
	    // 检查用户信息是否更新了
	    if (!msg) {
	      return;
	    }
	    return self.checkUserUpdate(msg);
	  }).then(function () {
	    // debugger;
	    // 分类型处理消息
	    if (!msg) {
	      return;
	    }
	    var type = msg.type;
	    self.logger.log('handle ' + msg.scene + ' ' + type + ' msg' + (type === 'notification' ? ' ' + msg.attach.type : ''), msg);
	    switch (type) {
	      case 'notification':
	        return self.onTeamNotificationMsg(msg);
	    }
	  }).then(function () {
	    // debugger;
	    // 通知消息, 但是要先过滤掉被忽略的消息
	    if (!msg || msg.ignore) {
	      return;
	    }
	    self.logger.info('on msg', msg);
	    setTimeout(function () {
	      self.options.onmsg(util.copy(msg));
	    }, 0);
	  }).then(undefined, function (event) {
	    event._msg = 'handle msg error';
	    self.onDBError(event);
	  });
	};

	/*
	 * 更新消息, 以下情况会更新消息
	 * - 收到漫游消息
	 * - 收到离线消息
	 * - 发消息
	 * - 收到在线消息
	 * 策略
	 * - 更新消息之后要更新对应的会话对象
	 * - 如果是收到离线消息、或者收到不是当前会话的在线消息, 那么需要更新未读数
	 * - 如果是收到在线消息, 通知会话
	 * 多 tab 页
	 * - 当支持多个 tab 同时登录时, 收到消息时, 只会在一个 tab 页里面存储这些消息, 其它 tab 页会存储失败
	 * - 存储成功的 tab 负责存储会话和更新未读数, 其它 tab 页也要计算自己的未读数(但是不能更新到数据库), 同时也要将消息推给开发者
	 * type
	 * - `'roamingMsgs'`
	 * - `'offlineMsgs'`
	 * - `'sendMsg'`
	 * - `'onMsg'`
	 */
	IMProtocolFn.putMsg = function (msgs, type) {
	  // debugger;
	  if (!util.isArray(msgs)) {
	    msgs = [msgs];
	  }
	  // 如果是过滤（云商服专用）, 直接返回
	  if (msgs[0].filter) {
	    return Promise.resolve(msgs);
	  }
	  var self = this;
	  var db = self.db;
	  var supportDb = db.enable;
	  var promise = Promise.resolve();
	  var Message = self.message.Message;
	  var lastMsg = Message.getLastMsg(msgs);
	  var flow = lastMsg.flow;
	  var notCurrSession = lastMsg.sessionId !== self.currSessionId;
	  // 后面存储会话函数又调用了一次，可以优化
	  var session = self.genSessionByMsgs(msgs);
	  cacheSession(session);

	  // 落后了, 其它 tab 已经存过了
	  var backward = false;
	  // 未计入未读数的消息
	  var uncountMsgs = [];
	  // 过滤并存储, 存储之前要先标记被忽略的消息
	  self.checkIgnore(msgs);
	  promise = promise.then(function () {
	    // 没有设置自动标记已读，需要缓存消息，用于重置会话未读数resetSessionUnread时，markMsgRead
	    if (!supportDb && !self.options.autoMarkRead && type !== 'roamingMsgs' && session) {
	      self.sessionUnreadMsgs = self.sessionUnreadMsgs || {};
	      self.sessionUnreadMsgs[session.id] = self.sessionUnreadMsgs[session.id] || [];
	      self.sessionUnreadMsgs[session.id] = self.sessionUnreadMsgs[session.id].concat(msgs.filter(function (msg) {
	        var notifySignal = self.options.shouldCountNotifyUnread(msg);
	        return notifySignal;
	      }));
	    }
	    // 如果是漫游和离线消息, 那么等同步完成后统一存
	    if (supportDb && type !== 'roamingMsgs' && type !== 'offlineMsgs') {
	      return db.putMsg(msgs);
	    } else {
	      return msgs;
	    }
	  }).then(function (records) {
	    // debugger;
	    // 过滤出最终回传给用户的消息
	    var arr = [];
	    msgs.forEach(function (msg) {
	      if (self.checkMsgUnique(msg)) {
	        arr.push(msg);
	      }
	    });
	    msgs = arr;
	    if (supportDb) {
	      // records 为存储到数据库的消息数组, 需要根据此数组来更新未读数
	      uncountMsgs = records;
	    } else {
	      uncountMsgs = msgs;
	    }
	    return Promise.resolve(msgs);
	  });
	  // 存储会话
	  // todo 重复回调逻辑（后期存储会话调整 wj）
	  promise = promise.then(function (msgs) {
	    // debugger;
	    // 如果过滤后的消息为空数组, 则不作处理
	    if (msgs.length) {
	      // 计算 session
	      session = self.genSessionByMsgs(msgs);
	      cacheSession(session);
	      // 忽略通知类消息，可能session为null
	      if (supportDb && session) {
	        return new Promise(function (resolve, reject) {
	          // 比较发来的消息与数据库所存储的消息的时间戳
	          db.getSessions({
	            sessionId: session.id
	          }).then(function (record) {
	            if (record && record.lastMsg) {
	              var currLastMsg = record.lastMsg;
	              if (session.lastMsg) {
	                if (session.lastMsg.time < currLastMsg.time) {
	                  session.lastMsg = currLastMsg;
	                }
	              }
	            }
	            // 如果未计入未读数的消息不为空数组, 说明此 tab 页负责存储消息, 那么需要存储会话
	            // 如果未计入未读数的消息为空数组, 则说明其它 tab 页已经存储过消息了, 那么不需要存储会话, 但是依然需要重新计算未读数, 只是不能存储这个未读数
	            if (uncountMsgs.length) {
	              if (session) {
	                db.putSession(session).then(function (recordNew) {
	                  resolve(recordNew);
	                });
	              } else {
	                resolve(record);
	              }
	            } else {
	              backward = true;
	              uncountMsgs = msgs;
	              // 将记录传递给后一个promise
	              // 后一个promise仅仅只涉及未读数，且针对漫游消息
	              resolve(record);
	            }
	          });
	        }); // end return new Promise
	      } // end supportDb
	    }
	    // 没有数据库记录
	    return Promise.resolve(session);
	  });

	  // 更新未读数, 必须是
	  // - 离线消息
	  // - 启用了 syncSessionUnread 之后的比 session.ack 晚的漫游消息
	  // - 收到非当前会话的在线消息
	  // - 此时才将会话存储到数据库，session是内存里的，record是数据库里的
	  promise = promise.then(function (record) {
	    // 如果没有会话, 说明所有的消息都被忽略了, 那么直接返回
	    if (!session) {
	      return;
	    }
	    // 如果未读数没有变化, 直接返回
	    if (!uncountMsgs.length) {
	      return;
	    }
	    var isRoaming = type === 'roamingMsgs';
	    var syncSessionUnread = self.options.syncSessionUnread;
	    var sessionId = session.id;
	    var sessionInMemory = self.findSession(sessionId) || {};
	    var sessionAck = sessionInMemory.ack || 0;
	    var shouldUpdateUnread = type === 'offlineMsgs' || isRoaming && syncSessionUnread || type === 'onMsg' && flow === 'in' && notCurrSession;
	    if (shouldUpdateUnread) {
	      // 如果没有从数据库拿到会话记录, 那么从数据源获取会话记录的未读数
	      if (supportDb && !!record) {
	        session = record;
	        // 如果内存里面没有 session.ack 那么使用数据库里的数据
	        sessionAck = sessionAck || session.ack || 0;
	      } else {
	        record = sessionInMemory;
	        if (record) {
	          session.unread = record.unread || 0;
	        }
	      }
	      cacheSession(session);
	      // 计算未读数
	      session.unread = session.unread || 0;
	      var unread = 0;
	      uncountMsgs.forEach(function (msg) {
	        // 群通知消息不计入未读数
	        // isUnreadable 字段不存在, 或者为 true, 计入未读数
	        var countNotifyUnread = self.options.shouldCountNotifyUnread(msg);
	        var isUnreadable = (msg.type !== 'notification' || msg.type === 'notification' && countNotifyUnread) && (undef(msg.isUnreadable) || msg.isUnreadable);
	        // 如果要同步会话未读数, 那么必须还要满足:
	        // - 消息比 session.ack 晚
	        // - 不是自己发的消息
	        if (isUnreadable && syncSessionUnread) {
	          isUnreadable = msg.time > sessionAck && msg.flow !== 'out';
	        }
	        if (isUnreadable) {
	          unread++;
	          // 如果需要 syncSessionUnread 并且不支持数据库, 那么需要将所有的未读消息记录下来以便在 markSessionAck 的时候计算未读数
	          if (syncSessionUnread && !supportDb) {
	            var unreadMsgs = sessionInMemory.unreadMsgs || [];
	            unreadMsgs.push(msg);
	            session.unreadMsgs = unreadMsgs;
	          }
	        }
	      });
	      session.unread += unread;
	      cacheSession(session);
	      // 更新未读数, 如果落后, 那么不能存储未读数
	      if (supportDb && !backward) {
	        // return db.putSession(session)
	        return db.updateSession({ id: session.id, unread: session.unread });
	      }
	    }
	  });

	  // 通知会话
	  if (type === 'onMsg') {
	    promise = promise.then(function () {
	      // debugger;
	      // 如果过滤后的消息为空数组, 则不作处理
	      // 如果没有会话, 说明都是被忽略的消息, 那么也不作处理
	      if (!!msgs.length && !!session) {
	        self.onUpdateSession(session);
	        // 如果接收消息，且为当前会话，且设置了同步会话未读数，重置未读数，发消息在onSendMsg中重置
	        if (self.options.syncSessionUnread && !notCurrSession) {
	          self.api.resetSessionUnread(self.currSessionId);
	        }
	      }
	    });
	  } else if (type === 'sendMsg' && !notCurrSession && session && session.lastMsg && session.lastMsg.isLocal) {
	    self.onUpdateSession(session);
	    self.api.resetSessionUnread(self.currSessionId);
	  }
	  function cacheSession(session) {
	    if (type === 'roamingMsgs' || type === 'offlineMsgs') {
	      self.cacheSyncedSession(session);
	    }
	  }
	  return promise.then(function () {
	    // 把过滤后的消息返回出去
	    return Promise.resolve(msgs);
	  });
	};

	IMProtocolFn.putBroadcastMsgs = function (msgs) {
	  var self = this;
	  var db = self.db;
	  var len = msgs.length;
	  if (len > 0) {
	    self.doMarkBroadcastMsgsRead(msgs);
	    if (db.enable) {
	      var timetag = msgs[len - 1].broadcastId;
	      db.updateBroadcastMsgTimetag(timetag);
	      return db.putBroadcastMsg(msgs).then(function () {
	        setTimeout(function () {
	          self.doMarkMsgsRead();
	          self.options.onbroadcastmsgs(util.copy(msgs));
	        }, 0);
	        return Promise.resolve(msgs);
	      });
	    } else {
	      setTimeout(function () {
	        self.options.onbroadcastmsgs(util.copy(msgs));
	      }, 0);
	    }
	  }
	  return msgs;
	};

	IMProtocolFn.putBroadcastMsg = function (msg) {
	  var self = this;
	  var db = self.db;
	  self.doMarkBroadcastMsgsRead([msg]);
	  if (db.enable) {
	    if (msg.broadcastId) {
	      db.updateBroadcastMsgTimetag(msg.broadcastId);
	    }
	    return db.putBroadcastMsg(msg).then(function () {
	      setTimeout(function () {
	        self.options.onbroadcastmsg(util.copy(msg));
	      }, 0);
	      return Promise.resolve(msg);
	    });
	  } else {
	    setTimeout(function () {
	      self.options.onbroadcastmsg(util.copy(msg));
	    }, 0);
	    return msg;
	  }
	};

	IMProtocolFn.doMarkBroadcastMsgsRead = function (msgs) {
	  var sid = 7;
	  var cid = 17;
	  msgs = msgs.map(function (msg) {
	    return msg.broadcastId;
	  });
	  this.sendCmd('batchMarkRead', {
	    sid: sid,
	    cid: cid,
	    ids: msgs
	  });
	};

	IMProtocolFn.cacheSyncedSession = function (session) {
	  // 特殊情况下，会出现还没有初始化，但cacheSyncedSession，导致syncResult未定义
	  var self = this;
	  if (session && self.syncResult) {
	    session = util.merge({}, session);
	    // session.unread = session.unread || 0
	    self.syncResult.sessions = self.syncResult.sessions || {};
	    var sessionId = session.id;
	    self.syncResult.sessions[sessionId] = util.merge(self.syncResult.sessions[sessionId], session);
	    if (undef(self.syncResult.sessions[sessionId].unread)) {
	      self.syncResult.sessions[sessionId].unread = 0;
	    }
	    self.mergeSession(self.syncResult.sessions[sessionId]);
	  }
	};

	IMProtocolFn.checkMsgUnique = util.genCheckUniqueFunc('idClient');

	// 发消息之前要存储该消息
	IMProtocolFn.storeSendMsg = function (msg) {
	  var self = this;
	  // 如果正在同步中, 那么先不存储消息, 等到同步完成之后再存储消息
	  if (self.syncing) {
	    self.unhandledMsgs.push({
	      type: 'sendMsg',
	      msg: msg
	    });
	  } else {
	    var promise = self.putMsg(msg, 'sendMsg');
	    self.msgPromise = self.msgPromise.then(function () {
	      return promise;
	    });
	    return promise;
	  }
	};

	// 更新发送失败的消息
	IMProtocolFn.updateSendMsgError = function (msg) {
	  var self = this;
	  // 如果正在同步中, 那么先不更新消息, 等到同步完成之后再更新消息
	  if (self.syncing) {
	    self.unupdatedMsgs.push(msg);
	  } else {
	    var promise = self.updateMsg(msg);
	    self.msgPromise = self.msgPromise.then(function () {
	      return promise;
	    });
	    return promise;
	  }
	};

	// 发了一条消息
	IMProtocolFn.onSendMsg = function (packet, isFilter) {
	  var self = this;
	  var msg = packet.obj && packet.obj.msg || packet.content.msg;
	  self.completeMsg(msg);
	  // 被对方加入了黑名单
	  var blacked = packet.error && packet.error.code === 7101;
	  // 如果没有错误或者错误是被拉黑, 服务器端会返回额外的字段
	  if (!packet.error || blacked) {
	    msg.idServer = packet.content.msg.idServer;
	    msg.time = +packet.content.msg.time;
	  }
	  // 如果有错误，那么重置 status
	  if (packet.error) {
	    msg.status = 'fail';
	  } else {
	    msg.status = 'success';
	  }
	  // 返回给开发者的信息
	  msg = self.message.reverse(msg);
	  if (isFilter) {
	    msg.filter = true;
	  }
	  packet.obj = msg;
	  // 如果正在同步中, 那么先不更新消息, 等到同步完成之后再更新消息
	  if (self.syncing) {
	    self.unupdatedMsgs.push(msg);
	  } else {
	    // 发送消息时会存储消息, 那么需要等这个操作结束后再更新消息状态
	    self.msgPromise = Promise.all([self.msgPromise, packet.obj.promise]).then(function (records) {
	      // 这里返回的是过滤后的消息, 有可能为空数组
	      // 为空时表明是重发的消息, 所以依然需要更新到数据库
	      if (!records.length) {
	        msg.resend = true;
	      }
	      return self.updateMsg(msg).then(function () {
	        // 如果发送或接收消息，且为当前会话，且设置了同步会话未读数
	        if (self.options.syncSessionUnread && self.currSessionId === msg.sessionId) {
	          self.api.resetSessionUnread(self.currSessionId);
	        }
	        self.resolveMsgReceiptTask(msg);
	        return msg;
	      });
	    });
	  }
	};

	// 更新本地消息
	IMProtocolFn.updateLocalMsg = function (msg) {
	  var self = this;
	  var promise = self.updateMsg(msg);
	  self.msgPromise = self.msgPromise.then(function () {
	    return promise;
	  });
	  return promise;
	};

	/**
	 * 发消息收到回包
	 * - 通知开发者, 会话更新了
	 * - 如果支持数据库, 更新消息状态
	 *     - 更新对应会话, 并通知开发者
	 *     - 如果是成功, 那么更新漫游消息时间戳
	 * - 如果不支持数据库, 那么更新记录漫游消息时间戳
	 * @private
	 * @param  {Object} msg 消息对象
	 * @return {Void}
	 */
	IMProtocolFn.updateMsg = function (msg) {
	  // debugger;
	  // 如果是过滤（云商服专用）, 直接返回
	  if (msg.filter) {
	    return Promise.resolve(msg);
	  }
	  var self = this;
	  var db = self.db;
	  var success = msg.status === 'success';
	  var session = Session.genSessionByMsg(msg);
	  var isLocal = !!msg.isLocal;
	  // 通知开发者, 会话更新了
	  self.onUpdateSession(session);
	  if (db.enable) {
	    // 更新消息、会话和时间戳
	    return db.updateMsg(msg).then(function (record) {
	      var p1 = db.updateSession(session);
	      var p2 = Promise.resolve();
	      // 如果是本地消息, 那么不要更新时间戳
	      // 因为是异步的, 所以 record 有可能被删掉了, 所以额外检查一次
	      if (success && record && !isLocal) {
	        p2 = db.updateRoamingMsgTimetag(record.time);
	      }
	      return Promise.all([p1, p2]);
	    });
	  } else {
	    // 如果是本地消息, 那么不要更新时间戳
	    if (success && !isLocal) {
	      self.timetags.roamingMsgs = msg.time;
	    }
	    return Promise.resolve(msg);
	  }
	};

	// updateMsg 之后也要更新漫游消息时间戳，但是并没有调用此方法，是因为逻辑不太一致，代码略有冗余，但是便于理解
	IMProtocolFn.updateRoamingMsgTimetag = function (timetag) {
	  var self = this;
	  var db = self.db;
	  if (db.enable) {
	    return db.updateRoamingMsgTimetag(timetag);
	  } else {
	    self.timetags.roamingMsgs = timetag;
	    return Promise.resolve(timetag);
	  }
	};

	/**
	 * 检查用户信息是否更新了
	 * - 如果不是自己发的消息, 那么检查发消息的人的信息是否被更新了
	 * @private
	 * @param  {String} account 被检查的用户账号
	 * @return {Void}
	 */
	IMProtocolFn.checkUserUpdate = function (msg) {
	  var self = this;
	  var account = msg.from;
	  if (account === self.account) {
	    return Promise.resolve();
	  }
	  return new Promise(function (resolve) {
	    var user = self.userSet[account];
	    // 如果没有此用户信息或者用户信息过时了, 那么更新之
	    if (!user) {
	      refreshUser();
	    } else {
	      var updateTime = +user.updateTime;
	      var userUpdateTime = +msg.userUpdateTime;
	      if (!isNaN(updateTime) && !isNaN(userUpdateTime) && util.isNumber(updateTime) && util.isNumber(userUpdateTime) && updateTime < userUpdateTime) {
	        refreshUser();
	      } else {
	        // 没有更新, 算完成
	        resolve();
	      }
	    }

	    function refreshUser() {
	      self.api.getUser({
	        account: account,
	        sync: true,
	        done: function done(error, user) {
	          // debugger;
	          if (!error) {
	            setTimeout(function () {
	              self.logger.info('on update user', user.account, user);
	              self.options.onupdateuser(user);
	            }, 0);
	          }
	          // 不管有没有错, 都算完成
	          resolve();
	        }
	      });
	    }
	  });
	};

	// 在同步过程中, 收发消息都不进行数据库操作, 等到同步完成之后再处理消息
	IMProtocolFn.processUnsettledMsgs = function () {
	  var self = this;
	  // 先处理 unhandledMsgs (包括收到的消息和发送之前的消息)
	  // 再处理 unupdatedMsgs (包括发送成功的消息和发送失败的消息)
	  self.unhandledMsgs.forEach(function (obj) {
	    var msg = obj.msg;
	    switch (obj.type) {
	      case 'onMsg':
	        self.handleMsg(msg);
	        break;
	      case 'sendMsg':
	        // 在现有的 msgPromise 执行完成之后再执行
	        self.msgPromise = self.msgPromise.then(function () {
	          return self.putMsg(msg);
	        });
	        break;
	      case 'onBroadcastMsg':
	        self.msgPromise = self.msgPromise.then(function () {
	          return self.putBroadcastMsg(msg);
	        });
	    }
	  });
	  self.unupdatedMsgs.forEach(function (msg) {
	    // 在现有的 msgPromise 执行完成之后再执行
	    self.msgPromise = self.msgPromise.then(function () {
	      return self.updateMsg(msg);
	    });
	  });
	  self.resetUnsettledMsgs();
	};

	IMProtocolFn.onTeamNotificationMsg = function (msg) {
	  var self = this;
	  var db = self.db;
	  var attach = msg.attach;
	  var type = attach.type;
	  var from = msg.from;
	  var teamId = msg.to;
	  var timetag = msg.time;
	  var team = attach.team;
	  var account = attach.account;
	  var accounts = attach.accounts;
	  switch (type) {
	    case 'updateTeam':
	      if (!db.enable) {
	        return;
	      }
	      team.updateTime = timetag;
	      self.onUpdateTeam(team);
	      return db.updateTeam(team);
	    case 'addTeamMembers':
	      return self.onAddTeamMembers(msg, team, accounts);
	    case 'removeTeamMembers':
	      return self.onRemoveTeamMembers(team, teamId, accounts);
	    case 'acceptTeamInvite':
	      return self.onAddTeamMembers(msg, team, [from]);
	    case 'passTeamApply':
	      return self.onAddTeamMembers(msg, team, [account]);
	    case 'addTeamManagers':
	      return self.updateTeamManagers(msg, teamId, accounts, true, timetag);
	    case 'removeTeamManagers':
	      return self.updateTeamManagers(msg, teamId, accounts, false, timetag);
	    case 'leaveTeam':
	      return self.onRemoveTeamMembers(team, teamId, [from]);
	    case 'dismissTeam':
	      return self.onDismissTeam(teamId, timetag);
	    case 'transferTeam':
	      return self.transferTeam(msg, team, from, account);
	    case 'updateTeamMute':
	      return self.onUpdateTeamMembersMute(msg, team, [account], attach.mute);
	  }
	};

	/*
	 * 普通群拉人
	 * 高级群接受入群邀请
	 */
	IMProtocolFn.onAddTeamMembers = function (msg, team, accounts) {
	  var self = this;
	  var db = self.db;
	  var teamId = team.teamId;
	  var members = TeamMember.assembleMembers(team, accounts);
	  msg.attach.members = members;
	  var obj = {
	    team: team,
	    accounts: accounts,
	    members: members
	  };
	  self.logger.info('on add team members', obj);
	  self.options.onAddTeamMembers(util.simpleClone(obj));
	  if (!db.enable) {
	    return;
	  }
	  var p1;
	  var p2 = db.putTeam(team);
	  /*
	   * 如果是别人被拉进来了, 那么拼接群成员列表
	   * 如果是自己被拉进来了, 那么同步一次群成员列表
	   */
	  var oldTeam = accounts.indexOf(self.account) === -1;
	  if (oldTeam) {
	    p1 = db.putTeamMembers(members);
	  } else {
	    self.logger.warn('join team', teamId);
	    p2 = new Promise(function (resolve) {
	      self.api.getTeamMembers({
	        teamId: teamId,
	        sync: true,
	        done: function done() {
	          resolve();
	        }
	      });
	    });
	  }
	  return Promise.all([p1, p2]);
	};

	/*
	 * 移出群成员
	 * 主动退群
	 */
	IMProtocolFn.onRemoveTeamMembers = function (team, teamId, accounts) {
	  var self = this;
	  var db = self.db;
	  var obj = {
	    team: team,
	    accounts: accounts
	  };
	  self.logger.info('on remove team members', obj);
	  self.options.onRemoveTeamMembers(util.simpleClone(obj));
	  if (!db.enable) {
	    return;
	  }
	  /*
	   * 如果是别人被踢了, 那么移除群成员
	   * 如果是自己被踢了, 那么离开该群
	   */
	  if (accounts.indexOf(self.account) === -1) {
	    var p1 = db.removeTeamMembersByAccounts(teamId, accounts);
	    var p2 = Promise.resolve();
	    if (team) {
	      p2 = db.putTeam(team);
	    }
	    return Promise.all([p1, p2]);
	  } else {
	    return db.leaveTeam(teamId);
	  }
	};

	IMProtocolFn.updateTeamManagers = function (msg, teamId, accounts, isManager, timetag) {
	  var self = this;
	  var db = self.db;
	  var members = msg.attach.members = accounts.map(function (account) {
	    return {
	      id: TeamMember.genId(teamId, account),
	      type: isManager ? 'manager' : 'normal',
	      updateTime: timetag
	    };
	  });
	  var team = {
	    teamId: '' + teamId,
	    memberUpdateTime: timetag
	  };
	  msg.attach.team = team;

	  var obj = {
	    team: team,
	    accounts: accounts,
	    isManager: isManager,
	    members: members
	  };
	  self.logger.info('on update team managers', obj);
	  self.options.onUpdateTeamManagers(util.simpleClone(obj));

	  if (!db.enable) {
	    return;
	  }
	  var p1 = db.updateTeam(team);
	  var p2 = db.updateTeamManagers(teamId, accounts, isManager, timetag);
	  return Promise.all([p1, p2]);
	};

	IMProtocolFn.onDismissTeam = function (teamId, timetag) {
	  var self = this;
	  var db = self.db;
	  var obj = {
	    teamId: teamId
	  };
	  self.logger.info('on dismiss team', obj);
	  self.options.onDismissTeam(obj);
	  if (!db.enable) {
	    return;
	  }
	  return db.dismissTeam(teamId, timetag);
	};

	IMProtocolFn.transferTeam = function (msg, team, from, account) {
	  var self = this;
	  var db = self.db;
	  var teamId = team.teamId;
	  var memberUpdateTime = team.memberUpdateTime;
	  var oldOwner = {
	    id: TeamMember.genId(teamId, from),
	    type: 'normal',
	    updateTime: memberUpdateTime
	  };
	  var newOwner = {
	    id: TeamMember.genId(teamId, account),
	    type: 'owner',
	    updateTime: memberUpdateTime
	  };
	  msg.attach.members = [oldOwner, newOwner];

	  var obj = {
	    team: team,
	    from: oldOwner,
	    to: newOwner
	  };
	  self.logger.info('on transfer team', obj);
	  self.options.onTransferTeam(util.simpleClone(obj));

	  if (!db.enable) {
	    return;
	  }
	  return db.transferTeam(team, from, account);
	};

	IMProtocolFn.onUpdateTeamMembersMute = function (msg, team, accounts, mute) {
	  var self = this;
	  var db = self.db;
	  var teamId = teamId;
	  var members = accounts.map(function (account) {
	    return {
	      id: TeamMember.genId(team.teamId, account),
	      account: account,
	      teamId: team.teamId,
	      mute: mute,
	      updateTime: team.memberUpdateTime
	    };
	  });
	  msg.attach.members = members;

	  var obj = {
	    team: team,
	    accounts: accounts,
	    members: members,
	    mute: mute
	  };
	  self.logger.info('on update team members mute', obj);
	  self.options.onUpdateTeamMembersMute(util.simpleClone(obj));

	  if (!db.enable) {
	    return;
	  }
	  var p1 = db.updateTeamMembers(members);
	  var p2 = db.putTeam(team);
	  return Promise.all([p1, p2]);
	};

	IMProtocolFn.onHistoryMsgs = function (packet) {
	  if (!packet.error) {
	    packet.obj.msgs = this.message.reverseMsgs(packet.content.msgs);
	  }
	};

	IMProtocolFn.isFilterMsgs = function (msgs) {
	  return !!msgs[0].filter;
	};

	// 分割消息, 将消息分为点对点消息、群消息和过滤消息
	IMProtocolFn.splitMsgs = function (msgs, p2pMsgs, teamMsgs, filterMsgs) {
	  msgs.forEach(function (msg) {
	    if (!msg.filter) {
	      switch (msg.scene) {
	        case 'p2p':
	          p2pMsgs.push(msg);
	          break;
	        case 'team':
	          teamMsgs.push(msg);
	          break;
	      }
	    } else {
	      filterMsgs.push(msg);
	    }
	  });
	};

	/*
	 * 标记消息已读
	 * - 当收到离线消息和在线消息时
	 *     - 如果支持数据库, 那么会存储消息和未读数, 所以标记消息已读
	 *     - 如果不支持数据库, 但是自动标记已读(默认配置), 那么会标记消息
	 *     - 如果不支持数据库, 也不自动标记消息已读, 用户可以主动标记消息已读
	 */
	IMProtocolFn.markMsgRead = function (msgs, force) {
	  if (!util.isArray(msgs)) {
	    msgs = [msgs];
	  }
	  var self = this;
	  var db = self.db;
	  if (db.enable || self.options.autoMarkRead || force) {
	    // 消息分为点对点消息、群消息、过滤消息
	    var p2pMsgs = [];
	    var teamMsgs = [];
	    var filterMsgs = [];
	    self.splitMsgs(msgs, p2pMsgs, teamMsgs, filterMsgs);
	    self.markP2pMsgsRead(p2pMsgs);
	    self.markTeamMsgsRead(teamMsgs);
	    self.markFilterMsgsRead(filterMsgs);
	  }
	};
	IMProtocolFn.markP2pMsgsRead = function (msgs) {
	  if (msgs.length) {
	    var sid = configMap.idMap.msg.id;
	    var cid = configMap.idMap.msg.msg;
	    this.doMarkMsgsRead(sid, cid, msgs);
	  }
	};
	IMProtocolFn.markTeamMsgsRead = function (msgs) {
	  if (msgs.length) {
	    var sid = configMap.idMap.team.id;
	    var cid = configMap.idMap.team.teamMsg;
	    this.doMarkMsgsRead(sid, cid, msgs);
	  }
	};
	IMProtocolFn.markFilterMsgsRead = function (msgs) {
	  if (msgs.length) {
	    var sid = configMap.idMap.filter.id;
	    var cid = configMap.idMap.filter.filterMsg;
	    this.doMarkMsgsRead(sid, cid, msgs);
	  }
	};

	/*
	 * 标记系统通知已收到
	 * - 当收到离线系统通知和在线系统通知时
	 *     - 如果支持数据库, 那么会存储系统通知和未读数, 所以标记系统通知已读
	 *     - 如果不支持数据库, 那么不存储系统通知和未读数, 所以不标记系统通知已读
	 * - 当用户主动标记某条系统通知已读
	 */
	IMProtocolFn.markSysMsgRead = function (sysMsgs, force) {
	  if (!util.isArray(sysMsgs)) {
	    sysMsgs = [sysMsgs];
	  }
	  var self = this;
	  var db = self.db;
	  if (db.enable || self.options.autoMarkRead || force) {
	    var sid, cid;
	    if (self.isFilterMsgs(sysMsgs)) {
	      sid = configMap.idMap.filter.id;
	      cid = configMap.idMap.filter.filterSysMsg;
	    } else {
	      sid = configMap.idMap.msg.id;
	      cid = configMap.idMap.msg.sysMsg;
	    }
	    self.doMarkMsgsRead(sid, cid, sysMsgs);
	  }
	};

	IMProtocolFn.doMarkMsgsRead = function (sid, cid, msgs) {
	  if (msgs && msgs.length) {
	    this.sendCmd('batchMarkRead', {
	      sid: sid,
	      cid: cid,
	      ids: msgs.map(function (msg) {
	        return msg.idServer;
	      })
	    });
	  }
	};

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var IMProtocolFn = __webpack_require__(5).fn;
	var SystemMessage = __webpack_require__(25);
	var Session = __webpack_require__(24);
	var util = __webpack_require__(1);

	IMProtocolFn.onDeleteMsg = function (packet) {
	  delete packet.obj.sysMsg;
	  if (!packet.error) {
	    packet.promise = this.deleteLocalMsg(packet.obj.msg);
	  }
	};

	IMProtocolFn.onMsgDeleted = function (packet) {
	  if (!packet.error) {
	    var self = this;
	    var db = self.db;
	    var sysMsg = SystemMessage.reverse(packet.content.sysMsg);
	    sysMsg = self.processDeleteMsgSysMsg(sysMsg);
	    self.markSysMsgRead(sysMsg);
	    // 删除对应的消息后通知开发者
	    self.deleteLocalMsg(sysMsg.msg).then(function () {
	      if (db.enable) {
	        // 后端的时间戳临界判断有问题, 手动 +1
	        db.updateDeleteMsgTimetag(sysMsg.time + 1);
	      }
	      self.handleSysMsg(sysMsg);
	    });
	  }
	};

	IMProtocolFn.processDeleteMsgSysMsg = function (sysMsg) {
	  var self = this;
	  sysMsg.msg = {};['scene', 'from', 'to'].forEach(function (key) {
	    sysMsg.msg[key] = sysMsg[key];
	  });
	  sysMsg.msg.idClient = sysMsg.deletedIdClient;
	  sysMsg.msg.idServer = sysMsg.deletedIdServer;
	  sysMsg.msg.time = sysMsg.deletedMsgTime;
	  sysMsg.msg.fromNick = sysMsg.deletedMsgFromNick;
	  self.message.Message.setExtra(sysMsg.msg, self.account);
	  return sysMsg;
	};

	// 同步到离线或者漫游撤回消息的通知
	IMProtocolFn.onDeleteMsgOfflineRoaming = function (packet) {
	  if (!packet.error) {
	    var self = this;
	    var type = +packet.content.type === 1 ? 'offline' : 'roaming';
	    var sysMsgs = SystemMessage.reverseSysMsgs(packet.content.sysMsgs, {
	      mapper: function mapper(sysMsg) {
	        return self.processDeleteMsgSysMsg(sysMsg);
	      }
	    });
	    self.logger.warn('sync deleteMsgSysMsgs ' + type, sysMsgs);
	    // 如果是离线, 那么需要标记已收到
	    if (type === 'offline') {
	      self.markSysMsgRead(sysMsgs);
	    }
	    // 存储时间戳
	    var timetag = packet.content.timetag;
	    self.timetags.deleteMsg = timetag;
	    self.syncResult.deleteMsgTimetag = timetag;
	    // 存储系统通知
	    var promise = self.putSysMsg(sysMsgs, 'offlineSysMsgs');
	    promise.cmd = 'deleteMsgSysMsgs ' + type;
	    self.syncPromiseArray.push(promise);
	    self.syncResult.deleteMsgSysMsgs = self.syncResult.deleteMsgSysMsgs || [];
	    self.syncResult.deleteMsgSysMsgs.push({
	      type: type,
	      sysMsgs: sysMsgs
	    });
	  }
	};

	// 根据离线和漫游的撤回消息系统通知来撤回消息, 同时修改回传给用户的会话
	// 最后再存储时间戳
	IMProtocolFn.deleteMsgOfflineRoaming = function (deleteMsgSysMsgs, sessions) {
	  if (!deleteMsgSysMsgs) {
	    return Promise.resolve();
	  }
	  var self = this;
	  self.logger.warn('deleting msgs', deleteMsgSysMsgs);
	  var db = self.db;
	  var array = [];
	  deleteMsgSysMsgs.forEach(function (obj) {
	    obj.sysMsgs.forEach(function (sysMsg) {
	      var p = self.deleteLocalMsg(sysMsg.msg, {
	        // 这里不走 updateLocalSession, 是因为它会通知会话被更新了, 但是同步过程中不需要这个更新
	        cbUpdateSession: function cbUpdateSession(session) {
	          // 修正内存里的会话
	          session = self.mergeSession(session);
	          session = util.simpleClone(session);
	          Session.trim(session);
	          // 修正返回给用户的会话
	          var index = util.findObjIndexInArray(sessions, {
	            value: session.id
	          });
	          if (index !== -1) {
	            sessions[index] = util.merge({}, sessions[index], session);
	          }
	          // 修改数据库里的会话
	          if (db.enable) {
	            return db.updateSession(session);
	          }
	        }
	      });
	      array.push(p);
	    });
	  });
	  return Promise.all(array).then(function () {
	    if (db.enable) {
	      return db.updateDeleteMsgTimetag(self.syncResult.deleteMsgTimetag);
	    }
	  });
	};

	IMProtocolFn.deleteLocalMsg = function (msg, options) {
	  var self = this;
	  var db = self.db;
	  options = options || {};
	  var cbUpdateSession = options.cbUpdateSession || self.updateLocalSession.bind(self);
	  if (db.enable && msg) {
	    // 如果删除的是最后一条消息, 那么需要更新会话
	    var isLast = false;
	    var lastMsg = null;
	    var sessionId = msg.sessionId;
	    return db.getMsgs({
	      sessionId: sessionId,
	      limit: 1
	    }).then(function (msgs) {
	      if (msgs && msgs[0] && msgs[0].idClient === msg.idClient) {
	        isLast = true;
	      }
	    }).then(function () {
	      return db.deleteMsg(msg.idClient);
	    }).then(function () {
	      if (isLast) {
	        return db.getMsgs({
	          sessionId: sessionId,
	          limit: 1
	        });
	      }
	    }).then(function (msgs) {
	      if (isLast) {
	        if (msgs && msgs[0]) {
	          lastMsg = msgs[0];
	        }
	        return cbUpdateSession({
	          id: sessionId,
	          lastMsg: lastMsg
	        });
	      }
	    });
	  } else {
	    return Promise.resolve();
	  }
	};

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var IMProtocolFn = __webpack_require__(5).fn;
	var util = __webpack_require__(1);

	IMProtocolFn.onOfflineMsgReceipts = function (packet) {
	    var self = this;
	    var db = self.db;
	    var rawMsgReceipts = packet.content.msgReceipts;
	    var msgReceipts = self.syncResult.msgReceipts = [];
	    // 首先要检查, 如果存在此会话, 那么才会存储对应的已读回执时间戳
	    var promiseArray = [];
	    var promise;
	    var cmd = 'msgReceipts';
	    var sessions = self.syncResult.sessions || {};
	    rawMsgReceipts.forEach(function (msgReceipt) {
	        msgReceipt.time = +msgReceipt.time;
	        var sessionId = msgReceipt.sessionId = 'p2p-' + msgReceipt.from;
	        cmd += '-' + sessionId;
	        promise = Promise.resolve();
	        // 只有数据库里面有对应的会话或者同步到该回话, 才存储已读回执时间戳
	        var sessionSynced = sessions[sessionId];
	        if (db.enable) {
	            promise = db.getSession(sessionId).then(function (session) {
	                // debugger;
	                session = session || sessionSynced;
	                if (session && self.shouldUpdateSessionFromMsgReceipt(session, msgReceipt)) {
	                    var update = self.genSessionFromMsgReceipt(session, msgReceipt);
	                    // 同步的时候会出现并发存会话的情况，lastMsg会不准，需要从内存数据中取做比较
	                    var tempSession = self.syncResult.sessions;
	                    if (tempSession && tempSession[sessionId]) {
	                        tempSession = tempSession[sessionId];
	                        if (tempSession.lastMsg && update.lastMsg && tempSession.lastMsg.time > update.lastMsg.time) {
	                            update.lastMsg = tempSession.lastMsg;
	                        }
	                    }
	                    return db.putSession(update).then(function (session) {
	                        // debugger;
	                        if (session) {
	                            self.cacheSyncedSession(session);
	                        }
	                    });
	                }
	            });
	        } else if (sessionSynced) {
	            msgReceipts.push(msgReceipt);
	        }
	        promiseArray.push(promise);
	    });
	    promise = Promise.all(promiseArray).then(function () {
	        if (db.enable) {
	            return db.updateMsgReceiptsTimetag(packet.content.timetag);
	        }
	    });
	    promise.cmd = cmd;
	    self.syncPromiseArray.push(promise);
	};

	// 将 msgReceipts 数据 merge 到 sessionSet 里面
	IMProtocolFn.mergeSessionAndMsgReceipts = function (sessions, msgReceipts) {
	    var self = this;
	    var sessionMap = {};
	    sessions = sessions || [];
	    msgReceipts = msgReceipts || [];
	    sessions.forEach(function (session) {
	        sessionMap[session.id] = session;
	    });
	    msgReceipts.forEach(function (msgReceipt) {
	        // debugger;
	        var session = sessionMap[msgReceipt.sessionId];
	        if (self.shouldUpdateSessionFromMsgReceipt(session, msgReceipt)) {
	            var update = self.genSessionFromMsgReceipt(session, msgReceipt);
	            sessions = self.api.mergeSessions(sessions, update);
	        }
	    });
	    return sessions;
	};

	IMProtocolFn.shouldUpdateSessionFromMsgReceipt = function (session, msgReceipt) {
	    // debugger;
	    // 如果没有会话, 或者会话没有消息回执时间服务器时间, 或者同步到的时间戳大于会话的上次服务器时间戳
	    // 用同步到的时间戳覆盖消息回执时间戳和消息回执服务器时间戳
	    return !session || !session.msgReceiptServerTime || msgReceipt.time > session.msgReceiptServerTime;
	};

	IMProtocolFn.genSessionFromMsgReceipt = function (session, msgReceipt) {
	    var time = msgReceipt.time;
	    var update = {
	        id: msgReceipt.sessionId,
	        msgReceiptTime: time,
	        msgReceiptServerTime: time
	    };
	    if (session && session.id === msgReceipt.sessionId) {
	        update = util.merge({}, session, update);
	    }
	    if (!session || !session.updateTime) {
	        update.updateTime = time;
	    }
	    return update;
	};

	IMProtocolFn.onMsgReceipt = function (packet) {
	    var self = this;
	    var db = self.db;
	    var msgReceipt = packet.content.msgReceipt;
	    msgReceipt.time = +msgReceipt.time;
	    var idClient = msgReceipt.idClient;
	    var promise = Promise.resolve();
	    if (db.enable && idClient) {
	        promise = db.getMsgByIdClient(idClient);
	    }
	    promise.then(function (msg) {
	        // debugger;
	        // 如果能拿到 idClient 对应的消息, 那么将消息的时间作为消息回执时间
	        // 否则将服务器返回的时间戳作为消息回执时间
	        // 消息回执时间表示此时间及其之前的所有消息, 对方均已读
	        var msgReceiptTime;
	        if (msg) {
	            // 只有当消息发送到服务器的时候（不论成功还是失败，比如说由于被拉黑而造成服务器认为发送失败）
	            // 才更新消息回执时间戳，否则等消息成功发送后再更新
	            // 模拟的时候可以执行到此，修改 delete idServer, 同时修改 status 为 fail，然后再重新发送该条消息即可
	            // delete msg.idServer
	            // data.msgMap[msg.idClient].status = 'fail';
	            if (msg.idServer) {
	                msgReceiptTime = msg.time;
	            } else {
	                self.msgReceiptTasks[idClient] = msgReceipt;
	                return;
	            }
	        } else {
	            msgReceiptTime = msgReceipt.time;
	        }
	        msgReceipt.msgReceiptTime = msgReceiptTime;
	        self.updateSessionMsgReceiptTime(msgReceipt);
	    });
	};

	IMProtocolFn.resolveMsgReceiptTask = function (msg) {
	    // debugger;
	    var self = this;
	    var msgReceipt = self.msgReceiptTasks[msg.idClient];
	    if (msgReceipt) {
	        msgReceipt.msgReceiptTime = msg.time;
	        this.updateSessionMsgReceiptTime(msgReceipt);
	    }
	};

	IMProtocolFn.updateSessionMsgReceiptTime = function (msgReceipt) {
	    // debugger;
	    var self = this;
	    var db = self.db;
	    var session = {
	        id: 'p2p-' + msgReceipt.from,
	        msgReceiptTime: msgReceipt.msgReceiptTime,
	        msgReceiptServerTime: msgReceipt.time
	    };
	    if (db.enable) {
	        db.putSession(session);
	    }
	    self.onUpdateSession(session);
	};

	IMProtocolFn.onSendMsgReceipt = function (packet) {
	    var self = this;
	    if (!packet.error) {
	        var msgReceiptRequest = packet.obj.msgReceipt;
	        // 发送的时间
	        var time1 = +msgReceiptRequest.time;
	        // 服务器回包时间
	        var time2 = +packet.content.msgReceipt.time;
	        var session = self.sessionSet['p2p-' + msgReceiptRequest.to];
	        // 取较小的时间作为上次发送已读回执的时间
	        // 控制发送已读回执的频率
	        // 如果下次发送已读回执时的消息时间小于此值, 那么忽略之
	        session.msgReceiptSendTime = Math.min(time1, time2);
	    }
	};

	// 是否应该发送已读回执
	IMProtocolFn.shouldSendMsgReceipt = function (msg) {
	    // 只有 'p2p' 消息才应该发送已读回执
	    if (msg && msg.scene === 'p2p' && msg.status === 'success') {
	        var session = this.sessionSet[msg.sessionId];
	        // 只有有会话才应该发送已读回执
	        if (session) {
	            var msgReceiptSendTime = session.msgReceiptSendTime;
	            // 如果没有发送过已读回执或者
	            // 发送过已读回执的时间戳小于消息时间戳
	            // 则应该发送已读回执
	            return !msgReceiptSendTime || msgReceiptSendTime < msg.time;
	        }
	    }
	    return false;
	};

	// 该条消息是否被对方读过
	IMProtocolFn.isMsgRemoteRead = function (msg) {
	    var self = this;
	    // 只有 'p2p' 并且成功发送的消息才进行判断
	    if (msg && msg.scene === 'p2p' && msg.flow === 'out' && msg.status === 'success') {
	        var session = self.sessionSet[msg.sessionId];
	        // 只有有已读回执时间戳的会话才进行判断
	        if (session && session.msgReceiptTime) {
	            // 当消息时间戳不大于已读回执时间戳时, 表示已被对方读过了
	            return msg.time <= session.msgReceiptTime;
	        }
	    }
	    return false;
	};

/***/ },
/* 161 */,
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var IMProtocolFn = __webpack_require__(5).fn;
	var util = __webpack_require__(1);
	var PushNotificationMultiportConfig = __webpack_require__(42);

	IMProtocolFn.processNotify = function (packet) {
	  var self = this;
	  switch (packet.cmd) {
	    // 离线session+team消息同步通知
	    case 'syncOfflineMsgs':
	      self.onOfflineMsgs(packet);
	      break;
	    // 批量标记协议已读
	    case 'batchMarkRead':
	      break;
	    // 离线sysMsg通知
	    case 'syncOfflineSysMsgs':
	      self.onOfflineSysMsgs(packet);
	      break;
	    // 漫游消息同步通知
	    // 每个会话返回一个包
	    // 不需要标记已读
	    case 'syncRoamingMsgs':
	      self.onRoamingMsgs(packet);
	      break;
	    // 离线过滤的消息通知
	    case 'syncOfflineFilterMsgs':
	      self.onOfflineMsgs(packet, true);
	      break;
	    // 离线过滤的sysMsg通知
	    case 'syncOfflineFilterSysMsgs':
	      self.onOfflineSysMsgs(packet, true);
	      break;
	    case 'syncMsgReceipts':
	      self.onOfflineMsgReceipts(packet);
	      break;
	    case 'syncDonnop':
	      self.onDonnop(packet, true);
	      break;
	    case 'syncSessionAck':
	      self.syncSessionAck(packet);
	      break;
	    case 'syncRobots':
	      self.onRobots(packet);
	      break;
	    case 'syncBroadcastMsgs':
	      self.onBroadcastMsgs(packet);
	      break;
	    default:
	      break;
	  }
	};

	/*
	 * 收到多端推送配置项
	 * - 同步 syncDonnop
	 * - 多端操作同步 syncUpdateDonnop
	 */
	IMProtocolFn.onDonnop = function (packet, isSync) {
	  if (!packet.error) {
	    var self = this;
	    var db = self.db;
	    // 解析配置
	    var donnop = PushNotificationMultiportConfig.reverse(packet.content.donnop);
	    self.mergeDonnop(donnop);
	    var promise = self.dbDonnop();
	    if (isSync) {
	      // 存储时间戳
	      var timetag = packet.content.timetag;
	      self.timetags.donnop = timetag;
	      if (db.enable) {
	        promise = promise.then(function () {
	          return self.db.updateDonnopTimetag(timetag);
	        });
	      }
	      promise.cmd = 'donnop';
	      self.syncPromiseArray.push(promise);
	    } else {
	      self.onPushNotificationMultiportConfigUpdate();
	    }
	  }
	};

	IMProtocolFn.onUpdateDonnop = function (packet) {
	  var self = this;
	  if (!packet.error) {
	    var obj = packet.obj;
	    if (obj) {
	      self.mergeDonnop(util.filterObj(obj, ['shouldPushNotificationWhenPCOnline']));
	      self.dbDonnop();
	      self.onPushNotificationMultiportConfigUpdate();
	    }
	  }
	};

	IMProtocolFn.getPushNotificationMultiportConfig = function () {
	  var self = this;
	  return util.merge({}, self.pushNotificationMultiportConfig);
	};

	IMProtocolFn.mergeDonnop = function (donnop) {
	  var self = this;
	  self.pushNotificationMultiportConfig = util.merge({}, self.pushNotificationMultiportConfig, donnop);
	};

	IMProtocolFn.dbDonnop = function () {
	  var self = this;
	  var db = self.db;
	  if (db.enable) {
	    return self.db.setDonnop(self.pushNotificationMultiportConfig);
	  } else {
	    return Promise.resolve();
	  }
	};

	IMProtocolFn.onPushNotificationMultiportConfigUpdate = function () {
	  var self = this;
	  setTimeout(function () {
	    var config = self.getPushNotificationMultiportConfig();
	    self.logger.info('on update pushNotificationMultiportConfig', config);
	    self.options.onPushNotificationMultiportConfigUpdate(config);
	  });
	};

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var IMProtocolFn = __webpack_require__(5).fn;
	var util = __webpack_require__(1);

	// 收到机器人列表消息
	IMProtocolFn.onRobots = function (packet) {
	  var self = this;
	  var content = packet.content;
	  var error = packet.error;
	  if (error) {
	    self.logger.error('sync robots error', error);
	    return;
	  }
	  if (util.isFunction(self.options.onrobots)) {
	    if (Array.isArray(content.robots)) {
	      var robots = content.robots.filter(function (item) {
	        if (!item.botid) {
	          return false;
	        }
	        return true;
	      });
	      if (robots.length > 0) {
	        self.options.onrobots(robots || []);
	      }
	    }
	  }
	};

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var IMProtocolFn = __webpack_require__(5).fn;
	var util = __webpack_require__(1);
	var Session = __webpack_require__(24);
	var NIMError = __webpack_require__(4);

	IMProtocolFn.mergeSession = function (session) {
	  session = util.copyWithNull(session);
	  var sessionSet = this.sessionSet;
	  var sessionId = session.id;
	  var oldSession = sessionSet[sessionId];
	  // 如果最后一条消息的时间戳比当前最后一条消息的小, 那么不更新 lastMsg 字段(适用于本地消息)
	  if (oldSession && oldSession.lastMsg && session && session.lastMsg && session.lastMsg.isLocal) {
	    var t1 = oldSession.lastMsg.time || 0;
	    var t2 = session.lastMsg.time || 0;
	    if (t2 < t1) {
	      return oldSession;
	    }
	  }
	  sessionSet[sessionId] = util.merge(oldSession, session);
	  session = sessionSet[sessionId];
	  if (util.undef(session.unread)) {
	    session.unread = 0;
	  }
	  return session;
	};

	IMProtocolFn.mergeSessions = function (sessions) {
	  var self = this;
	  sessions.forEach(function (session) {
	    self.mergeSession(session);
	  });
	};

	// 删除内存里的会话记录
	IMProtocolFn.deleteLocalSession = function (sessionIds) {
	  var self = this;
	  if (!util.isArray(sessionIds)) {
	    sessionIds = [sessionIds];
	  }
	  sessionIds.forEach(function (sessionId) {
	    delete self.sessionSet[sessionId];
	  });
	};

	IMProtocolFn.onDeleteSessions = function (packet) {
	  packet.obj = packet.obj.sessions.map(function (session) {
	    return Session.parse(session);
	  });
	};

	IMProtocolFn.onUpdateSession = function (session) {
	  var self = this;
	  return new Promise(function (resolve) {
	    if (session) {
	      session = self.mergeSession(session);
	      session = util.simpleClone(session);
	      Session.trim(session);
	      if (Session.isComplete(session)) {
	        setTimeout(function () {
	          self.logger.info('on update session', session.id, util.simpleClone(session));
	          self.options.onupdatesession(session);
	          resolve(session);
	        }, 0);
	      }
	    } else {
	      resolve(session);
	    }
	  });
	};

	/*
	 * 设置当前会话, 并重置它的未读数
	 */
	IMProtocolFn.setCurrSession = function (sessionId) {
	  var self = this;
	  sessionId = '' + sessionId;
	  self.currSessionId = sessionId;
	  self.logger.warn('set curr session', sessionId);
	};

	IMProtocolFn.findSession = function (sessionId) {
	  return this.sessionSet[sessionId];
	};

	/*
	 * 重置某个会话未读数
	 *
	 * - 如果没有该会话, 那么直接返回
	 */
	IMProtocolFn.resetSessionUnread = function (sessionId) {
	  sessionId = '' + sessionId;
	  var self = this;
	  var db = self.db;
	  var session;
	  if (!self.findSession(sessionId)) {
	    self.logger.warn('reset session unread, no session ' + sessionId);
	    return;
	  }
	  if (db.enable) {
	    db.resetSessionUnread(sessionId);
	  }
	  // 如果没有设置自动标记会话已读
	  if (!self.options.autoMarkRead && self.sessionUnreadMsgs && self.sessionUnreadMsgs[sessionId]) {
	    var currMsgs = self.sessionUnreadMsgs[sessionId];
	    self.markMsgRead(currMsgs, true);
	    self.sessionUnreadMsgs[sessionId] = [];
	  }
	  updateSession();
	  function updateSession() {
	    session = {
	      id: sessionId,
	      unread: 0
	    };
	    self.onUpdateSession(session);
	  }
	};

	// 插入一条本地回话记录, 如果已存在则报错
	IMProtocolFn.insertLocalSession = function (options) {
	  var self = this;
	  var db = self.db;
	  var sessionSet = self.sessionSet;
	  return new Promise(function (resolve, reject) {
	    var scene = options.scene;
	    var to = options.to;
	    var sessionId = scene + '-' + to;
	    var session = self.findSession(sessionId);
	    if (!session) {
	      // 会话更新的时间, 如果不填, SDK 会设置一个比当前所有会话更新时间大的一个时间
	      var updateTime;
	      if (util.isNumber(options.updateTime)) {
	        updateTime = options.updateTime;
	      } else {
	        var times = [];
	        var s;
	        for (var key in sessionSet) {
	          if (sessionSet.hasOwnProperty(key)) {
	            s = sessionSet[key];
	            if (util.isNumber(s.updateTime)) {
	              times.push(s.updateTime);
	            }
	          }
	        }
	        updateTime = Math.max.apply(Math, times) + 1;
	        updateTime = Math.max(updateTime, +new Date());
	      }
	      // 找一下会话的最后一条历史消息
	      var p = Promise.resolve();
	      if (db.enable) {
	        p = db.getMsgs({
	          sessionId: sessionId,
	          limit: 1
	        });
	      }
	      p.then(function (msgs) {
	        // 如果有最后一条消息, 那么根据它来生成会话并更新 updateTime
	        if (util.isArray(msgs) && msgs.length === 1) {
	          var msg = msgs[0];
	          session = Session.genSessionByMsg(msg);
	          session.updateTime = updateTime;
	        } else {
	          // 如果没有, 手动构造会话
	          session = {
	            id: sessionId,
	            scene: scene,
	            to: to,
	            updateTime: updateTime,
	            lastMsg: null
	          };
	        }
	        if (db.enable) {
	          db.putSession(session).then(resolve, reject);
	        } else {
	          resolve(session);
	        }
	        self.onUpdateSession(session);
	      });
	    } else {
	      self.logger.warn('session exist');
	      reject(NIMError.sessionExist());
	    }
	  });
	};
	/**
	 * options
	 * flag 是否删除最后条消息
	 */

	IMProtocolFn.updateLocalSession = function (options, flag) {
	  var self = this;
	  return new Promise(function (resolve, reject) {
	    var db = self.db;
	    var session = self.findSession(options.id);
	    if (session) {
	      var p = Promise.resolve();
	      var obj = util.filterObj(options, 'id lastMsg localCustom');
	      if (db.enable) {
	        p = db.updateSession(obj);
	      }
	      p.then(function (record) {
	        return self.onUpdateSession(record, flag);
	      }).then(resolve, function (error) {
	        reject(error);
	      });
	    } else {
	      self.logger.warn('no session ', options.id);
	      reject(NIMError.sessionNotExist());
	    }
	  });
	};

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var IMProtocolFn = __webpack_require__(5).fn;

	// 同步到 session ack
	IMProtocolFn.syncSessionAck = function (packet) {
	  var self = this;
	  var db = self.db;
	  // 将 session ack 存储于内存和数据库
	  var promise = Promise.resolve();[[packet.content.p2p, 'p2p'], [packet.content.team.m_map, 'team']].forEach(function (arr) {
	    var map = arr[0];
	    var scene = arr[1];
	    Object.keys(map).forEach(function (to) {
	      var id = scene + '-' + to;
	      var session = {
	        id: id,
	        ack: map[to]
	      };
	      if (db.enable) {
	        promise = promise.then(function () {
	          return db.putSession(session);
	        }).then(function () {
	          self.markUnreadBySessionAck({ sessionId: id, ack: map[to] });
	        });
	      }
	      self.mergeSession(session);
	    });
	  });
	  self.logger.warn('parse offline session ack', self.sessionSet);
	  // 存储同步时间戳
	  var timetag = packet.content.timetag;
	  if (db.enable) {
	    promise = promise.then(function () {
	      return self.db.updateSessionAck(timetag);
	    });
	  }
	  promise.cmd = 'sessionAck';
	  self.syncPromiseArray.push(promise);
	};

	// mark session ack 的回包
	IMProtocolFn.onMarkSessionAck = function (packet) {
	  if (!packet.error) {
	    this.storeSessionAck(packet.obj);
	  }
	};

	// mark session ack 的多端同步包
	IMProtocolFn.syncMarkSessionAck = function (packet) {
	  this.storeSessionAck(packet.content);
	};

	// 在 onMarkSessionAck 和 syncMarkSessionAck 之后
	// - 存储 session ack
	// - 并更新会话未读数, 凡是比 ack 早的消息均为已读, 凡是比 ack 晚的消息均为未读
	IMProtocolFn.storeSessionAck = function (obj) {
	  var self = this;
	  var syncSessionUnread = self.options.syncSessionUnread;
	  // 如果没有开启同步, 那么直接返回
	  if (!syncSessionUnread) {
	    return;
	  }
	  var db = self.db;
	  var scene = obj.scene === 0 ? 'p2p' : 'team';
	  var sessionId = scene + '-' + obj.to;
	  var ack = obj.timetag;
	  // 如果 ack 比现有的小, 那么这个包无效, 直接返回
	  var sessionInMemory = self.findSession(sessionId) || {};
	  var ackInMemory = sessionInMemory.ack || 0;
	  if (ack <= ackInMemory) {
	    self.logger.warn('useless ack, no store session ack', ack);
	    return;
	  }
	  // 存储 ack
	  var session = {
	    id: sessionId,
	    ack: ack
	  };
	  self.mergeSession(session);
	  if (db.enable) {
	    db.updateSession(session);
	  }
	  self.logger.warn('store session ack', session);
	  // update session unread
	  self.markUnreadBySessionAck({ sessionId: sessionId, ack: session.ack });
	};

	// update session unread
	// param {sessionId, ack}
	IMProtocolFn.markUnreadBySessionAck = function (_ref) {
	  var sessionId = _ref.sessionId,
	      ack = _ref.ack;

	  var self = this;
	  var db = self.db;
	  if (db.enable) {
	    self.pushMsgTask(function () {
	      return db.getMsgCountAfterAck({
	        shouldCountNotifyUnread: self.options.shouldCountNotifyUnread,
	        sessionId: sessionId,
	        ack: ack
	      }).then(function (unread) {
	        var s = {
	          id: sessionId,
	          unread: unread
	        };
	        // if (self.currSessionId === sessionId) {
	        //   // 如果是当前会话，会话未读数强制为0
	        //   s.unread = 0
	        // }
	        self.logger.warn('update unread via session ack');
	        // 通知和更新数据库同时进行, 数据库操作会有一定延时
	        if (self.syncing) {
	          self.cacheSyncedSession(s);
	        }
	        self.onUpdateSession(s);
	        return db.updateSession(s);
	      });
	    });
	  } else {
	    var s = self.findSession(sessionId);
	    if (s) {
	      var unreadMsgs = s.unreadMsgs;
	      if (unreadMsgs && unreadMsgs.length) {
	        var unread = 0;
	        var arr = [];
	        // 找到所有比 ack 晚的消息, 这些都算未读的
	        for (var i = unreadMsgs.length - 1; i >= 0; i--) {
	          var msg = unreadMsgs[i];
	          if (msg.time > ack) {
	            unread++;
	            arr.push(msg);
	          } else {
	            break;
	          }
	        }
	        s.unreadMsgs = arr;
	        s.unread = unread;
	        self.logger.warn('update unread via session ack');
	        self.onUpdateSession(s);
	      }
	    }
	  }
	};

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var IMProtocolFn = __webpack_require__(5).fn;
	var util = __webpack_require__(1);
	var NIMError = __webpack_require__(4);
	var undef = util.undef;
	var objs2ids = util.objs2ids;
	var objs2accounts = util.objs2accounts;
	var teams2ids = util.teams2ids;
	var Session = __webpack_require__(24);

	IMProtocolFn.beforeSync = function () {
	  var _this = this;
	  var db = _this.db;
	  if (db.enable) {
	    return db.clearSendingMsgs();
	  }
	  return Promise.resolve();
	};

	/*
	 * 同步数据, 强制同步离线消息, 其它同步做成可选的
	 * 所有的同步时间戳在同步完成之后才更新, 在单个更新的回包之后不更新, 这样就不会因为回包顺序问题导致时间戳记录有问题
	 */
	IMProtocolFn.syncData = function () {
	  var _this = this;
	  var db = _this.db;
	  var options = _this.options;
	  var supportDb = db.enable;
	  _this.notifyLogin();
	  _this.syncing = true;
	  if (supportDb) {
	    _this.beforeSync().then(function () {
	      return _this.db.getTimetags();
	    }).then(function (timetags) {
	      bingo(timetags);
	    }, function () {
	      bingo();
	    });
	  } else {
	    bingo(_this.timetags);
	  }
	  function bingo(timetags) {
	    _this.syncPromiseArray = [];
	    _this.syncResult = {};
	    _this.syncTeamMembersPromiseArray = [];
	    _this.syncTeamMembersResult = {};

	    // 默认同步
	    util.verifyBooleanWithDefault(options, 'syncRelations syncFriends syncFriendUsers syncTeams syncRoamingMsgs syncMsgReceipts syncExtraTeamInfo', true);
	    // 默认不同步
	    // 过滤的消息（目前只有云商服用到过滤消息）
	    util.verifyBooleanWithDefault(options, 'syncFilter syncTeamMembers', false);

	    var sync = {};
	    timetags = timetags || {};
	    if (window._nimForceSyncIM) {
	      _this.logger.warn('upgrade force sync');
	      delete timetags.teams;
	      window._nimForceSyncIM = false;
	    }
	    // 强制同步 我的信息、离线消息
	    sync.myInfo = timetags.myInfo || 0;
	    sync.offlineMsgs = 0;
	    // 可选同步
	    if (options.syncRelations) {
	      sync.relations = timetags.relations || 0;
	    }
	    if (options.syncFriends) {
	      sync.friends = timetags.friends || 0;
	    }
	    if (options.syncFriendUsers) {
	      sync.friendUsers = timetags.friendUsers || 0;
	    }
	    if (options.syncRobots) {
	      sync.robots = timetags.robots || 0;
	    }
	    if (options.syncTeams) {
	      sync.teams = timetags.teams || 0;
	    }
	    if (options.syncRoamingMsgs) {
	      sync.roamingMsgs = timetags.roamingMsgs || 0;
	    }
	    if (options.syncMsgReceipts) {
	      sync.msgReceipts = timetags.msgReceipts || 0;
	    }
	    // 不同步最近会话列表, 从漫游消息和离线消息构造最近会话列表
	    // 所以如果没有漫游消息和离线消息, 那么就没有最近会话列表
	    // if (false) { sync.sessions = 0; }
	    // 有四种情况, 无数据库不同步群成员, 无数据库同步群成员, 有数据库不同步群成员, 有数据库同步群成员
	    // 但是因为群和群成员是分开同步的, 所以还是用时间戳 0 来同步所有我的群成员
	    if (options.syncExtraTeamInfo) {
	      sync.myTeamMembers = timetags.myTeamMembers || 0;
	    }
	    // 同步会话 ack 位置
	    if (options.syncSessionUnread) {
	      sync.sessionAck = timetags.sessionAck || 0;
	    }
	    if (options.syncBroadcastMsgs) {
	      sync.broadcastMsgs = timetags.broadcastMsg || 0;
	    }
	    sync.donnop = timetags.donnop || 0;
	    sync.deleteMsg = timetags.deleteMsg || 0;
	    // 目前只有云商服用到这个配置, 未在文档上列出
	    if (options.syncFilter) {
	      sync.filterMsgs = 0;
	    }
	    _this.sendCmd('sync', {
	      sync: sync
	    }, _this.onSyncData.bind(_this));
	  }
	};

	IMProtocolFn.onSyncData = function (error, obj) {
	  if (error && this.syncRetryTimes > 3) {
	    this.syncRetryTimes = 0;
	    this.onMiscError(error, obj, 'sync error');
	  }
	};

	IMProtocolFn.processSync = function (packet) {
	  var self = this;
	  self.syncRetryTimes = self.syncRetryTimes || 0;
	  self.syncRetryTimes++;
	  switch (packet.cmd) {
	    // 同步
	    case 'syncDone':
	      if (packet.error) {
	        if (self.syncRetryTimes > 3) {
	          // throw new NIMError('同步消息错误-code: ' + packet.error)
	          // self.onError(`同步消息错误-code: ${packet.error}`)
	        } else {
	          // 重新同步
	          self.syncData();
	        }
	      } else {
	        self.timetags.sync = packet.content.timetag;
	        self.onSyncDone();
	      }
	      // setTimeout(self.onSyncDone.bind(self), 10000);
	      break;
	    // 同步群成员
	    case 'syncTeamMembersDone':
	      self.onSyncTeamMembersDone();
	      break;
	    default:
	      break;
	  }
	};

	IMProtocolFn.onSyncDone = function (syncError) {
	  var self = this;
	  var db = self.db;
	  var supportDb = db.enable,
	      options = self.options,

	  // self.syncPromiseArray 用于同步msg/roamingMsgs/friend等需要存db的操作
	  promiseArray = self.syncPromiseArray,

	  // syncResult里的session可以从roamingMsgs里塞，也可以从数据库里取
	  result = self.syncResult,
	      promise,
	      blacklist,
	      invalidBlacklist,
	      mutelist,
	      invalidMutelist,
	      friends,
	      invalidFriends,
	      myInfo,
	      users,
	      teams,
	      invalidTeams,
	      sessions,
	      msgReceipts,
	      roamingMsgs,
	      offlineMsgs,
	      offlineFilterMsgs,
	      roamingSysMsgs,
	      offlineSysMsgs,
	      offlineCustomSysMsgs,
	      offlineFilterSysMsgs,
	      offlineFilterCustomSysMsgs,
	      broadcastMsgs,
	      sysMsgUnread;
	  // 在 putMsg 中进行会话的存储
	  if (promiseArray && promiseArray.length) {
	    (function () {
	      var sessionAckPromise = promiseArray.filter(function (item) {
	        return item.cmd === 'sessionAck';
	      });
	      if (sessionAckPromise.length === 0) {
	        sessionAckPromise.push(Promise.resolve());
	      }
	      var normalPromise = promiseArray.filter(function (item) {
	        return item.cmd !== 'sessionAck';
	      });
	      if (normalPromise.length === 0) {
	        normalPromise.push(Promise.resolve());
	      }
	      Promise.all(normalPromise).then(function () {
	        return Promise.all(sessionAckPromise);
	      }).then(afterSync, function (e) {
	        self.onDBError(e);
	      })['catch'](function (e) {
	        // ... 待修改
	        self.syncData();
	        // afterSync()
	      });
	    })();
	  } else {
	    afterSync();
	  }

	  function afterSync() {
	    if (!promiseArray) {
	      // 允许单独同步部分字段，允许非初始化时同步
	      self.logger.warn('after sync --no promiseArray');
	      return;
	    }
	    self.logger.warn('after sync', util.promises2cmds(promiseArray));
	    promiseArray = [];
	    blacklist = result.blacklist || [];
	    invalidBlacklist = result.invalidBlacklist || [];
	    mutelist = result.mutelist || [];
	    invalidMutelist = result.invalidMutelist || [];
	    friends = result.friends;
	    invalidFriends = result.invalidFriends || [];
	    myInfo = result.myInfo;
	    users = result.users;
	    teams = result.teams;
	    invalidTeams = result.invalidTeams || [];
	    sessions = result.sessions;
	    msgReceipts = result.msgReceipts;
	    roamingMsgs = result.roamingMsgs;
	    offlineMsgs = result.offlineMsgs;
	    offlineFilterMsgs = result.offlineFilterMsgs;
	    offlineSysMsgs = result.offlineSysMsgs;
	    offlineCustomSysMsgs = result.offlineCustomSysMsgs;
	    offlineFilterSysMsgs = result.offlineFilterSysMsgs;
	    offlineFilterCustomSysMsgs = result.offlineFilterCustomSysMsgs;
	    broadcastMsgs = result.broadcastMsgs;
	    sysMsgUnread = result.sysMsgUnread;

	    if (sessions) {
	      var arr = [];
	      Object.keys(sessions).forEach(function (key) {
	        arr.push(sessions[key]);
	      });
	      sessions = arr.sort(function (s1, s2) {
	        return s2.updateTime - s1.updateTime;
	      });
	    }

	    var p = Promise.resolve();
	    if (supportDb) {
	      p = storeRoamingOfflineData().then(function (records) {
	        var tempSessionMap = {};
	        records.forEach(function (msg) {
	          var sessionId = msg.sessionId;
	          if (!tempSessionMap[sessionId]) {
	            tempSessionMap[sessionId] = true;
	            self.markUnreadByMsgsPromise(sessionId);
	          }
	        });
	      });
	    }
	    p.then(function () {
	      // 如果启用了数据库, 并且还没有同步过, 那么从数据库获取全量数据
	      if (supportDb && !self.hasSynced) {
	        self.hasSynced = true;
	        pullFullData();
	      }
	      // 在 pullFullData 中 push promiseArray
	      var sessionAckPromise = promiseArray.filter(function (item) {
	        return item.cmd === 'sessionAck';
	      });
	      if (sessionAckPromise.length === 0) {
	        sessionAckPromise.push(Promise.resolve());
	      }
	      var normalPromise = promiseArray.filter(function (item) {
	        return item.cmd !== 'sessionAck';
	      });
	      if (normalPromise.length === 0) {
	        normalPromise.push(Promise.resolve());
	      }
	      Promise.all(normalPromise).then(function () {
	        return Promise.all(sessionAckPromise);
	      }).then(taskAfterSync).then(notifyData, self.onDBError.bind(self));
	    });
	  }
	  // 此处仅仅存储离线消息和漫游消息
	  function storeRoamingOfflineData() {
	    var arr = [];
	    var p;
	    // 存储漫游消息和离线消息
	    var msgs = [];
	    if (roamingMsgs) {
	      roamingMsgs.forEach(function (i) {
	        msgs = [].concat(msgs, i.msgs);
	      });
	    }

	    if (offlineMsgs) {
	      offlineMsgs.forEach(function (i) {
	        msgs = [].concat(msgs, i.msgs);
	      });
	    }
	    p = db.putMsg(msgs);
	    arr.push(p);
	    return Promise.all(arr).then(function () {
	      return msgs;
	    });
	  }

	  function pullFullData() {
	    // 关系
	    if (options.syncRelations) {
	      promise = db.getRelations().then(function (result) {
	        blacklist = result[0];
	        mutelist = result[1];
	        blacklist.invalid = invalidBlacklist;
	        mutelist.invalid = invalidMutelist;
	      }, function (event) {
	        event._msg = 'on relations error';
	        return event;
	      });
	      promiseArray.push(promise);
	    }
	    // 好友
	    if (options.syncFriends) {
	      promise = db.getFriends().then(function (records) {
	        friends = records;
	        friends.invalid = invalidFriends;
	      }, function (event) {
	        event._msg = 'on friends error';
	        return event;
	      });
	      promiseArray.push(promise);
	    }
	    // 我的名片
	    if (undef(myInfo)) {
	      promise = db.getUser(self.account).then(function (record) {
	        myInfo = record;
	      }, function (event) {
	        event._msg = 'on myInfo error';
	        return event;
	      });
	      promiseArray.push(promise);
	    }
	    // 好友名片
	    if (options.syncFriendUsers) {
	      promise = db.getFriends().then(function (records) {
	        return records.map(function (friend) {
	          return friend.account;
	        });
	      }).then(function (accounts) {
	        return db.getUsers(accounts);
	      }).then(function (records) {
	        users = records;
	      }, function (event) {
	        event._msg = 'on users error';
	        return event;
	      });
	      promiseArray.push(promise);
	    }
	    // 群
	    if (options.syncTeams) {
	      promise = db.getTeams().then(function (records) {
	        teams = records;
	        teams.invalid = invalidTeams;
	      }, function (event) {
	        event._msg = 'on teams error';
	        return event;
	      });
	      promiseArray.push(promise);
	    }
	    // 我的群成员
	    promise = db.getTeamMembersByAccount(self.account).then(function (members) {
	      self.mergeMyTeamMembers(members);
	    });
	    promiseArray.push(promise);
	    // donnop
	    promise = db.getDonnop().then(function (donnop) {
	      self.mergeDonnop(donnop);
	    });
	    promiseArray.push(promise);
	    // 会话
	    promise = db.getSessions().then(function (records) {
	      sessions = records;
	    }, function (event) {
	      event._msg = 'on sessions error';
	      return event;
	    });
	    promiseArray.push(promise);
	    // 系统通知未读数
	    promise = db.getSysMsgUnread().then(function (records) {
	      sysMsgUnread = records;
	    }, function (event) {
	      event._msg = 'on sysMsgUnread error';
	      return event;
	    });
	    promiseArray.push(promise);
	  }

	  // 同步完成之后的一些任务, 这些任务放在这里是为了保证时序上的问题
	  // - 比如说漫游消息和离线消息要存储好之后才能删除, 如果删的操作过早是没有效果的
	  // - 首先将被删除的消息从漫游和离线里剔除, 然后从数据库里删除这些消息, 同时修改回传给用户的会话
	  function taskAfterSync() {
	    self.logger.warn('taskAfterSync');
	    rejectDeletedMsgs();
	    var array = [];
	    array.push(self.deleteMsgOfflineRoaming(result.deleteMsgSysMsgs, sessions));
	    return Promise.all(array);
	  }

	  // 将被删除的消息从漫游和离线里剔除
	  function rejectDeletedMsgs() {
	    if (result.deleteMsgSysMsgs) {
	      var roamingMsgsMap = {};
	      if (roamingMsgs) {
	        roamingMsgs.forEach(function (obj) {
	          roamingMsgsMap[obj.sessionId] = obj;
	        });
	      }
	      var offlineMsgsMap = {};
	      if (offlineMsgs) {
	        offlineMsgs.forEach(function (obj) {
	          offlineMsgsMap[obj.sessionId] = obj;
	        });
	      }
	      // 剔除消息
	      var api = self.api;
	      result.deleteMsgSysMsgs.forEach(function (obj) {
	        obj.sysMsgs.forEach(function (sysMsg) {
	          var msg = sysMsg.msg;
	          var sessionId = msg.sessionId;[roamingMsgsMap, offlineMsgsMap].forEach(function (roamingOfflineMsgsMap) {
	            if (roamingOfflineMsgsMap[sessionId]) {
	              roamingOfflineMsgsMap[sessionId].msgs = api.cutMsgs(roamingOfflineMsgsMap[sessionId].msgs, msg);
	            }
	          });
	        });
	      });
	      // 修正会话, 只有在没有数据库的时候才修正, 有数据的时候在 deleteMsgOfflineRoaming 里面修正会话
	      if (!db.enable) {
	        ;[roamingMsgs, offlineMsgs].forEach(function (roamingOfflineMsgs) {
	          if (roamingOfflineMsgs) {
	            roamingOfflineMsgs.forEach(function (obj) {
	              if (obj.msgs.length) {
	                var session = self.genSessionByMsgs(obj.msgs);
	                self.cacheSyncedSession(session);
	                sessions = api.mergeSessions(sessions, session);
	              } else {
	                sessions = api.cutSessions(sessions, {
	                  id: obj.sessionId
	                });
	              }
	            });
	          }
	        });
	      }
	    }
	  }

	  function notifyData() {
	    // 用 setTimeout 模拟异步线程
	    setTimeout(notifyDataAsync, 0);
	  }

	  function notifyDataAsync() {
	    // 是否要等待同步漫游消息时间戳
	    var timetags = [],
	        timetag,
	        msgs;

	    if (blacklist) {
	      self.logger.info('on blacklist', objs2accounts(blacklist), blacklist);
	      options.onblacklist(blacklist);
	    }

	    if (mutelist) {
	      self.logger.info('on mutelist', objs2accounts(mutelist), mutelist);
	      options.onmutelist(mutelist);
	    }

	    if (friends) {
	      self.logger.info('on friends', objs2accounts(friends), friends);
	      options.onfriends(friends);
	    }

	    if (myInfo) {
	      self.logger.info('on myInfo', myInfo);
	      // 记录我的信息
	      self.myInfo = myInfo;
	      options.onmyinfo(util.copy(myInfo));
	    }

	    if (users) {
	      users.forEach(function (user) {
	        self.mergeUser(user);
	      });
	      self.logger.info('on users', objs2accounts(users), users);
	      options.onusers(users);
	    }

	    if (teams) {
	      self.logger.info('on teams', teams2ids(teams), teams);
	      options.onteams(teams);
	    }

	    // 第一次同步之后的后续同步, 因为是增量的
	    // 如果先同步到 sessions, 后同步到 msgReceipts
	    // 那就需要将 msgReceipts merge 到 sessions 里
	    // 需要为了安全起见 merge 一下
	    if (msgReceipts) {
	      if (!self.hasSynced && sessions && sessions.length || self.hasSynced) {
	        sessions = self.mergeSessionAndMsgReceipts(sessions, msgReceipts);
	      }
	    }

	    if (!!sessions && sessions.length) {
	      // 在这里存储所有初始化得到的会话, 能保证全
	      // 因为如果没有同步到会话, 会从数据库里取出会话
	      sessions.forEach(function (session) {
	        if (self.syncResult.sessions && self.syncResult.sessions[session.id] && typeof self.syncResult.sessions[session.id].unread === 'number') {
	          session.unread = self.syncResult.sessions[session.id].unread;
	        }
	        self.mergeSession(session);
	        Session.trim(session);
	      });
	      self.logger.info('on sessions', objs2ids(sessions), sessions);
	      options.onsessions(sessions);
	    }

	    if (roamingMsgs) {
	      roamingMsgs.forEach(function (i) {
	        timetags.push(i.timetag);
	        msgs = i.msgs;
	        // 判断一下长度, 有可能都被删了
	        if (msgs.length) {
	          self.logger.info('on roaming msgs', i.sessionId, msgs.length, msgs);
	          options.onroamingmsgs(i);
	        }
	      });
	    }

	    if (offlineMsgs) {
	      offlineMsgs.forEach(function (i) {
	        timetags.push(i.timetag);
	        msgs = i.msgs;
	        // 判断一下长度, 有可能都被删了
	        if (msgs.length) {
	          self.logger.info('on offline msgs', i.sessionId, msgs.length, msgs);
	          options.onofflinemsgs(i);
	        }
	      });
	    }

	    if (offlineFilterMsgs) {
	      offlineFilterMsgs.forEach(function (i) {
	        timetags.push(i.timetag);
	        msgs = i.msgs;
	        if (msgs.length) {
	          self.logger.info('on offline filter msgs', i.sessionId, msgs.length, msgs);
	          options.onofflinefiltermsgs(msgs);
	        }
	      });
	    }

	    // 撤回消息的系统通知
	    var deleteMsgSysMsgsRoaming = [];
	    var deleteMsgSysMsgsOffline = [];
	    if (result.deleteMsgSysMsgs) {
	      result.deleteMsgSysMsgs.forEach(function (obj) {
	        if (obj.type === 'roaming') {
	          deleteMsgSysMsgsRoaming = deleteMsgSysMsgsRoaming.concat(obj.sysMsgs);
	        } else {
	          deleteMsgSysMsgsOffline = deleteMsgSysMsgsOffline.concat(obj.sysMsgs);
	        }
	      });
	    }
	    if (deleteMsgSysMsgsRoaming.length) {
	      roamingSysMsgs = roamingSysMsgs || [];
	      roamingSysMsgs = roamingSysMsgs.concat(deleteMsgSysMsgsRoaming);
	    }
	    if (deleteMsgSysMsgsOffline.length) {
	      offlineSysMsgs = offlineSysMsgs || [];
	      offlineSysMsgs = offlineSysMsgs.concat(deleteMsgSysMsgsOffline);
	    }

	    if (roamingSysMsgs) {
	      self.logger.info('on roaming sys msgs', roamingSysMsgs.length, roamingSysMsgs);
	      options.onroamingsysmsgs(roamingSysMsgs);
	    }

	    if (offlineSysMsgs) {
	      self.logger.info('on offline sys msgs', offlineSysMsgs.length, offlineSysMsgs);
	      options.onofflinesysmsgs(offlineSysMsgs);
	    }

	    // 目前并没有这种类型的消息
	    if (offlineFilterSysMsgs) {
	      self.logger.info('on offline filter sys msgs', offlineFilterSysMsgs.length, offlineFilterSysMsgs);
	      options.onofflinefiltersysmsgs(offlineFilterSysMsgs);
	    }

	    if (offlineCustomSysMsgs) {
	      self.logger.info('on offline custom sys msgs', offlineCustomSysMsgs.length, offlineCustomSysMsgs);
	      options.onofflinecustomsysmsgs(offlineCustomSysMsgs);
	    }

	    if (offlineFilterCustomSysMsgs) {
	      self.logger.info('on offline filter custom sys msgs', offlineFilterCustomSysMsgs.length, offlineFilterCustomSysMsgs);
	      options.onofflinefiltercustomsysmsgs(offlineFilterCustomSysMsgs);
	    }

	    if (sysMsgUnread) {
	      sysMsgUnread = util.merge({}, self.sysMsgUnread, sysMsgUnread);
	      self.sysMsgUnread = util.merge({}, sysMsgUnread);
	      self.logger.info('on sysMsgUnread', sysMsgUnread);
	      options.onsysmsgunread(sysMsgUnread);
	    }

	    var pushNotificationMultiportConfig = self.getPushNotificationMultiportConfig();
	    self.logger.info('on pushNotificationMultiportConfig', pushNotificationMultiportConfig);
	    options.onPushNotificationMultiportConfig(pushNotificationMultiportConfig);

	    // timetags 时间戳数组长度为0 表示没有漫游消息和离线消息
	    // 如果没有漫游消息和离线消息, 不需要更新漫游消息时间戳
	    // 如果有, 需要更新漫游消息时间戳, 取所有漫游消息和离线消息里面最大的时间戳
	    if (timetags.length) {
	      timetag = Math.max.apply(Math, timetags);
	      self.updateRoamingMsgTimetag(timetag).then(bingo, bingo);
	    } else {
	      bingo();
	    }

	    // 清空同步缓存数据
	    self.syncPromiseArray = null;
	    self.syncResult = null;
	  }

	  function bingo() {
	    // 处理同步过程中的收发消息和系统通知, 处理完之后设置 syncing 为 false, 表示同步完成
	    self.processUnsettledMsgs();
	    self.processUnsettledSysMsgs();
	    // 设置 flag
	    self.syncing = false;

	    options.onsyncdone();

	    // 如果要同步群成员, 并且有群（全量或者增量）, 则同步群成员
	    // 如果不要同步群成员, 或者没有群（本来就没有群或者没有增量更新）, 当做群成员已经同步完成
	    if (options.syncTeamMembers && !!teams && !!teams.length) {
	      throw new NIMError('sync team members api deprecated!');
	      return;
	      // self.syncTeamMembers(teams)
	    } else {
	        // setTimeout(function () {
	        //   self.onSyncTeamMembersDone()
	        // }, 0)
	      }
	  }
	};

	IMProtocolFn.syncTeamMembers = function (teams) {
	  var self = this;
	  // var db = self.db
	  // if (db.enable) {
	  //   db.getTeamMemberTimetags().then(function (timetags) {
	  //     bingo(timetags)
	  //   }, function () {
	  //     bingo()
	  //   })
	  // } else {
	  //   bingo(self.timetags)
	  // }
	  bingo(self.timetags);
	  function bingo(timetags) {
	    var sync = {};
	    timetags = timetags || {};
	    teams.forEach(function (team) {
	      sync[team.teamId] = 0; // timetags['team-' + team.teamId] || 0
	    }, self);
	    self.sendCmd('syncTeamMembers', {
	      sync: sync
	    }, self.onSyncTeamMembers.bind(self));
	  }
	};

	IMProtocolFn.onSyncTeamMembers = function (error, obj) {
	  this.onMiscError(error, obj, 'sync teamMembers error');
	};

	/*
	 * - 同步时如果启用了数据库, 统一在同步完成后通知开发者
	 * - 同步时如果没启用数据库, 会在同步过程中通知开发者
	 * - 请参考 IMProtocol#onTeamMembers~getAll
	 */
	IMProtocolFn.onSyncTeamMembersDone = function () {
	  var self = this,
	      db = self.db,
	      options = self.options,
	      result = self.syncTeamMembersResult,
	      promiseArray = self.syncTeamMembersPromiseArray,
	      promise;

	  if (promiseArray.length) {
	    Promise.all(promiseArray).then(afterSync, function (e) {
	      self.onCustomError(e, 'SYNC_TEAM_MEMBERS_ERROR');
	    })['catch'](function (err) {
	      // ... 待修改
	      afterSync();
	    });
	  } else {
	    afterSync();
	  }

	  // 所有同步的 Promise 均已完成
	  function afterSync() {
	    self.logger.warn('after sync members', util.promises2cmds(promiseArray));
	    promiseArray = [];
	    // 如果启用了数据库, 并且还没有同步过, 那么从数据库获取全量数据
	    if (db.enable && !self.hasSyncedTeamMembers) {
	      self.hasSyncedTeamMembers = true;
	      pullFullData();
	    } else {
	      notifyData();
	    }
	  }

	  function pullFullData() {
	    // 如果不同步群或者不同步群成员, 则直接通知同步完成
	    if (!options.syncTeams || !options.syncTeamMembers) {
	      return bingo();
	    }
	    db.getTeams().then(function (teams) {
	      teams.forEach(function (team) {
	        var teamId = team.teamId;
	        promise = new Promise(function (resolve, reject) {
	          self.api.getTeamMembers({
	            teamId: teamId,
	            done: function done(err, obj) {
	              if (err) {
	                reject('sync team members error');
	              }
	              result[teamId] = obj.members || [];
	              resolve();
	            }
	          });
	        });
	        promiseArray.push(promise);
	      });
	      if (promiseArray.length) {
	        Promise.all(promiseArray).then(notifyData, function (e) {
	          self.onCustomError(e, 'SYNC_TEAM_MEMBERS_ERROR');
	        });
	      } else {
	        notifyData();
	      }
	    }, function (event) {
	      event._msg = 'on members error';
	      self.onDBError(event);
	    });
	  }

	  function notifyData() {
	    // 用 setTimeout 模拟异步线程
	    setTimeout(notifyDataAsync, 0);
	  }

	  function notifyDataAsync() {
	    var members, invalid;
	    Object.keys(result).forEach(function (teamId) {
	      if (teamId.indexOf('invalid') === -1) {
	        members = result[teamId];
	        invalid = result[teamId + '-invalid'] || [];
	        members.invalid = invalid;
	        onTeamMembers(teamId, members);
	      }
	    });
	    bingo();
	  }

	  function onTeamMembers(teamId, members) {
	    self.logger.info('on members', teamId, objs2accounts(members), members);
	    options.onteammembers({
	      teamId: teamId,
	      members: members
	    });
	  }

	  function bingo() {
	    self.logger.info('sync members done');
	    options.onsyncteammembersdone();
	    // 清空同步缓存数据
	    self.syncTeamMembersResult = null;
	    self.syncTeamMembersPromiseArray = null;
	  }
	};

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var IMProtocolFn = __webpack_require__(5).fn;
	var util = __webpack_require__(1);
	var SystemMessage = __webpack_require__(25);

	IMProtocolFn.splitSysMsgs = function (sysMsgs, customSysMsgs) {
	    var sysMsg;
	    for (var i = sysMsgs.length - 1; i >= 0; i--) {
	        sysMsg = sysMsgs[i];
	        if (SystemMessage.isCustom(sysMsg)) {
	            sysMsgs.splice(i, 1);
	            customSysMsgs.push(sysMsg);
	        }
	    }
	};

	// 收到离线系统通知
	// 不用调用 handleSysMsg, 因为同步的时候已经同步到这些变更了
	IMProtocolFn.onOfflineSysMsgs = function (packet, isFilter) {
	    var self = this;
	    var sysMsgs = packet.content.sysMsgs.map(function (sysMsg) {
	        sysMsg = SystemMessage.reverse(sysMsg);
	        if (isFilter) {
	            sysMsg.filter = true;
	        }
	        return sysMsg;
	    });
	    // 服务器返回的数据是按照时间从晚到早排序的, 但是一般UI上都是按照时间从早到晚排序的
	    sysMsgs = sysMsgs.reverse();
	    // 标记系统通知已读
	    self.markSysMsgRead(sysMsgs);
	    // 剥离出自定义系统通知
	    var customSysMsgs = [];
	    self.splitSysMsgs(sysMsgs, customSysMsgs);
	    var p1 = isFilter ? 'offlineFilterSysMsgs' : 'offlineSysMsgs';
	    var p2 = isFilter ? 'offlineFilterCustomSysMsgs' : 'offlineCustomSysMsgs';
	    // 存储离线系统通知
	    if (!!sysMsgs.length) {
	        var promise = self.putSysMsg(sysMsgs, 'offlineSysMsgs').then(function (records) {
	            // debugger;
	            // 这里返回的是过滤后的系统通知, 有可能为空数组
	            sysMsgs = records;
	            // 记录同步结果
	            if (!!sysMsgs.length) {
	                self.logger.warn('sync', p1, sysMsgs.length, sysMsgs);
	                self.syncResult[p1] = sysMsgs;
	            }
	        });
	        promise.cmd = 'sysMsgs';
	        self.syncPromiseArray.push(promise);
	    }
	    // 记录同步结果
	    if (!!customSysMsgs.length) {
	        self.logger.warn('sync ' + p2, customSysMsgs);
	        self.syncResult[p2] = customSysMsgs;
	    }
	};

	IMProtocolFn.onSendSysMsg = function (packet, isFilter) {
	    var self = this;
	    var sysMsg = packet.obj;
	    self.completeSysMsg(sysMsg);
	    if (!packet.error) {
	        sysMsg.status = 'success';
	    } else {
	        sysMsg.status = 'fail';
	    }
	    sysMsg = SystemMessage.reverse(sysMsg);
	    if (isFilter) {
	        packet.obj.filter = true;
	    }
	    packet.obj = sysMsg;
	};

	IMProtocolFn.completeSysMsg = function (sysMsg) {
	    sysMsg.from = this.account;
	    return sysMsg;
	};

	// 收到系统通知
	IMProtocolFn.onSysMsg = function (packet, isFilter) {
	    var self = this;
	    var sysMsg = SystemMessage.reverse(packet.content.sysMsg);
	    // 标记已读
	    self.markSysMsgRead(sysMsg);
	    // 是否是过滤
	    if (isFilter) {
	        sysMsg.filter = true;
	    }
	    // 处理系统通知
	    if (SystemMessage.isCustom(sysMsg)) {
	        self.logger.info('on customSysMsg', sysMsg);
	        self.options.oncustomsysmsg(sysMsg);
	    } else {
	        // 如果正在同步中, 那么先不处理系统通知, 等到同步完成之后再处理系统通知
	        if (self.syncing) {
	            self.unhandledSysMsgs.push(sysMsg);
	        } else {
	            self.handleSysMsg(sysMsg);
	        }
	    }
	};

	IMProtocolFn.handleSysMsg = function (sysMsg) {
	    var self = this;
	    var type = sysMsg.type;
	    var from = sysMsg.from;
	    self.sysMsgPromise = self.sysMsgPromise.then(function () {
	        // 存储系统通知
	        return self.putSysMsg(sysMsg, 'onSysMsg');
	    }).then(function (records) {
	        // 这里返回的是过滤后的系统通知, 有可能为空数组
	        sysMsg = records[0];
	    }).then(function () {
	        // debugger;
	        if (!sysMsg) {
	            return;
	        }
	        // 分类型处理
	        var obj;
	        var promise = Promise.resolve();
	        switch (type) {
	            case 'addFriend':
	                obj = {
	                    type: 'addFriend',
	                    account: from
	                };
	                promise = self.onFriendRequest(obj);
	                break;
	            case 'passFriendApply':
	                obj = {
	                    type: 'passFriendApply',
	                    account: from
	                };
	                promise = self.onFriendRequest(obj);
	                break;
	            case 'deleteFriend':
	                promise = self.onDeleteFriend({
	                    account: from
	                });
	                break;
	        }
	        if (obj && obj.friend) {
	            sysMsg.friend = obj.friend;
	        }
	        return promise;
	    }).then(function () {
	        // debugger;
	        if (!sysMsg) {
	            return;
	        }
	        // 通知系统通知
	        self.logger.info('on sysMsg', type, sysMsg);
	        setTimeout(function () {
	            self.options.onsysmsg(sysMsg);
	        }, 0);
	    });
	};

	/*
	 * 存储系统通知（不存自定义系统通知）
	 * - 收到离线系统通知
	 * - 收到系统通知
	 * 多 tab 页
	 * - 当支持多个 tab 同时登录时, 收到消息时, 只会在一个 tab 页里面存储这些消息, 其它 tab 页会存储失败
	 * - 存储成功的 tab 负责存储会话和更新未读数, 其它 tab 页也要计算自己的未读数(但是不能更新到数据库), 同时也要将消息推给开发者
	 * type
	 * - offlineSysMsgs
	 * - onSysMsg
	 */
	IMProtocolFn.putSysMsg = function (sysMsgs, type) {
	    // debugger;
	    if (!util.isArray(sysMsgs)) {
	        sysMsgs = [sysMsgs];
	    }
	    // 如果是过滤（云商服专用）, 直接返回
	    if (sysMsgs[0].filter) {
	        return Promise.resolve(sysMsgs);
	    }
	    var self = this;
	    var db = self.db;
	    var supportDb = db.enable;
	    var promise = Promise.resolve();
	    // 未计入未读数的消息
	    var uncoundSysMsgs = [];
	    // 存储并过滤
	    promise = promise.then(function () {
	        // debugger;
	        if (supportDb) {
	            return db.putSysMsg(sysMsgs);
	        } else {
	            return sysMsgs;
	        }
	    }).then(function (records) {
	        // debugger;
	        // 过滤出最终回传给用户的消息
	        var arr = [];
	        sysMsgs.forEach(function (sysMsg) {
	            if (self.checkSysMsgUnique(sysMsg)) {
	                arr.push(sysMsg);
	            }
	        });
	        sysMsgs = arr;
	        if (supportDb) {
	            // records 为存储到数据库的消息数组, 需要根据此数组来更新未读数
	            uncoundSysMsgs = records;
	        } else {
	            uncoundSysMsgs = sysMsgs;
	        }
	    });
	    promise = promise.then(function () {
	        // debugger;
	        // 获取未读数
	        return self.getSysMsgUnread().then(function (sysMsgUnread) {
	            // debugger;
	            // 如果未计入未读数的消息不为空数组, 说明此 tab 页负责存储消息
	            // 如果未计入未读数的消息为空数组, 则说明其它 tab 页已经存储过消息了, 但是依然需要重新计算未读数, 只是不能存储这个未读数
	            if (!uncoundSysMsgs.length) {
	                uncoundSysMsgs = sysMsgs;
	                uncoundSysMsgs.backward = true;
	            }
	            // 更新未读数
	            return self.updateSysMsgUnread(uncoundSysMsgs, sysMsgUnread, 1).then(function (sysMsgUnread) {
	                // debugger;
	                // 缓存未读数
	                if (type === 'offlineSysMsgs') {
	                    self.syncResult.sysMsgUnread = sysMsgUnread;
	                }
	                // 通知开发者, 未读数更新了
	                if (type === 'onSysMsg') {
	                    self.onUpdateSysMsgUnread(sysMsgUnread);
	                }
	            });
	        });
	    });
	    return promise.then(function () {
	        // 把过滤后的系统通知返回出去
	        return sysMsgs;
	    });
	};

	IMProtocolFn.checkSysMsgUnique = util.genCheckUniqueFunc('idServer');

	// 如果支持数据库, 那么从数据库拿未读记录
	// 如果不支持数据库, 那么从数据源获取未读记录
	IMProtocolFn.getSysMsgUnread = function () {
	    var self = this;
	    var db = self.db;
	    return new Promise(function (resolve) {
	        if (db.enable) {
	            db.getSysMsgUnread().then(function (records) {
	                resolve(records);
	            }, function () {
	                resolve(self.sysMsgUnread);
	            });
	        } else {
	            resolve(self.sysMsgUnread);
	        }
	    });
	};

	/*
	 * 更新系统通知未读数, 如果支持数据库, 更新数据库
	 * - 收到系统通知 delta 为 1
	 * - 主动标记系统通知 delta 为 -1
	 */
	IMProtocolFn.updateSysMsgUnread = function (sysMsgs, sysMsgUnread, delta) {
	    // debugger;
	    if (!util.isArray(sysMsgs)) {
	        sysMsgs = [sysMsgs];
	    }
	    if (!sysMsgs.length) {
	        return Promise.resolve(sysMsgUnread);
	    }
	    sysMsgUnread = sysMsgUnread || {};
	    var self = this;
	    var db = self.db;
	    var type;
	    sysMsgs.forEach(function (sysMsg) {
	        if (delta > 0 && !sysMsg.read || delta < 0 && sysMsg.read) {
	            type = sysMsg.type;
	            sysMsgUnread[type] = (sysMsgUnread[type] || 0) + delta;
	        }
	    });
	    sysMsgUnread = SystemMessage.completeUnread(sysMsgUnread);
	    // 更新后存起来
	    self.sysMsgUnread = sysMsgUnread;
	    // 如果落后, 那么不能存储未读数
	    if (db.enable && !sysMsgs.backward) {
	        return db.updateSysMsgUnread(sysMsgUnread);
	    } else {
	        return Promise.resolve(sysMsgUnread);
	    }
	};

	IMProtocolFn.reduceSysMsgUnread = function (sysMsgs) {
	    var self = this;
	    return self.getSysMsgUnread().then(function (sysMsgUnread) {
	        return self.updateSysMsgUnread(sysMsgs, sysMsgUnread, -1);
	    }).then(function (sysMsgUnread) {
	        self.onUpdateSysMsgUnread(sysMsgUnread);
	    });
	};

	IMProtocolFn.onUpdateSysMsgUnread = function (sysMsgUnread) {
	    var self = this;
	    setTimeout(function () {
	        self.logger.info('on update sysMsg unread', sysMsgUnread);
	        self.options.onupdatesysmsgunread(sysMsgUnread);
	    }, 0);
	};

	/*
	 * 更新系统消息, 如果支持数据库, 那么将变更写入数据库
	 * - 更新好友相关的系统消息的状态
	 * - 更新群相关的系统消息的状态
	 * 更新完后, 通知开发者
	 */
	IMProtocolFn.updateSysMsg = function (sysMsg) {
	    var self = this;
	    var db = self.db;
	    var promise;
	    if (db.enable) {
	        promise = db.updateSysMsg(sysMsg);
	    } else {
	        promise = Promise.resolve(sysMsg);
	    }
	    promise.then(function (sysMsg) {
	        self.onUpdateSysMsg(sysMsg);
	    });
	};

	IMProtocolFn.onUpdateSysMsg = function (sysMsgs) {
	    var self = this;
	    setTimeout(function () {
	        if (!util.isArray(sysMsgs)) {
	            sysMsgs = [sysMsgs];
	        }
	        sysMsgs.forEach(function (sysMsg) {
	            self.logger.info('on update sysMsg', sysMsg);
	            self.options.onupdatesysmsg(sysMsg);
	        });
	    }, 0);
	};

	IMProtocolFn.processUnsettledSysMsgs = function () {
	    var self = this;
	    self.unhandledSysMsgs.forEach(function (sysMsg) {
	        self.handleSysMsg(sysMsg);
	    });
	    self.resetUnsettledSysMsgs();
	};

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var IMProtocolFn = __webpack_require__(5).fn;
	var util = __webpack_require__(1);
	var objs2accounts = util.objs2accounts;
	var teams2ids = util.teams2ids;
	var Team = __webpack_require__(26);
	var TeamMember = __webpack_require__(20);

	/**
	 * 处理群协议
	 */
	IMProtocolFn.processTeam = function (packet) {
	  var self = this;
	  var error = packet.error;
	  var team = void 0;
	  var member = void 0;
	  var owner = void 0;
	  switch (packet.cmd) {
	    case 'createTeam':
	      team = packet.obj.team;
	      if (!error) {
	        team = packet.content.team;
	      }
	      team = Team.reverse(team);
	      packet.obj.team = team;
	      owner = TeamMember.assembleOwner(team);
	      packet.obj.owner = owner;
	      if (!error) {
	        var obj = {
	          team: team,
	          owner: owner
	        };
	        self.logger.info('on create team', obj);
	        self.options.onCreateTeam(obj);
	        self.onCreateTeam(team, owner);
	      }
	      break;
	    case 'syncCreateTeam':
	      team = Team.reverse(packet.content.team);
	      owner = TeamMember.assembleOwner(team);
	      self.logger.info('on sync createTeam', team, owner);
	      self.options.onsynccreateteam(team, owner);
	      self.onCreateTeam(team, owner);
	      break;
	    case 'sendTeamMsg':
	      self.onSendMsg(packet);
	      break;
	    case 'teamMsg':
	      self.onMsg(packet);
	      break;
	    case 'teamMsgs':
	      self.onMsgs(packet);
	      break;
	    case 'addTeamMembers':
	    case 'removeTeamMembers':
	    case 'leaveTeam':
	    case 'dismissTeam':
	    case 'addTeamManagers':
	    case 'removeTeamManagers':
	    case 'transferTeam':
	      break;
	    case 'updateInfoInTeam':
	      if (!error) {
	        member = packet.obj;
	        member.account = self.account;
	        member.id = TeamMember.genId(member.teamId, member.account);
	        member = TeamMember.reverse(member);
	        packet.obj = member;
	        self.mergeMyTeamMembers(member);
	        self.onUpdateTeamMember(member);
	      }
	      break;
	    case 'updateNickInTeam':
	      packet.obj = TeamMember.reverse(packet.obj);
	      break;
	    case 'updateTeam':
	      packet.obj = Team.reverse(packet.obj, true);
	      break;
	    case 'applyTeam':
	      if (!packet.error) {
	        packet.obj = Team.reverse(packet.content.team);
	      }
	      break;
	    case 'passTeamApply':
	      self.updateTeamSysMsgState(packet, 'passed');
	      break;
	    case 'rejectTeamApply':
	      self.updateTeamSysMsgState(packet, 'rejected');
	      break;
	    case 'acceptTeamInvite':
	      self.updateTeamSysMsgState(packet, 'passed');
	      if (!packet.error) {
	        packet.obj = Team.reverse(packet.content.team);
	      }
	      break;
	    case 'rejectTeamInvite':
	      self.updateTeamSysMsgState(packet, 'rejected');
	      break;
	    case 'getTeam':
	      if (!packet.error) {
	        packet.obj = Team.reverse(packet.content.team);
	      }
	      break;
	    case 'getTeams':
	      self.onTeams(packet);
	      break;
	    case 'getTeamMembers':
	      self.onTeamMembers(packet);
	      break;
	    case 'syncTeams':
	      self.onTeams(packet);
	      break;
	    case 'syncTeamMembers':
	      self.onTeamMembers(packet);
	      break;
	    case 'getTeamHistoryMsgs':
	    case 'searchTeamHistoryMsgs':
	      self.onHistoryMsgs(packet);
	      break;
	    case 'syncSendTeamMsg':
	      self.onMsg(packet);
	      break;
	    // 在其他端更新了自己的群信息
	    // 在其他端更新了别人的群信息
	    // 更新别人的群昵称
	    // 都会走这里
	    case 'syncUpdateTeamMember':
	      member = TeamMember.reverse(packet.content.teamMember);
	      self.onUpdateTeamMember(member);
	      // 如果是更新自己, 那么存储数据
	      if (member.account === self.account) {
	        self.mergeMyTeamMembers(member);
	      }
	      break;
	    case 'updateMuteStateInTeam':
	      break;
	    case 'getMyTeamMembers':
	      if (!packet.error) {
	        packet.obj = TeamMember.reverseMembers(packet.content.teamMembers);
	      }
	      break;
	    case 'getMutedTeamMembers':
	      if (!packet.error) {
	        packet.obj = {
	          teamId: packet.obj.teamId,
	          members: TeamMember.reverseMembers(packet.content.teamMembers)
	        };
	      }
	      break;
	    case 'syncMyTeamMembers':
	      self.onSyncMyTeamMembers(packet);
	      break;
	    default:
	      break;
	  }
	};

	IMProtocolFn.onCreateTeam = function (team, owner) {
	  var db = this.db;
	  if (db.enable) {
	    db.putTeam(team);
	    db.putTeamMembers(owner);
	  }
	};

	/*
	 * 处理群, 同步和主动获取都会走这个逻辑
	 */
	IMProtocolFn.onTeams = function (packet) {
	  packet.content = packet.content || {};
	  var self = this;
	  var db = self.db;
	  // 有同步和主动获取两种情况
	  var isSync = self.packetFromSync(packet);
	  var rawTeams = packet.content.teams || [];
	  var hasChange = true;
	  var timetag;
	  var teams = [];
	  var invalidTeams = [];

	  if (packet.error) {
	    switch (packet.error.code) {
	      // 没有获取到增量更新
	      case 803:
	        packet.error = null;
	        hasChange = false;
	        break;
	    }
	  }

	  // 用于同步的Promise
	  var promise = new Promise(function (resolve, reject) {
	    if (!packet.error) {
	      // 处理数据
	      parseData();
	      // 如果支持数据库, 那么合并数据, 否则直接 bingo
	      if (db.enable) {
	        mergeData(resolve, reject);
	      } else {
	        bingo();
	        resolve();
	      }
	    } else if (isSync) {
	      // 同步时应该没有error, 所以这里应该走不到
	      reject(packet.error);
	    }
	  });

	  if (isSync) {
	    promise.cmd = 'teams';
	    self.syncPromiseArray.push(promise);
	  }

	  function parseData() {
	    if (hasChange) {
	      rawTeams.forEach(function (team) {
	        team = Team.reverse(team);
	        if (team.validToCurrentUser) {
	          teams.push(team);
	        } else {
	          invalidTeams.push(team);
	        }
	      });
	    }
	    self.logger.warn('parse teams', teams2ids(teams), teams, 'invalid', teams2ids(invalidTeams), invalidTeams);
	    if (!rawTeams.length) {
	      hasChange = false;
	    } else {
	      hasChange = true;
	      timetag = packet.content.timetag;
	    }
	  }

	  function mergeData(resolveSync, rejectSync) {
	    // 设置用于主动获取的 Promise, 在 callPacketAckCallback 里面使用
	    packet.promise = new Promise(function (resolve, reject) {
	      if (hasChange) {
	        // 增量更新数据库
	        db.mergeTeams(teams, invalidTeams, timetag).then(function () {
	          afterMergeData();
	        }).then(undefined, function (event) {
	          event._msg = 'merge teams error';
	          reject(event);
	          rejectSync(event);
	        });
	      } else {
	        self.logger.warn('no merge teams');
	        afterMergeData();
	      }
	      function afterMergeData() {
	        if (!isSync) {
	          db.getTeams().then(function (records) {
	            teams = records;
	            bingo();
	            resolve();
	            resolveSync();
	          }).then(undefined, function (event) {
	            event._msg = 'get teams error';
	            reject(event);
	            rejectSync(event);
	          });
	        } else {
	          bingo();
	          resolve();
	          resolveSync();
	        }
	      }
	    }).then(undefined, function (event) {
	      event._msg = 'merge teams data error';
	      rejectSync(event);
	      throw event;
	    });
	  }

	  function bingo() {
	    self.timetags.teams = timetag;
	    teams.invalid = invalidTeams;
	    // 返回数据
	    if (isSync) {
	      // 如果是同步, 那么统一在 onSyncDone 里面通知开发者
	      self.syncResult.teams = teams;
	      self.syncResult.invalidTeams = invalidTeams;
	    } else {
	      self.logger.warn('get teams', teams2ids(teams), teams);
	      packet.obj = teams;
	    }
	  }
	};

	// TODO 同步的时候不存储群成员和时间戳, 等所有的群成员同步完成之后再存储, 这样可以减少数据库操作
	IMProtocolFn.onTeamMembers = function (packet) {
	  packet.content = packet.content || {};
	  var self = this;
	  var db = self.db;
	  // 有同步和主动获取两种情况
	  var isSync = self.packetFromSync(packet);
	  var rawMembers = packet.content.members || [];
	  var hasChange = true;
	  var timetag;
	  var teamId;
	  var members = [];
	  var invalidMembers = [];

	  // 获取 teamId
	  if (packet.obj) {
	    teamId = packet.obj.teamId;
	  }

	  if (!teamId) {
	    teamId = packet.content.teamId;
	  }
	  teamId = '' + teamId;

	  if (packet.error) {
	    switch (packet.error.code) {
	      // 没有获取到增量更新
	      case 406:
	        packet.error = null;
	        hasChange = false;
	        break;
	    }
	  }

	  // 用于同步的Promise
	  var promise = new Promise(function (resolve, reject) {
	    if (!packet.error) {
	      // 处理数据
	      parseData();
	      // 如果支持数据库, 那么合并数据, 否则直接 bingo
	      // if (db.enable) {
	      //   mergeData(resolve, reject)
	      // } else {
	      //   bingo()
	      //   resolve()
	      // }
	      bingo();
	      resolve();
	    } else if (isSync) {
	      // 同步时应该没有error, 所以这里应该走不到
	      reject(packet.error + ' teamId: ' + teamId);
	    }
	  });
	  if (isSync) {
	    promise.cmd = teamId;
	    self.syncTeamMembersPromiseArray.push(promise);
	  }

	  function parseData() {
	    if (hasChange) {
	      rawMembers.forEach(function (member) {
	        member = TeamMember.reverse(member);
	        if (member.valid) {
	          members.push(member);
	        } else {
	          invalidMembers.push(member);
	        }
	      });
	    }
	    self.logger.warn('parse members', teamId, objs2accounts(members), members, 'invalid', objs2accounts(invalidMembers), invalidMembers);
	    if (!rawMembers.length) {
	      hasChange = false;
	    } else {
	      hasChange = true;
	      timetag = packet.content.timetag;
	    }
	  }

	  // function mergeData (resolveSync, rejectSync) {
	  //   // 设置用于主动获取的 Promise, 在 callPacketAckCallback 里面使用
	  //   packet.promise = new Promise(function (resolve, reject) {
	  //     if (hasChange) {
	  //       // 增量更新数据库
	  //       db.mergeTeamMembers(teamId, members, invalidMembers, timetag).then(function () {
	  //         afterMergeData()
	  //       }).then(undefined, function (event) {
	  //         event._msg = 'merge members error ' + teamId
	  //         reject(event)
	  //         rejectSync(event)
	  //       })
	  //     } else {
	  //       self.logger.warn('no merge members', teamId)
	  //       afterMergeData()
	  //     }
	  //     function afterMergeData () {
	  //       if (!isSync) {
	  //         db.getTeamMembers(teamId).then(function (records) {
	  //           members = records
	  //           bingo()
	  //           resolve()
	  //           resolveSync()
	  //         }).then(undefined, function (event) {
	  //           event._msg = 'get members error'
	  //           reject(event)
	  //           rejectSync(event)
	  //         })
	  //       } else {
	  //         bingo()
	  //         resolve()
	  //         resolveSync()
	  //       }
	  //     }
	  //   }).then(undefined, function (event) {
	  //     event._msg = 'merge members data error'
	  //     rejectSync(event)
	  //     throw event
	  //   })
	  // }

	  function bingo() {
	    members.invalid = invalidMembers;
	    // 返回数据
	    if (isSync) {
	      // 如果是同步, 那么统一在 onSyncTeamMembersDone 里面通知开发者
	      self.syncTeamMembersResult[teamId] = members;
	      self.syncTeamMembersResult[teamId + '-invalid'] = invalidMembers;
	      self.timetags['team-' + teamId] = timetag;
	    } else {
	      self.logger.warn('get members', teamId, objs2accounts(members), members);
	      packet.obj = {
	        teamId: teamId,
	        members: members
	      };
	    }
	  }
	};

	IMProtocolFn.onUpdateTeamMember = function (member) {
	  var self = this;
	  if (!member.updateTime) {
	    member.updateTime = +new Date();
	  }
	  self.logger.warn('parse update member', member);
	  self.logger.info('on update teamMember', member);
	  self.options.onupdateteammember(util.simpleClone(member));
	  var team = {
	    teamId: member.teamId,
	    memberUpdateTime: member.updateTime
	  };
	  self.onUpdateTeam(team);
	  var db = this.db;
	  if (db.enable) {
	    db.updateTeamMember(member);
	  }
	};

	IMProtocolFn.onUpdateTeam = function (team) {
	  var self = this;
	  self.logger.info('on update team', team);
	  self.options.onUpdateTeam(util.simpleClone(team));
	  var db = self.db;
	  if (db.enable) {
	    db.updateTeam(team);
	  }
	};

	// 同步到所有群里面我的群成员信息
	// 这里不用存储时间戳, 无意义
	IMProtocolFn.onSyncMyTeamMembers = function (packet) {
	  var self = this;
	  var db = self.db;
	  var teamMembers = TeamMember.reverseMembers(packet.content.teamMembers);
	  self.logger.warn('parse my team members', teamMembers);
	  if (db.enable) {
	    var promise = db.putTeamMembers(teamMembers).then(function () {
	      return db.updateMyTeamMembersTimetag(packet.content.timetag);
	    });
	    promise.cmd = 'myTeamMembers';
	    self.syncTeamMembersPromiseArray.push(promise);
	  }
	  self.mergeMyTeamMembers(teamMembers);
	};

	// 存储我的群成员信息
	IMProtocolFn.mergeMyTeamMembers = function (teamMembers) {
	  if (!util.isArray(teamMembers)) {
	    teamMembers = [teamMembers];
	  }
	  var self = this;
	  var myTeamMembersMap = self.myTeamMembersMap = self.myTeamMembersMap || {};
	  teamMembers.forEach(function (member) {
	    var teamId = member.teamId;
	    myTeamMembersMap[teamId] = util.merge(myTeamMembersMap[teamId], member);
	  });
	  self.logger.warn('cache my team members', myTeamMembersMap);
	};

	/**
	 * 是否需要群消息通知
	 * @private
	 * 如果没有我的群成员信息, 那么从服务器拉取
	 */
	IMProtocolFn.notifyForNewTeamMsg = function (teamIds) {
	  if (!util.isArray(teamIds)) {
	    teamIds = [teamIds];
	  }
	  var self = this;
	  var myTeamMembersMap = this.myTeamMembersMap || {};
	  // 如果现有数据没有, 需要从服务器拉取
	  var map = {};
	  var missing = [];
	  teamIds.forEach(function (teamId) {
	    if (util.exist(myTeamMembersMap[teamId])) {
	      map[teamId] = !myTeamMembersMap[teamId].muteTeam;
	    } else {
	      missing.push(teamId);
	    }
	  });
	  var promise = Promise.resolve(map);
	  if (!!missing.length) {
	    promise = self.api.getMyTeamMembers({
	      teamIds: missing,
	      promise: true
	    }).then(function (teamMembers) {
	      self.mergeMyTeamMembers(teamMembers);
	      teamMembers.forEach(function (member) {
	        map[member.teamId] = !member.muteTeam;
	      });
	      return map;
	    });
	  }
	  return promise;
	};

	/*
	 * 更新群系统通知的状态
	 * - 通过入群申请
	 * - 拒绝入群申请
	 * - 通过入群邀请
	 * - 拒绝入群邀请
	 */
	IMProtocolFn.updateTeamSysMsgState = function (packet, state) {
	  var error = packet.error;
	  var sysMsg;

	  // 处理错误
	  if (error) {
	    state = 'error';
	    error = util.filterObj(error, 'code message');
	  }

	  sysMsg = {
	    idServer: packet.obj.idServer,
	    state: state
	  };
	  if (error) {
	    sysMsg.error = error;
	  }
	  this.updateSysMsg(sysMsg);
	};

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(2).Promise;
	var IMProtocolFn = __webpack_require__(5).fn;
	var util = __webpack_require__(1);
	var objs2accounts = util.objs2accounts;
	var SpecialRelation = __webpack_require__(144);
	var User = __webpack_require__(32);

	IMProtocolFn.processUser = function (packet) {
	    var self = this,
	        db = self.db,
	        obj = packet.obj,
	        error = packet.error,
	        content = packet.content,
	        users;

	    switch (packet.cmd) {
	        // 加入黑名单/从黑名单移除
	        case 'markInBlacklist':
	            if (!error) {
	                self.markInBlacklist(obj);
	            }
	            break;
	        case 'syncMarkInBlacklist':
	            self.markInBlacklist(content, true);
	            break;
	        // 加入静音列表/从静音列表移除
	        case 'markInMutelist':
	            if (!error) {
	                self.markInMutelist(obj);
	            }
	            break;
	        case 'syncMarkInMutelist':
	            self.markInMutelist(content, true);
	            break;
	        // 获取黑名单和静音列表
	        case 'getRelations':
	            if (!error) {
	                self.onRelations(packet);
	            }
	            break;
	        case 'syncMyInfo':
	            self.onMyInfo(packet, true);
	            break;
	        case 'updateMyInfo':
	            if (!error) {
	                obj.updateTime = content.timetag;
	                self.onUpdateMyInfo(packet, obj);
	            }
	            break;
	        case 'syncUpdateMyInfo':
	            self.onUpdateMyInfo(packet, content.user, true);
	            break;
	        case 'getUsers':
	            if (!error) {
	                users = content.users.map(function (user) {
	                    user = User.reverse(user);
	                    self.mergeUser(user);
	                    return user;
	                });
	                packet.obj = users;
	                if (db.enable) {
	                    db.putUsers(users);
	                }
	            }
	            break;
	        case 'updateDonnop':
	            self.onUpdateDonnop(packet);
	            break;
	        case 'syncUpdateDonnop':
	            self.onDonnop(packet, false);
	            break;
	        default:
	            break;
	    }
	};

	/*
	 * 处理我的信息
	 */
	IMProtocolFn.onMyInfo = function (packet) {
	    var self = this;
	    var db = self.db;
	    var error = packet.error;
	    var content = packet.content;
	    var isSync = true;
	    var user = void 0;

	    // 用于同步的Promise
	    var promise = new Promise(function (resolve, reject) {
	        if (!error) {
	            // 处理数据
	            parseData();
	            // 如果支持数据库, 那么合并数据, 否则直接 bingo
	            if (db.enable) {
	                mergeData(resolve, reject);
	            } else {
	                bingo();
	                resolve();
	            }
	        } else if (isSync) {
	            // 同步时应该没有error, 所以这里应该走不到
	            // reject(error);
	            resolve(error);
	            self.syncData();
	        }
	    });
	    if (isSync) {
	        promise.cmd = 'myInfo';
	        self.syncPromiseArray.push(promise);
	    }

	    function parseData() {
	        user = User.reverse(content.user);
	        self.logger.warn('parse myInfo', user);
	    }

	    function mergeData(resolveSync, rejectSync) {
	        // 不用设置用于主动获取的 Promise
	        db.mergeMyInfo(user, isSync).then(function () {
	            bingo();
	            resolveSync();
	        }).then(undefined, function (event) {
	            event._msg = 'merge myInfo error';
	            rejectSync(event);
	        });
	    }

	    function bingo() {
	        self.timetags.myInfo = user.updateTime;
	        if (isSync) {
	            // 如果是同步, 那么统一在 onSyncDone 里面通知开发者
	            self.syncResult.myInfo = user;
	        }
	    }
	};

	/**
	 * 更新我的信息
	 * @private
	 * @param  {Object}  user     增量的用户信息
	 * @param  {Boolean} isSynced 是否是多端同步
	 */
	IMProtocolFn.onUpdateMyInfo = function (packet, obj, isSynced) {
	    var self = this;
	    var db = self.db;
	    var userUpdate = User.reverse(obj);
	    var user = util.merge(self.myInfo, userUpdate);
	    self.myInfo = user;
	    // 如果是多端同步, 那么通知开发者
	    if (isSynced) {
	        self.logger.info('on update myInfo', user);
	        self.options.onupdatemyinfo(user);
	    } else {
	        packet.obj = user;
	    }
	    if (db.enable) {
	        userUpdate.account = self.account;
	        db.updateUser(userUpdate);
	    }
	};

	/*
	 * 处理黑名单和静音列表, 同步和主动获取都会走这个逻辑
	 */
	IMProtocolFn.onRelations = function (packet) {
	    var self = this;
	    var db = self.db;
	    var error = packet.error;
	    // 有同步和主动获取两种情况
	    var isSync = self.packetFromSync(packet);
	    var rawRelations = packet.content.specialRelations;
	    var hasChange = true;
	    var timetag = void 0;
	    var blacklist = [];
	    var invalidBlacklist = [];
	    var mutelist = [];
	    var invalidMutelist = [];

	    // 用于同步的Promise
	    var promise = new Promise(function (resolve, reject) {
	        if (!error) {
	            // 处理数据
	            parseData();
	            // 如果支持数据库, 那么合并数据, 否则直接 bingo
	            if (db.enable) {
	                mergeData(resolve, reject);
	            } else {
	                bingo();
	                resolve();
	            }
	        } else if (isSync) {
	            // 同步时应该没有error, 所以这里应该走不到
	            // reject(error)
	            resolve(error);
	            self.syncData();
	        }
	    });
	    if (isSync) {
	        promise.cmd = 'relations';
	        self.syncPromiseArray.push(promise);
	    }

	    function parseData() {
	        rawRelations.forEach(function (sr) {
	            sr = SpecialRelation.parse(sr);
	            var item = {
	                account: sr.account,
	                createTime: sr.createTime,
	                updateTime: sr.updateTime
	            };
	            if (sr.isBlacked) {
	                blacklist.push(item);
	            } else {
	                invalidBlacklist.push(item);
	            }
	            if (sr.isMuted) {
	                mutelist.push(item);
	            } else {
	                invalidMutelist.push(item);
	            }
	        });
	        self.logger.warn('parse blacklist', objs2accounts(blacklist), blacklist, 'delete', objs2accounts(invalidBlacklist), invalidBlacklist);
	        self.logger.warn('parse mutelist', objs2accounts(mutelist), mutelist, 'delete', objs2accounts(invalidMutelist), invalidMutelist);
	        if (!rawRelations.length) {
	            hasChange = false;
	        } else {
	            hasChange = true;
	            timetag = packet.content.timetag;
	        }
	    }

	    function mergeData(resolveSync, rejectSync) {
	        // 设置用于主动获取的 Promise, 在 callPacketAckCallback 里面使用
	        packet.promise = new Promise(function (resolve, reject) {
	            if (hasChange) {
	                // 增量更新数据库
	                db.mergeRelations(blacklist, invalidBlacklist, mutelist, invalidMutelist, timetag).then(function () {
	                    afterMergeData();
	                }).then(undefined, function (event) {
	                    event._msg = 'merge relations error';
	                    reject(event);
	                    rejectSync(event);
	                });
	            } else {
	                self.logger.warn('no merge relations');
	                afterMergeData();
	            }
	            function afterMergeData() {
	                // 如果不是同步, 那么需要获取完整的列表
	                if (!isSync) {
	                    db.getRelations().then(function (result) {
	                        blacklist = result[0];
	                        mutelist = result[1];
	                        bingo();
	                        resolve();
	                        resolveSync();
	                    }).then(undefined, function (event) {
	                        event._msg = 'get relations error';
	                        reject(event);
	                        rejectSync(event);
	                    });
	                } else {
	                    bingo();
	                    resolve();
	                    resolveSync();
	                }
	            }
	        }).then(undefined, function (event) {
	            event._msg = 'merge relations data error';
	            rejectSync(event);
	            throw event;
	        });
	    }

	    function bingo() {
	        self.timetags.relations = timetag;
	        blacklist.invalid = invalidBlacklist;
	        mutelist.invalid = invalidMutelist;
	        // 返回数据
	        if (isSync) {
	            // 如果是同步, 那么统一在onSyncDone里面通知开发者
	            self.syncResult.blacklist = blacklist;
	            self.syncResult.mutelist = mutelist;
	            self.syncResult.invalidBlacklist = invalidBlacklist;
	            self.syncResult.invalidMutelist = invalidMutelist;
	        } else {
	            self.logger.warn('get relations', blacklist, mutelist);
	            packet.obj.blacklist = blacklist;
	            packet.obj.mutelist = mutelist;
	        }
	    }
	};

	/**
	 * 标记黑名单
	 * @private
	 * @param  {Object}  obj      请求对象
	 * @param  {Boolean} isSynced 是否是多端同步
	 * @return {Void}
	 */
	IMProtocolFn.markInBlacklist = function (obj, isSynced) {
	    var self = this;
	    var db = self.db;
	    obj.record = {
	        account: obj.account,
	        updateTime: +new Date()
	    };
	    if (db.enable) {
	        db.markInBlacklist(obj);
	    }
	    if (isSynced) {
	        self.logger.info('on sync markInBlacklist', obj);
	        self.options.onsyncmarkinblacklist(obj);
	    }
	};

	/**
	 * 标记静音列表
	 * @private
	 * @param  {Object}  obj      请求对象
	 * @param  {Boolean} isSynced 是否是多端同步
	 * @return {Void}
	 */
	IMProtocolFn.markInMutelist = function (obj, isSynced) {
	    var self = this;
	    var db = self.db;
	    obj.record = {
	        account: obj.account,
	        updateTime: +new Date()
	    };
	    if (db.enable) {
	        db.markInMutelist(obj);
	    }
	    if (isSynced) {
	        self.logger.info('on sync markInMutelist', obj);
	        self.options.onsyncmarkinmutelist(obj);
	    }
	};

	IMProtocolFn.mergeUser = function (user) {
	    this.userSet[user.account] = user;
	};

/***/ }
/******/ ])
});
;